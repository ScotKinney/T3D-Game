//-------------------------- 2/2/2015 -- 23:20:27 -----
namespace Global {

   /*! @name ServerQuery
   
   Functions which allow you to query the LAN or a master server for online games.
   @{ */
   /*! */
   /*! queryAllServers(...); */
   virtual void queryAllServers() {}
   /*! queryLanServers(...); */
   virtual void queryLanServers() {}
   /*! queryMasterServer(...); */
   virtual void queryMasterServer() {}
   /*! querySingleServer(address, flags); */
   virtual void querySingleServer() {}
   /*! cancelServerQuery() */
   virtual void cancelServerQuery() {}
   /*! stopServerQuery() */
   virtual void stopServerQuery() {}
   /*! startHeartbeat() */
   virtual void startHeartbeat() {}
   /*! stopHeartbeat(); */
   virtual void stopHeartbeat() {}
   /*! getServerCount(); */
   virtual int getServerCount() {}
   /*! setServerInfo(index); */
   virtual bool setServerInfo() {}
   /// @}

   virtual void Remote_InspectorChangeValue(( SimObject obj, string fieldname, int arrayindex, string newvalue="" )) {}
   virtual void Remote_SelectItem(( SimObject obj, string pass="" )) {}
   virtual void Remote_DeleteItem(( SimObject obj=0 )) {}
   virtual void Remote_SetCameraSpeed(( float speed=40 )) {}
   virtual void Remote_SaveMission(()) {}
   virtual void GetDatablocks(( string classname="", string classnamealt="", int passedthis=0, int ctrlidx=0, int passedindex=0 )) {}
   /*! Sends a message to the server to be executed.
 */
   virtual void SendRemoteRun(( string msg )) {}
   /*! Test call for users to submit files */
   virtual void SubmitFile(( String fileName )) {}
   /*! aiAddPlayer( 'playerName'[, 'AIClassType'] ); */
   virtual int aiAddPlayer() {}
   /*! Null */
   virtual void DumpIPSBenchmark(()) {}
   virtual void IPSSDMUnbindMouse(()) {}
   virtual string getObjectAtCursor(( int TypeMask=U32_MAX, bool Debug=false )) {}
   virtual void initializePointAndClickSystem((  void )) {}
   virtual bool setTarget(( NetObject obj=NULL, bool isServerObject=false )) {}
   virtual string getTarget(( NetConnection conn=NULL )) {}
   virtual bool AttachSpellManager(( SceneObject Obj, NetConnection Client=NULL )) {}
   virtual bool CreateTargetIndicator(( SimDataBlock data=NULL )) {}
   virtual void ThrowHomingProjectile(( ShapeBase src=NULL, SceneObject tgt=NULL, SpellProjectileData dat=NULL, bool IgnoreCollisions=true )) {}
   virtual string ThrowHomingBezierProjectile(( ShapeBase src=NULL, SceneObject tgt=NULL, BezierProjectileData dat=NULL, bool IgnoreCollisions=true, Point3F weights=Point3F(0) )) {}
   virtual string ThrowBezierProjectile(( ShapeBase src=NULL, Point3F end=Point3F(0), BezierProjectileData dat=NULL, bool IgnoreCollisions=true, Point3F weights=Point3F(0) )) {}
   virtual bool CastSpellOnServer(( SpellData dat=NULL )) {}
   virtual void DrawTimedDebugVector(( Point3F Start, Point3F End, int numFrames, ColorI Col=ColorI(gRandGen.randI() % 255, gRandGen.randI() % 255, gRandGen.randI() % 255) )) {}
   virtual void executeJavaScriptOnTAPLink(( string cmd )) {}
   /*! getFileMD5(file) */
   virtual string getFileMD5() {}
   /*! getStringMD5(string) */
   virtual string getStringMD5() {}
   /*! Initializes the Mumble voice chat sub system.
@ingroup Mumble
 */
   virtual void InitMumble(()) {}
   /*! Disconnects the voice chat system and shuts down mumble.
@ingroup Mumble
 */
   virtual void ShutdownMumble(()) {}
   /*! Called to execute a local instance of mumble.exe.
userName - (text) The players in-game name.
Returns true if mumble is running.@ingroup Mumble
 */
   virtual bool LaunchMumble(( string userName="Anon" )) {}
   /*! Called to establish a Mumble link when the player lands on a game server.
serverName - (text) String that identifies the game server.
playerID - (int) The player's identification number.
Returns true if a mumble link has been established.@ingroup Mumble
 */
   virtual bool MumbleJoinGame(( string serverName="SkyCity", string playerID="00000" )) {}
   /*! Informs Mumble that the player has left a game server.
@ingroup Mumble
 */
   virtual void MumbleLeaveGame(()) {}
   /*! Sets the listener position for mumble.
ID - The ID of the client object to use when determining position and direction.@ingroup Mumble
 */
   virtual void UpdateMumblePos(( SimObjectId ID=NULL )) {}
   /*! Sets the Mumble context string. Context should be equal for players which should be able to hear each other positional and differ for those who shouldn't (e.g. it could contain the server+port and team).
contextStr - The string value to use.
clearPos - (bool) true if the 3D position should be reset to the default.@ingroup Mumble
 */
   virtual void SetMumbleContext(( string contextStr="Lobby", bool clearPos=true )) {}
   /*! Sets the position mode for mumble. The mode determines what values are used to represent the camera and avatar positions passed to Mumble.
modeType - (int) 0-2.
           0 = Player and Camera values are used.
           1 = Only Player values are used.
           2 = Only Camera values are used.
@ingroup Mumble
 */
   virtual void SetMumbleMode(( int modeType=0 )) {}
   /*! Return the current local time as: month day year hour min sec.

Local time is platform defined. */
   virtual string getLocalTime() {}
   /*! Return the current local time as: hour:min:sec.

Local time is platform defined. */
   virtual string getTimeStr() {}
   /*! Returns the current platform time in seconds

 */
   virtual int getTimeSec() {}
   /*! Calculate the square of the distance between a and b. */
   virtual float VectorDistSquared((Vector3F a, Vector3F b)) {}
   /*! Calculate the square of the length of a vector. */
   virtual float VectorLenSquared((Vector3F v)) {}
   /*! Calculate the square of the distance between a and b. */
   virtual float VectorXYDistSquared((Vector3F a, Vector3F b)) {}
   /*! is this a dev build of the game? */
   virtual bool isDevBuild(()) {}
   /*! Return the passed time converted to the local timezone as: month/day/year hour:min.

 */
   virtual string convertToLocalTime((string timestr)) {}
   /*! @brief Sets the material to use when rendering the gui curtain layer.
@param matName name of material.
 */
   virtual bool setGuiCurtainMat(( String matName )) {}
   /*! @brief Sets the scale for the gui curtain layer.
@param scale (Point3F).
 */
   virtual void setGuiCurtainScale(( Point3F scale )) {}
   /*! @brief Sets the maximum head rotation angles for sliding the gui curtain layer.
@param maxRot (Point3F) Euler rotation values in radians. Only the x and z values are used.
 */
   virtual void setGuiCurtainMaxRot(( Point3F maxRot )) {}
   /*! @brief Sets the scale for the hud curtain layer.
@param scale (Point3F).
 */
   virtual void setHUDCurtainScale(( Point3F scale )) {}
   /*! @brief Sets the maximum head rotation angles for sliding the hud curtain layer.
@param maxRot (Point3F) Euler rotation values in radians. Only the x and z values are used.
 */
   virtual void setHUDCurtainMaxRot(( Point3F maxRot )) {}
   /*! @brief Sets the material to use when rendering the hud curtain layer.
@param matName name of material.
 */
   virtual bool setHUDCurtainMat(( String matName )) {}
   /*! @brief Sets the GuiControl to render onto the hud curtain texture.
@param ctrl GuiControl name.
 */
   virtual void setHUDCurtainControl(( GuiControl ctrl )) {}
   /*! @brief Removes the GuiControl that was used to render onto the hud curtain texture.
 */
   virtual void clearHUDCurtainControl(()) {}
   /*! @brief Removes the display device from the curtain manager.
 */
   virtual void clearCurtainHMDDisplay(()) {}
   /*! @brief Reloads the gui and hud curtain material instance.
 */
   virtual void reloadCurtainMaterials(()) {}
   /*! @brief Creates a new AIConnection, and passes arguments to its onConnect script callback.

@returns The newly created AIConnection
@see GameConnection for parameter information
@ingroup AI */
   virtual int aiConnect((...)) {}

   /*! @name Containers
   
   Spatial query functions. <b>Server side only!</b>
   @{ */
   /*! */
   /*! @brief Find objects matching the bitmask type within a box centered at point, with extents x, y, z.

@returns The first object found, or an empty string if nothing was found.  Thereafter, you can get more results using containerFindNext().@see containerFindNext
@ingroup Game */
   virtual string containerFindFirst((int mask, Point3F point, float x, float y, float z)) {}
   /*! @brief Get more results from a previous call to containerFindFirst().

@note You must call containerFindFirst() to begin the search.
@returns The next object found, or an empty string if nothing else was found.
@see containerFindFirst()
@ingroup Game */
   virtual string containerFindNext(()) {}
   /// @}

   /*! @brief Set the default FOV for a camera.
@param defaultFOV The default field of view in degrees
@ingroup CameraSystem */
   virtual void setDefaultFov(( float defaultFOV )) {}
   /*! @brief Set the zoom speed of the camera.
This affects how quickly the camera changes from one field of view to another.
@param speed The camera's zoom speed in ms per 90deg FOV change
@ingroup CameraSystem */
   virtual void setZoomSpeed(( int speed )) {}
   /*! @brief Set the FOV of the camera.
@param FOV The camera's new FOV in degrees
@ingroup CameraSystem */
   virtual void setFov(( float FOV )) {}
   /*! @brief Prevents mouse movement from being processed

In the source, whenever a mouse move event occurs GameTSCtrl::onMouseMove() is called. Whenever snapToggle() is called, it will flag a variable that can prevent this from happening: gSnapLine. This variable is not exposed to script, so you need to call this function to trigger it.

@tsexample
// Snapping is off by default, so we will toggle
// it on first:
PlayGui.snapToggle();

// Mouse movement should be disabled
// Let's turn it back on
PlayGui.snapToggle();
@endtsexample

@ingroup GuiGame */
   virtual void snapToggle(()) {}
   /*! Get the MissionArea object, if any.

@ingroup enviroMisc

 */
   virtual string getMissionAreaServerObject(()) {}
   /*! Saves the decals for the active mission in the entered filename.
@param decalSaveFile Filename to save the decals to.
@tsexample
// Set the filename to save the decals in. If no filename is set, then the
// decals will default to <activeMissionName>.mis.decals
%fileName = "./missionDecals.mis.decals";
// Inform the decal manager to save the decals for the active mission.
decalManagerSave( %fileName );
@endtsexample
@ingroup Decals */
   virtual void decalManagerSave(( String decalSaveFile="" )) {}
   /*! Clears existing decals and replaces them with decals loaded from the specified file.
@param fileName Filename to load the decals from.
@return True if the decal manager was able to load the requested file, false if it could not.
@tsexample
// Set the filename to load the decals from.
%fileName = "./missionDecals.mis.decals";
// Inform the decal manager to load the decals from the entered filename.
decalManagerLoad( %fileName );
@endtsexample
@ingroup Decals */
   virtual bool decalManagerLoad(( string fileName )) {}
   /*! Returns whether the decal manager has unsaved modifications.
@return True if the decal manager has unsaved modifications, false if everything has been saved.
@tsexample
// Ask the decal manager if it has unsaved modifications.
%hasUnsavedModifications = decalManagerDirty();
@endtsexample
@ingroup Decals */
   virtual bool decalManagerDirty(()) {}
   /*! Removes all decals currently loaded in the decal manager.
@tsexample
// Tell the decal manager to remove all existing decals.
decalManagerClear();
@endtsexample
@ingroup Decals */
   virtual void decalManagerClear(()) {}
   /*! Adds a new decal to the decal manager.
@param position World position for the decal.
@param normal Decal normal vector (if the decal was a tire lying flat on a surface, this is the vector pointing in the direction of the axle).
@param rot Angle (in radians) to rotate this decal around its normal vector.
@param scale Scale factor applied to the decal.
@param decalData DecalData datablock to use for the new decal.
@param isImmortal Whether or not this decal is immortal. If immortal, it does not expire automatically and must be removed explicitly.
@return Returns the ID of the new Decal object or -1 on failure.
@tsexample
// Specify the decal position
%position = "1.0 1.0 1.0";

// Specify the up vector
%normal = "0.0 0.0 1.0";

// Add the new decal.
%decalObj = decalManagerAddDecal( %position, %normal, 0.5, 0.35, ScorchBigDecal, false );
@endtsexample
@ingroup Decals */
   virtual int decalManagerAddDecal(( Point3F position, Point3F normal, float rot, float scale, DecalData decalData, bool isImmortal=false )) {}
   /*! Remove specified decal from the scene.
@param decalID ID of the decal to remove.
@return Returns true if successful, false if decal ID not found.
@tsexample
// Specify a decal ID to be removed
%decalID = 1;

// Tell the decal manager to remove the specified decal ID.
decalManagerRemoveDecal( %decalId )
@endtsexample
@ingroup Decals */
   virtual bool decalManagerRemoveDecal(( int decalID )) {}
   /*! @brief Calculates how much an explosion effects a specific object.

Use this to determine how much damage to apply to objects based on their distance from the explosion's center point, and whether the explosion is blocked by other objects.

@param pos Center position of the explosion.
@param id Id of the object of which to check coverage.
@param covMask Mask of object types that may block the explosion.
@return Coverage value from 0 (not affected by the explosion) to 1 (fully affected)

@tsexample
// Get the position of the explosion.
%position = %explosion.getPosition();

// Set a list of TypeMasks (defined in gameFunctioncs.cpp), seperated by the | character.
%TypeMasks = $TypeMasks::StaticObjectType | $TypeMasks::ItemObjectType

// Acquire the damage value from 0.0f - 1.0f.
%coverage = calcExplosionCoverage( %position, %sceneObject, %TypeMasks );

// Apply damage to object
%sceneObject.applyDamage( %coverage * 20 );
@endtsexample
@ingroup FX */
   virtual float calcExplosionCoverage(( Point3F pos=Point3F(0.0f,0.0f,0.0f), int id=NULL, int covMask=NULL )) {}
   /*! Activates the foliage replicator.
@tsexample
// Call the function
StartFoliageReplication();
@endtsexample
@ingroup Foliage */
   virtual void StartFoliageReplication(()) {}
   /*! Activates the shape replicator.
@tsexample
// Call the function
StartClientReplication()
@endtsexample
@ingroup Foliage */
   virtual void StartClientReplication(()) {}
      /*! @brief Called on the client each time a datablock has been received.

This callback is typically used to notify the player of how far along in the datablock download process they are.

@param index The index of the datablock just received.
@param total The total number of datablocks to be received.

@see GameConnection, GameConnection::transmitDataBlocks(), GameConnection::onDataBlocksDone()

@ingroup Networking
 */
      void onDataBlockObjectReceived( int index, int total );

   /*! Dumps all ProcessObjects in ServerProcessList and ClientProcessList to the console. */
   virtual void dumpProcessList() {}
   /*! physicsPluginPresent()
@brief Returns true if a physics plugin exists and is initialized.

@ingroup Physics */
   virtual bool physicsPluginPresent() {}
   /*! physicsInit( [string library] ) */
   virtual bool physicsInit() {}
   /*! physicsDestroy() */
   virtual void physicsDestroy() {}
   /*! physicsInitWorld( String worldName ) */
   virtual bool physicsInitWorld() {}
   /*! physicsDestroyWorld( String worldName ) */
   virtual void physicsDestroyWorld() {}
   /*! physicsStartSimulation( String worldName ) */
   virtual void physicsStartSimulation() {}
   /*! physicsStopSimulation( String worldName ) */
   virtual void physicsStopSimulation() {}
   /*! physicsSimulationEnabled() */
   virtual bool physicsSimulationEnabled() {}
   /*! physicsSetTimeScale( F32 scale ) */
   virtual void physicsSetTimeScale() {}
   /*! physicsGetTimeScale() */
   virtual float physicsGetTimeScale() {}
   /*! physicsStoreState() */
   virtual void physicsStoreState() {}
   /*! physicsRestoreState() */
   virtual void physicsRestoreState() {}
   /*! physicsDebugDraw( bool enable ) */
   virtual void physicsDebugDraw() {}
   /*! @brief Add a string to the bad word filter

The bad word filter is a table containing words which will not be displayed in chat windows. Instead, a designated replacement string will be displayed.  There are already a number of bad words automatically defined.

@param badWord Exact text of the word to restrict.
@return True if word was successfully added, false if the word or a subset of it already exists in the table
@see filterString()

@tsexample
// In this game, "Foobar" is banned
%badWord = "Foobar";

// Returns true, word was successfully added
addBadWord(%badWord);

// Returns false, word has already been added
addBadWord("Foobar");@endtsexample
@ingroup Game */
   virtual bool addBadWord(( string badWord )) {}
   /*! @brief Replaces the characters in a string with designated text

Uses the bad word filter to determine which characters within the string will be replaced.

@param baseString  The original string to filter.
@param replacementChars A string containing letters you wish to swap in the baseString.
@return The new scrambled string 
@see addBadWord()
@see containsBadWords()
@tsexample
// Create the base string, can come from anywhere
%baseString = "Foobar";

// Create a string of random letters
%replacementChars = "knqwrtlzs";

// Filter the string
%newString = filterString(%baseString, %replacementChars);

// Print the new string to console
echo(%newString);@endtsexample
@ingroup Game */
   virtual string filterString(( string baseString=NULL, string replacementChars=NULL )) {}
   /*! @brief Checks to see if text is a bad word

The text is considered to be a bad word if it has been added to the bad word filter.

@param text Text to scan for bad words
@return True if the text has bad word(s), false if it is clean
@see addBadWord()
@see filterString()
@tsexample
// In this game, "Foobar" is banned
%badWord = "Foobar";

// Add a banned word to the bad word filter
addBadWord(%badWord);

// Create the base string, can come from anywhere like user chat
%userText = "Foobar";

// Create a string of random letters
%replacementChars = "knqwrtlzs";

// If the text contains a bad word, filter it before printing
// Otherwise print the original text
if(containsBadWords(%userText))
{
^// Filter the string
^%filteredText = filterString(%userText, %replacementChars);

^// Print filtered text
^echo(%filteredText);
}
else
^echo(%userText);

@endtsexample
@ingroup Game */
   virtual bool containsBadWords(( string text )) {}

   /*! @name InputManagement
   
   Functions that let you deal with input from scripts
   @{ */
   /*! */
   /*! @brief Disables DirectInput.

Also deactivates any connected joysticks.

@ingroup Input */
   virtual void deactivateDirectInput(()) {}
   /*! @brief Activates DirectInput.

Also activates any connected joysticks.@ingroup Input */
   virtual void activateDirectInput(()) {}
   /// @}

   /*! strToPlayerName( string ) */
   virtual string strToPlayerName() {}

   /*! @name Platform
   
   General platform functions.
   @{ */
   /*! */
   /*! @brief Lock or unlock the mouse to the window.

When true, prevents the mouse from leaving the bounds of the game window.

@ingroup Input */
   virtual void lockMouse((bool isLocked)) {}
   /*! @brief Set the network port for the game to use.

@param port The port to use.
@param bind True if bind() should be called on the port.
@returns True if the port was successfully opened.
This will trigger a windows firewall prompt.  If you don't have firewall tunneling tech you can set this to false to avoid the prompt.

@ingroup Networking */
   virtual bool setNetPort((int port, bool bind=true)) {}
   /*! @brief Closes the current network port

@ingroup Networking */
   virtual void closeNetPort(()) {}
   /*! Save the journal to the specified file.

@ingroup Platform */
   virtual void saveJournal((string filename)) {}
   /*! @brief Begin playback of a journal from a specified field.

@param filename Name and path of file journal file
@ingroup Platform */
   virtual void playJournal((string filename)) {}
   /*! Return the current sim time in milliseconds.

@brief Sim time is time since the game started.

@ingroup Platform */
   virtual int getSimTime(()) {}
   /*! @brief Return the current real time in milliseconds.

Real time is platform defined; typically time since the computer booted.

@ingroup Platform */
   virtual int getRealTime(()) {}
   /// @}


   /*! @name CompileInformation
   
   Functions to get version information about the current executable.
   @{ */
   /*! */
   /*! Get the version of the engine build, as a string.

@ingroup Debugging */
   virtual int getVersionNumber() {}
   /*! Get the version of the application build, as a string.

@ingroup Debugging */
   virtual int getAppVersionNumber() {}
   /*! Get the version of the engine build, as a human readable string.

@ingroup Debugging */
   virtual string getVersionString() {}
   /*! Get the version of the aplication, as a human readable string.

@ingroup Debugging */
   virtual string getAppVersionString() {}
   /*! Get the name of the engine product that this is running from, as a string.

@ingroup Debugging */
   virtual string getEngineName() {}
   /*! Get the time of compilation.

@ingroup Debugging */
   virtual string getCompileTimeString() {}
   /*! Get the type of build, "Debug" or "Release".

@ingroup Debugging */
   virtual string getBuildString() {}
   /// @}


   /*! @name Net
   
   Functions for use with the network; tagged strings and remote commands.
   @{ */
   /*! */
   /*! @brief Send a command to the server.

@param func Name of the server command being called
@param ... Various parameters being passed to server command

@tsexample
// Create a standard function.  Needs to be executed on the client, such 
// as within scripts/client/default.bind.cs
function toggleCamera(%val)
{
^// If key was down, call a server command named 'ToggleCamera'
^if (%val)
^^commandToServer('ToggleCamera');
}

// Server command being called from above.  Needs to be executed on the 
// server, such as within scripts/server/commands.cs
function serverCmdToggleCamera(%client)
{
   if (%client.getControlObject() == %client.player)
   {
^  %client.camera.setVelocity("0 0 0");
^  %control = %client.camera;
   }
   else
   {
^  %client.player.setVelocity("0 0 0");
^  %control = %client.player;
  }
   %client.setControlObject(%control);
   clientCmdSyncEditorGui();
}
@endtsexample

@ingroup Networking */
   virtual void commandToServer((string func, ...)) {}
   /*! @brief Send a command from the server to the client

@param client The numeric ID of a client GameConnection
@param func Name of the client function being called
@param ... Various parameters being passed to client command

@tsexample
// Set up the client command.  Needs to be executed on the client, such as
// within scripts/client/client.cs
// Update the Ammo Counter with current ammo, if not any then hide the counter.
function clientCmdSetAmmoAmountHud(%amount)
{
   if (!%amount)
^  AmmoAmount.setVisible(false);
   else
   {
^  AmmoAmount.setVisible(true);
^  AmmoAmount.setText("Ammo: "@%amount);
   }
}

// Call it from a server function.  Needs to be executed on the server, 
//such as within scripts/server/game.cs
function GameConnection::setAmmoAmountHud(%client, %amount)
{
   commandToClient(%client, 'SetAmmoAmountHud', %amount);
}
@endtsexample

@ingroup Networking
 */
   virtual void commandToClient((NetConnection client, string func, ...)) {}
   /*! @brief Remove a tagged string from the Net String Table

@param tag The tag associated with the string

@see \ref syntaxDataTypes under Tagged %Strings
@see addTaggedString()
@see getTaggedString()
@ingroup Networking
 */
   virtual void removeTaggedString(( int tag=-1 )) {}
   /*! @brief Use the addTaggedString function to tag a new string and add it to the NetStringTable

@param str The string to be tagged and placed in the NetStringTable. Tagging ignores case, so tagging the same string (excluding case differences) will be ignored as a duplicated tag.

@return Returns a string( containing a numeric value) equivalent to the string ID for the newly tagged string@see \ref syntaxDataTypes under Tagged %Strings
@see removeTaggedString()
@see getTaggedString()
@ingroup Networking
 */
   virtual string addTaggedString(( string str="" )) {}
   /*! @brief Use the getTaggedString function to convert a tag to a string.

This is not the same as detag() which can only be used within the context of a function that receives a tag. This function can be used any time and anywhere to convert a tag to a string.

@param tag A numeric tag ID.
@returns The string as found in the Net String table.
@see \ref syntaxDataTypes under Tagged %Strings
@see addTaggedString()
@see removeTaggedString()
@ingroup Networking
 */
   virtual string getTaggedString(( string tag="" )) {}
   /*! @brief Build a string using the specified tagged string format.

This function takes an already tagged string (passed in as a tagged string ID) and one or more additional strings.  If the tagged string contains argument tags that range from %%1 through %%9, then each additional string will be substituted into the tagged string.  The final (non-tagged) combined string will be returned.  The maximum length of the tagged string plus any inserted additional strings is 511 characters.

@param format A tagged string ID that contains zero or more argument tags, in the form of %%1 through %%9.
@param ... A variable number of arguments that are insterted into the tagged string based on the argument tags within the format string.
@returns An ordinary string that is a combination of the original tagged string with any additional strings passed in inserted in place of each argument tag.
@tsexample
// Create a tagged string with argument tags
%taggedStringID = addTaggedString("Welcome %1 to the game!");

// Some point later, combine the tagged string with some other string
%string = buildTaggedString(%taggedStringID, %playerName);
echo(%string);
@endtsexample

@see \ref syntaxDataTypes under Tagged %Strings
@see addTaggedString()
@see getTaggedString()
@ingroup Networking
 */
   virtual string buildTaggedString((string format, ...)) {}
   /// @}

   /*! testBridge(arg1, arg2, arg3) */
   virtual string testJavaScriptBridge() {}
   /*! testFunction(arg1, arg2) */
   virtual string TestFunction2Args() {}

   /*! @name Clipboard
   
   Miscellaneous functions to control the clipboard and clear the console.
   @{ */
   /*! */
   /*! @brief Clears the console output.

@ingroup Console */
   virtual void cls(()) {}
   /*! @brief Get text from the clipboard.

@internal */
   virtual string getClipboard(()) {}
   /*! @brief Set the system clipboard.

@internal */
   virtual bool setClipboard((string text)) {}
   /// @}

   /*! @brief Logs a message to the console.

@param message The message text.
@note By default, messages will appear white in the console.
@ingroup Logging */
   virtual void log(( string message )) {}
   /*! @brief Logs an error message to the console.

@param message The message text.
@note By default, errors will appear red in the console.
@ingroup Logging */
   virtual void logError(( string message )) {}
   /*! @brief Logs a warning message to the console.

@param message The message text.

@note By default, warnings will appear turquoise in the console.
@ingroup Logging */
   virtual void logWarning(( string message )) {}

   /*! @name ConsoleDoc
   
   Console self-documentation functions. These output psuedo C++ suitable for feeeding through Doxygen or another auto documentation tool.
   @{ */
   /*! */
   /*! @brief Dumps all declared console classes to the console.

@param dumpScript Optional parameter specifying whether or not classes defined in script should be dumped.
@param dumpEngine Optional parameter specifying whether or not classes defined in the engine should be dumped.
@ingroup Logging */
   virtual void dumpConsoleClasses(( bool dumpScript=true, bool dumpEngine=true )) {}
   /*! @brief Dumps all declared console functions to the console.
@param dumpScript Optional parameter specifying whether or not functions defined in script should be dumped.
@param dumpEngine Optional parameter specitying whether or not functions defined in the engine should be dumped.
@ingroup Logging */
   virtual void dumpConsoleFunctions(( bool dumpScript=true, bool dumpEngine=true )) {}
   /// @}

   /*! Add 2 large numbers.
@param first large number.
@param second large number.

 */
   virtual string mAddBigNumbers(( string first, string second )) {}
   /*! Add 2 large numbers.
@param first large number.
@param second large number.

 */
   virtual string mSubBigNumbers(( string first, string second )) {}
   /*! Add 2 large numbers.
@param first large number.
@param second large number.

 */
   virtual string mMulBigNumbers(( string first, string second )) {}
   /*! Add 2 large numbers.
@param first large number.
@param second large number.

 */
   virtual string mDivBigNumbers(( string first, string second )) {}
   /*! Add 2 large numbers.
@param first large number.
@param second large number.

 */
   virtual string mScaleBigNumbers(( string first, string second )) {}
   /*! Return the integer character code value corresponding to the first character in the given string.
@param chr a (one-character) string.
@return the UTF32 code value for the first character in the given string.
@ingroup Strings */
   virtual int strasc(( string chr )) {}
   /*! Format the given value as a string using printf-style formatting.
@param format A printf-style format string.
@param value The value argument matching the given format string.

@tsexample
// Convert the given integer value to a string in a hex notation.
%hex = strformat( "%x", %value );
@endtsexample
@ingroup Strings
@see http://en.wikipedia.org/wiki/Printf */
   virtual string strformat(( string format, string value )) {}
   /*! Compares two strings using case-<b>sensitive</b> comparison.
@param str1 The first string.
@param str2 The second string.
@return 0 if both strings are equal, a value <0 if the first character different in str1 has a smaller character code value than the character at the same position in str2, and a value >1 otherwise.

@tsexample
if( strcmp( %var, "foobar" ) == 0 )
   echo( "%var is equal to 'foobar'" );
@endtsexample
@see stricmp
@see strnatcmp
@ingroup Strings */
   virtual int strcmp(( string str1, string str2 )) {}
   /*! Compares two strings using case-<b>insensitive</b> comparison.
@param str1 The first string.
@param str2 The second string.
@return 0 if both strings are equal, a value <0 if the first character different in str1 has a smaller character code value than the character at the same position in str2, and a value >0 otherwise.

@tsexample
if( stricmp( "FOObar", "foobar" ) == 0 )
   echo( "this is always true" );
@endtsexample
@see strcmp
@see strinatcmp
@ingroup Strings */
   virtual int stricmp(( string str1, string str2 )) {}
   /*! Compares two strings using "natural order" case-<b>sensitive</b> comparison.
Natural order means that rather than solely comparing single character code values, strings are ordered in a natural way.  For example, the string "hello10" is considered greater than the string "hello2" even though the first numeric character in "hello10" actually has a smaller character value than the corresponding character in "hello2".  However, since 10 is greater than 2, strnatcmp will put "hello10" after "hello2".
@param str1 The first string.
@param str2 The second string.

@return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value <0 if @a str1 comes before @a str2 in a natural order.

@tsexample
// Bubble sort 10 elements of %array using natural order
do
{
   %swapped = false;
   for( %i = 0; %i < 10 - 1; %i ++ )
      if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
      {
         %temp = %array[ %i ];
         %array[ %i ] = %array[ %i + 1 ];
         %array[ %i + 1 ] = %temp;
         %swapped = true;
      }
}
while( %swapped );
@endtsexample
@see strcmp
@see strinatcmp
@ingroup Strings */
   virtual int strnatcmp(( string str1, string str2 )) {}
   /*! Compares two strings using "natural order" case-<b>insensitive</b> comparison.
Natural order means that rather than solely comparing single character code values, strings are ordered in a natural way.  For example, the string "hello10" is considered greater than the string "hello2" even though the first numeric character in "hello10" actually has a smaller character value than the corresponding character in "hello2".  However, since 10 is greater than 2, strnatcmp will put "hello10" after "hello2".
@param str1 The first string.
@param str2 The second string.
@return 0 if the strings are equal, a value >0 if @a str1 comes after @a str2 in a natural order, and a value <0 if @a str1 comes before @a str2 in a natural order.

@tsexample

// Bubble sort 10 elements of %array using natural order
do
{
   %swapped = false;
   for( %i = 0; %i < 10 - 1; %i ++ )
      if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) > 0 )
      {
         %temp = %array[ %i ];
         %array[ %i ] = %array[ %i + 1 ];
         %array[ %i + 1 ] = %temp;
         %swapped = true;
      }
}
while( %swapped );
@endtsexample
@see stricmp
@see strnatcmp
@ingroup Strings */
   virtual int strinatcmp(( string str1, string str2 )) {}
   /*! Get the length of the given string in bytes.
@note This does <b>not</b> return a true character count for strings with multi-byte characters!
@param str A string.
@return The length of the given string in bytes.
@ingroup Strings */
   virtual int strlen(( string str )) {}
   /*! Find the start of @a substring in the given @a string searching from left to right.
@param string The string to search.
@param substring The string to search for.
@return The index into @a string at which the first occurrence of @a substring was found or -1 if @a substring could not be found.

@tsexample
strstr( "abcd", "c" ) // Returns 2.
@endtsexample
@ingroup Strings */
   virtual int strstr(( string string, string substring )) {}
   /*! Find the start of @a needle in @a haystack searching from left to right beginning at the given offset.
@param haystack The string to search.
@param needle The string to search for.
@return The index at which the first occurrence of @a needle was found in @a haystack or -1 if no match was found.

@tsexample
strpos( "b ab", "b", 1 ) // Returns 3.
@endtsexample
@ingroup Strings */
   virtual int strpos(( string haystack, string needle, int offset=0 )) {}
   /*! Remove leading whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any leading (i.e. leftmost) whitespace removed.

@tsexample
ltrim( "   string  " ); // Returns "string  ".
@endtsexample
@see rtrim
@see trim
@ingroup Strings */
   virtual string ltrim(( string str )) {}
   /*! Remove trailing whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any trailing (i.e. rightmost) whitespace removed.

@tsexample
rtrim( "   string  " ); // Returns "   string".
@endtsexample
@see ltrim
@see trim
@ingroup Strings */
   virtual string rtrim(( string str )) {}
   /*! Remove leading and trailing whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any leading (i.e. leftmost) and trailing (i.e. rightmost) whitespace removed.

@tsexample
trim( "   string  " ); // Returns "string".
@endtsexample
@ingroup Strings */
   virtual string trim(( string str )) {}
   /*! Remove all occurrences of characters contained in @a chars from @a str.
@param str The string to filter characters out from.
@param chars A string of characters to filter out from @a str.
@return A version of @a str with all occurrences of characters contained in @a chars filtered out.

@tsexample
stripChars( "teststring", "se" ); // Returns "tttring".@endtsexample
@ingroup Strings */
   virtual string stripChars(( string str, string chars )) {}
   /*! Return an all lower-case version of the given string.
@param str A string.
@return A version of @a str with all characters converted to lower-case.

@tsexample
strlwr( "TesT1" ) // Returns "test1"
@endtsexample
@see strupr
@ingroup Strings */
   virtual string strlwr(( string str )) {}
   /*! Return an all upper-case version of the given string.
@param str A string.
@return A version of @a str with all characters converted to upper-case.

@tsexample
strupr( "TesT1" ) // Returns "TEST1"
@endtsexample
@see strlwr
@ingroup Strings */
   virtual string strupr(( string str )) {}
   /*! Find the first occurrence of the given character in @a str.
@param str The string to search.
@param chr The character to search for.  Only the first character from the string is taken.
@return The remainder of the input string starting with the given character or the empty string if the character could not be found.

@see strrchr
@ingroup Strings */
   virtual string strchr(( string str, string chr )) {}
   /*! Find the last occurrence of the given character in @a str.@param str The string to search.
@param chr The character to search for.  Only the first character from the string is taken.
@return The remainder of the input string starting with the given character or the empty string if the character could not be found.

@see strchr
@ingroup Strings */
   virtual string strrchr(( string str, string chr )) {}
   /*! Replace all occurrences of @a from in @a source with @a to.
@param source The string in which to replace the occurrences of @a from.
@param from The string to replace in @a source.
@param to The string with which to replace occurrences of @from.
@return A string with all occurrences of @a from in @a source replaced by @a to.

@tsexample
strreplace( "aabbccbb", "bb", "ee" ) // Returns "aaeeccee".
@endtsexample
@ingroup Strings */
   virtual string strreplace(( string source, string from, string to )) {}
   /*! Return a string that repeats @a str @a numTimes number of times delimiting each occurrence with @a delimiter.
@param str The string to repeat multiple times.
@param numTimes The number of times to repeat @a str in the result string.
@param delimiter The string to put between each repetition of @a str.
@return A string containing @a str repeated @a numTimes times.

@tsexample
strrepeat( "a", 5, "b" ) // Returns "ababababa".
@endtsexample
@ingroup Strings */
   virtual string strrepeat(( string str, int numTimes, string delimiter="" )) {}
   /*! @brief Return a substring of @a str starting at @a start and continuing either through to the end of @a str (if @a numChars is -1) or for @a numChars characters (except if this would exceed the actual source string length).
@param str The string from which to extract a substring.
@param start The offset at which to start copying out characters.
@param numChars Optional argument to specify the number of characters to copy.  If this is -1, all characters up the end of the input string are copied.
@return A string that contains the given portion of the input string.

@tsexample
getSubStr( "foobar", 1, 2 ) // Returns "oo".
@endtsexample

@ingroup Strings */
   virtual string getSubStr(( string str, int start, int numChars=-1 )) {}
   /*! Match a pattern against a string.
@param pattern The wildcard pattern to match against.  The pattern can include characters, '*' to match any number of characters and '?' to match a single character.
@param str The string which should be matched against @a pattern.
@param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against this string.  If false, differences in casing are ignored.
@return True if @a str matches the given @a pattern.

@tsexample
strIsMatchExpr( "f?o*R", "foobar" ) // Returns true.
@endtsexample
@see strIsMatchMultipleExpr
@ingroup Strings */
   virtual bool strIsMatchExpr(( string pattern, string str, bool caseSensitive=false )) {}
   /*! Match a multiple patterns against a single string.
@param patterns A tab-separated list of patterns.  Each pattern can include charaters, '*' to match any number of characters and '?' to match a single character.  Each of the patterns is tried in turn.
@param str The string which should be matched against @a patterns.
@param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against this string.  If false, differences in casing are ignored.
@return True if @a str matches any of the given @a patterns.

@tsexample
strIsMatchMultipleExpr( "*.cs *.gui *.mis", "mymission.mis" ) // Returns true.
@endtsexample
@see strIsMatchExpr
@ingroup Strings */
   virtual bool strIsMatchMultipleExpr(( string patterns, string str, bool caseSensitive=false )) {}
   /*! Get the numeric suffix of the given input string.
@param str The string from which to read out the numeric suffix.
@return The numeric value of the number suffix of @a str or -1 if @a str has no such suffix.

@tsexample
getTrailingNumber( "test123" ) // Returns '123'.
@endtsexample

@see stripTrailingNumber
@ingroup Strings */
   virtual int getTrailingNumber(( string str )) {}
   /*! Strip a numeric suffix from the given string.
@param str The string from which to strip its numeric suffix.
@return The string @a str without its number suffix or the original string @a str if it has no such suffix.

@tsexample
stripTrailingNumber( "test123" ) // Returns "test".
@endtsexample

@see getTrailingNumber
@ingroup Strings */
   virtual string stripTrailingNumber(( string str )) {}
   /*! Test whether the character at the given position is a whitespace character.
Characters such as tab, space, or newline are considered whitespace.
@param str The string to test.
@param index The index of a character in @a str.
@return True if the character at the given index in @a str is a whitespace character; false otherwise.

@see isalnum
@ingroup Strings */
   virtual bool isspace(( string str, int index )) {}
   /*! Test whether the character at the given position is an alpha-numeric character.
Alpha-numeric characters are characters that are either alphabetic (a-z, A-Z) or numbers (0-9).
@param str The string to test.
@param index The index of a character in @a str.
@return True if the character at the given index in @a str is an alpha-numeric character; false otherwise.

@see isspace
@ingroup Strings */
   virtual bool isalnum(( string str, int index )) {}
   /*! Test whether the given string begins with the given prefix.
@param str The string to test.
@param prefix The potential prefix of @a str.
@param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will not be taken into account.
@return True if the first characters in @a str match the complete contents of @a prefix; false otherwise.

@tsexample
startsWith( "TEST123", "test" ) // Returns true.
@endtsexample
@see endsWith
@ingroup Strings */
   virtual bool startsWith(( string str, string prefix, bool caseSensitive=false )) {}
   /*! @brief Test whether the given string ends with the given suffix.

@param str The string to test.
@param suffix The potential suffix of @a str.
@param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will not be taken into account.
@return True if the last characters in @a str match the complete contents of @a suffix; false otherwise.

@tsexample
startsWith( "TEST123", "123" ) // Returns true.
@endtsexample

@see startsWith
@ingroup Strings */
   virtual bool endsWith(( string str, string suffix, bool caseSensitive=false )) {}
   /*! Find the first occurrence of the given character in the given string.
@param str The string to search.
@param chr The character to look for.  Only the first character of this string will be searched for.
@param start The index into @a str at which to start searching for the given character.
@return The index of the first occurrence of @a chr in @a str or -1 if @a str does not contain the given character.

@tsexample
strchrpos( "test", "s" ) // Returns 2.
@endtsexample
@ingroup Strings */
   virtual int strchrpos(( string str, string chr, int start=0 )) {}
   /*! Find the last occurrence of the given character in the given string.
@param str The string to search.
@param chr The character to look for.  Only the first character of this string will be searched for.
@param start The index into @a str at which to start searching for the given character.
@return The index of the last occurrence of @a chr in @a str or -1 if @a str does not contain the given character.

@tsexample
strrchrpos( "test", "t" ) // Returns 3.
@endtsexample
@ingroup Strings */
   virtual int strrchrpos(( string str, string chr, int start=0 )) {}
   /*! Extract the word at the given @a index in the whitespace-separated list in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to extract.
@return The word at the given index or "" if the index is out of range.

@tsexample
getWord( "a b c", 1 ) // Returns "b"
@endtsexample

@see getWords
@see getWordCount
@see getField
@see getRecord
@ingroup FieldManip */
   virtual string getWord(( string text, int index )) {}
   /*! Extract a range of words from the given @a startIndex onwards thru @a endIndex.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param startIndex The zero-based index of the first word to extract from @a text.
@param endIndex The zero-based index of the last word to extract from @a text.  If this is -1, all words beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of words from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getWords( "a b c d", 1, 2, ) // Returns "b c"
@endtsexample

@see getWord
@see getWordCount
@see getFields
@see getRecords
@ingroup FieldManip */
   virtual string getWords(( string text, int startIndex, int endIndex=-1 )) {}
   /*! Replace the word in @a text at the given @a index with @a replacement.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to replace.
@param replacement The string with which to replace the word.
@return A new string with the word at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setWord( "a b c d", 2, "f" ) // Returns "a b f d"
@endtsexample

@see getWord
@see setField
@see setRecord
@ingroup FieldManip */
   virtual string setWord(( string text, int index, string replacement )) {}
   /*! Remove the word in @a text at the given @a index.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word in @a text.
@return A new string with the word at the given index removed or the original string if @a index is out of range.

@tsexample
removeWord( "a b c d", 2 ) // Returns "a b d"
@endtsexample

@see removeField
@see removeRecord
@ingroup FieldManip */
   virtual string removeWord(( string text, int index )) {}
   /*! Return the number of whitespace-separated words in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@return The number of whitespace-separated words in @a text.

@tsexample
getWordCount( "a b c d e" ) // Returns 5
@endtsexample

@see getFieldCount
@see getRecordCount
@ingroup FieldManip */
   virtual int getWordCount(( string text )) {}
   /*! Extract the field at the given @a index in the newline and/or tab separated list in @a text.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field to extract.
@return The field at the given index or "" if the index is out of range.

@tsexample
getField( "a b" TAB "c d" TAB "e f", 1 ) // Returns "c d"
@endtsexample

@see getFields
@see getFieldCount
@see getWord
@see getRecord
@ingroup FieldManip */
   virtual string getField(( string text, int index )) {}
   /*! Extract a range of fields from the given @a startIndex onwards thru @a endIndex.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param startIndex The zero-based index of the first field to extract from @a text.
@param endIndex The zero-based index of the last field to extract from @a text.  If this is -1, all fields beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of fields from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getFields( "a b" TAB "c d" TAB "e f", 1 ) // Returns "c d" TAB "e f"
@endtsexample

@see getField
@see getFieldCount
@see getWords
@see getRecords
@ingroup FieldManip */
   virtual string getFields(( string text, int startIndex, int endIndex=-1 )) {}
   /*! Replace the field in @a text at the given @a index with @a replacement.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field to replace.
@param replacement The string with which to replace the field.
@return A new string with the field at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setField( "a b" TAB "c d" TAB "e f", 1, "g h" ) // Returns "a b" TAB "g h" TAB "e f"
@endtsexample

@see getField
@see setWord
@see setRecord
@ingroup FieldManip */
   virtual string setField(( string text, int index, string replacement )) {}
   /*! Remove the field in @a text at the given @a index.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field in @a text.
@return A new string with the field at the given index removed or the original string if @a index is out of range.

@tsexample
removeField( "a b" TAB "c d" TAB "e f", 1 ) // Returns "a b" TAB "e f"
@endtsexample

@see removeWord
@see removeRecord
@ingroup FieldManip */
   virtual string removeField(( string text, int index )) {}
   /*! Return the number of newline and/or tab separated fields in @a text.
@param text A list of fields separated by newlines and/or tabs.
@return The number of newline and/or tab sepearated elements in @a text.

@tsexample
getFieldCount( "a b" TAB "c d" TAB "e f" ) // Returns 3
@endtsexample

@see getWordCount
@see getRecordCount
@ingroup FieldManip */
   virtual int getFieldCount(( string text )) {}
   /*! Extract the record at the given @a index in the newline-separated list in @a text.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record to extract.
@return The record at the given index or "" if @a index is out of range.

@tsexample
getRecord( "a b" NL "c d" NL "e f", 1 ) // Returns "c d"
@endtsexample

@see getRecords
@see getRecordCount
@see getWord
@see getField
@ingroup FieldManip */
   virtual string getRecord(( string text, int index )) {}
   /*! Extract a range of records from the given @a startIndex onwards thru @a endIndex.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param startIndex The zero-based index of the first record to extract from @a text.
@param endIndex The zero-based index of the last record to extract from @a text.  If this is -1, all records beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of records from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getRecords( "a b" NL "c d" NL "e f", 1 ) // Returns "c d" NL "e f"
@endtsexample

@see getRecord
@see getRecordCount
@see getWords
@see getFields
@ingroup FieldManip */
   virtual string getRecords(( string text, int startIndex, int endIndex=-1 )) {}
   /*! Replace the record in @a text at the given @a index with @a replacement.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record to replace.
@param replacement The string with which to replace the record.
@return A new string with the record at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setRecord( "a b" NL "c d" NL "e f", 1, "g h" ) // Returns "a b" NL "g h" NL "e f"
@endtsexample

@see getRecord
@see setWord
@see setField
@ingroup FieldManip */
   virtual string setRecord(( string text, int index, string replacement )) {}
   /*! Remove the record in @a text at the given @a index.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record in @a text.
@return A new string with the record at the given @a index removed or the original string if @a index is out of range.

@tsexample
removeRecord( "a b" NL "c d" NL "e f", 1 ) // Returns "a b" NL "e f"
@endtsexample

@see removeWord
@see removeField
@ingroup FieldManip */
   virtual string removeRecord(( string text, int index )) {}
   /*! Return the number of newline-separated records in @a text.
@param text A list of records separated by newlines.
@return The number of newline-sepearated elements in @a text.

@tsexample
getRecordCount( "a b" NL "c d" NL "e f" ) // Returns 3
@endtsexample

@see getWordCount
@see getFieldCount
@ingroup FieldManip */
   virtual int getRecordCount(( string text )) {}
   /*! Return the first word in @a text.
@param text A list of words separated by newlines, spaces, and/or tabs.
@return The word at index 0 in @a text or "" if @a text is empty.

@note This is equal to 
@tsexample_nopar
getWord( text, 0 )
@endtsexample

@see getWord
@ingroup FieldManip */
   virtual string firstWord(( string text )) {}
   /*! Return all but the first word in @a text.
@param text A list of words separated by newlines, spaces, and/or tabs.
@return @a text with the first word removed.

@note This is equal to 
@tsexample_nopar
getWords( text, 1 )
@endtsexample

@see getWords
@ingroup FieldManip */
   virtual string restWords(( string text )) {}
   /*! Tokenize a string using a set of delimiting characters.
This function first skips all leading charaters in @a str that are contained in @a delimiters. From that position, it then scans for the next character in @a str that is contained in @a delimiters and stores all characters from the starting position up to the first delimiter in a variable in the current scope called @a token.  Finally, it skips all characters in @a delimiters after the token and then returns the remaining string contents in @a str.

To scan out all tokens in a string, call this function repeatedly by passing the result it returns each time as the new @a str until the function returns "".

@param str A string.
@param token The name of the variable in which to store the current token.  This variable is set in the scope in which nextToken is called.
@param delimiters A string of characters.  Each character is considered a delimiter.
@return The remainder of @a str after the token has been parsed out or "" if no more tokens were found in @a str.

@tsexample
// Prints:
// a
// b
// c
%str = "a   b c";
while ( %str !$= "" )
{
   // First time, stores "a" in the variable %token and sets %str to "b c".
   %str = nextToken( %str, "token", " " );
   echo( %token );
}
@endtsexample

@ingroup Strings */
   virtual string nextToken(( string str, string token, string delimiters )) {}
   /*! @brief Returns the string from a tag string.

Should only be used within the context of a function that receives a tagged string, and is not meant to be used outside of this context.  Use getTaggedString() to convert a tagged string ID back into a regular string at any time.

@tsexample
// From scripts/client/message.cs
function clientCmdChatMessage(%sender, %voice, %pitch, %msgString, %a1, %a2, %a3, %a4, %a5, %a6, %a7, %a8, %a9, %a10)
{
   onChatMessage(detag(%msgString), %voice, %pitch);
}
@endtsexample

@see \ref syntaxDataTypes under Tagged %Strings
@see getTag()
@see getTaggedString()
@ingroup Networking */
   virtual string detag(( string str )) {}
   /*! @brief Extracts the tag from a tagged string

Should only be used within the context of a function that receives a tagged string, and is not meant to be used outside of this context.

@param textTagString The tagged string to extract.
@returns The tag ID of the string.
@see \ref syntaxDataTypes under Tagged %Strings
@see detag()
@ingroup Networking */
   virtual string getTag((string textTagString)) {}
   /*! @brief Logs a message to the console.

Concatenates all given arguments to a single string and prints the string to the console. A newline is added automatically after the text.

@param message Any number of string arguments.

@ingroup Logging */
   virtual void echo(( string message... )) {}
   /*! @brief Logs a warning message to the console.

Concatenates all given arguments to a single string and prints the string to the console as a warning message (in the in-game console, these will show up using a turquoise font by default). A newline is added automatically after the text.

@param message Any number of string arguments.

@ingroup Logging */
   virtual void warn(( string message... )) {}
   /*! @brief Logs an error message to the console.

Concatenates all given arguments to a single string and prints the string to the console as an error message (in the in-game console, these will show up using a red font by default). A newline is added automatically after the text.

@param message Any number of string arguments.

@ingroup Logging */
   virtual void error(( string message... )) {}
   /*! @brief Logs the value of the given variable to the console.

Prints a string of the form "<variableName> = <variable value>" to the console.

@param variableName Name of the local or global variable to print.

@tsexample
%var = 1;
debugv( "%var" ); // Prints "%var = 1"
@endtsexample

@ingroup Debugging */
   virtual void debugv(( string variableName )) {}
   /*! @brief Replace all characters in @a text that need to be escaped for the string to be a valid string literal with their respective escape sequences.

All characters in @a text that cannot appear in a string literal will be replaced by an escape sequence (\\n, \\t, etc).

The primary use of this function is for converting strings suitable for being passed as string literals to the TorqueScript compiler.

@param text A string
@return A duplicate of the text parameter with all unescaped characters that cannot appear in string literals replaced by their respective escape sequences.

@tsxample
expandEscape( "str" NL "ing" ) // Returns "str\ning".
@endtsxample

@see collapseEscape
@ingroup Strings */
   virtual string expandEscape(( string text )) {}
   /*! Replace all escape sequences in @a text with their respective character codes.

This function replaces all escape sequences (\\n, \\t, etc) in the given string with the respective characters they represent.

The primary use of this function is for converting strings from their literal form into their compiled/translated form, as is normally done by the TorqueScript compiler.

@param text A string.
@return A duplicate of @a text with all escape sequences replaced by their respective character codes.

@tsexample
// Print:
//
//    str
//    ing
//
// to the console.  Note how the backslash in the string must be escaped here
// in order to prevent the TorqueScript compiler from collapsing the escape
// sequence in the resulting string.
echo( collapseEscape( "str\ning" ) );
@endtsexample

@see expandEscape

@ingroup Strings */
   virtual string collapseEscape(( string text )) {}
   /*! @brief Determines how log files are written.

Sets the operational mode of the console logging system.

@param mode Parameter specifying the logging mode.  This can be:
- 1: Open and close the console log file for each seperate string of output.  This will ensure that all parts get written out to disk and that no parts remain in intermediate buffers even if the process crashes.
- 2: Keep the log file open and write to it continuously.  This will make the system operate faster but if the process crashes, parts of the output may not have been written to disk yet and will be missing from the log.

Additionally, when changing the log mode and thus opening a new log file, either of the two mode values may be combined by binary OR with 0x4 to cause the logging system to flush all console log messages that had already been issued to the console system into the newly created log file.

@note Xbox 360 does not support logging to a file. Use Platform::OutputDebugStr in C++ instead.@ingroup Logging */
   virtual void setLogMode(( int mode )) {}
   /*! Shut down the engine and exit its process.
This function cleanly uninitializes the engine and then exits back to the system with a process exit status indicating a clean exit.

@see quitWithErrorMessage

@ingroup Platform */
   virtual void quit(()) {}
   /*! Shut down the engine and exit its process.
This function cleanly uninitializes the engine and then exits back to the system with a process exit status indicating a clean exit.

@see quitWithErrorMessage

@ingroup Platform */
   virtual void TAPLinkQuit(()) {}
   /*! Display an error message box showing the given @a message and then shut down the engine and exit its process.
This function cleanly uninitialized the engine and then exits back to the system with a process exit status indicating an error.

@param message The message to log to the console and show in an error message box.

@see quit

@ingroup Platform */
   virtual void quitWithErrorMessage(( string message )) {}
   /*! Open the given URL or file in the user's web browser.

@param address The address to open.  If this is not prefixed by a protocol specifier ("...://"), then the function checks whether the address refers to a file or directory and if so, prepends "file://" to @a adress; if the file check fails, "http://" is prepended to @a address.

@tsexample
gotoWebPage( "http://www.garagegames.com" );
@endtsexample

@ingroup Platform */
   virtual void gotoWebPage(( string address )) {}
   /*! Display a startup splash window suitable for showing while the engine still starts up.

@note This is currently only implemented on Windows.

@return True if the splash window could be successfully initialized.

@ingroup Platform */
   virtual bool displaySplashWindow(( string path="art/gui/splash.bmp" )) {}
   /*! Test whether Torque is running in web-deployment mode.
In this mode, Torque will usually run within a browser and certain restrictions apply (e.g. Torque will not be able to enter fullscreen exclusive mode).
@return True if Torque is running in web-deployment mode.
@ingroup Platform */
   virtual bool getWebDeployment(()) {}
   /*! Count the number of bits that are set in the given 32 bit integer.
@param v An integer value.

@return The number of bits that are set in @a v.

@ingroup Utilities */
   virtual int countBits(( int v )) {}
   /*! Generate a new universally unique identifier (UUID).

@return A newly generated UUID.

@ingroup Utilities */
   virtual string generateUUID(()) {}
   /*! Apply the given arguments to the specified global function and return the result of the call.

@param functionName The name of the function to call.  This function must be in the global namespace, i.e. you cannot call a function in a namespace through #call.  Use eval() for that.
@return The result of the function call.

@tsexample
function myFunction( %arg )
{
  return ( %arg SPC "World!" );
}

echo( call( "myFunction", "Hello" ) ); // Prints "Hello World!" to the console.
@endtsexample

@ingroup Scripting */
   virtual string call(( string functionName, string args... )) {}
   /*! Get the absolute path to the file in which the compiled code for the given script file will be stored.
@param scriptFileName %Path to the .cs script file.
@return The absolute path to the .dso file for the given script file.

@note The compiler will store newly compiled DSOs in the prefs path but pre-existing DSOs will be loaded from the current paths.

@see compile
@see getPrefsPath
@ingroup Scripting */
   virtual string getDSOPath(( string scriptFileName )) {}
   /*! Compile a file to bytecode.

This function will read the TorqueScript code in the specified file, compile it to internal bytecode, and, if DSO generation is enabled or @a overrideNoDDSO is true, will store the compiled code in a .dso file in the current DSO path mirrorring the path of @a fileName.

@param fileName Path to the file to compile to bytecode.
@param overrideNoDSO If true, force generation of DSOs even if the engine is compiled to not generate write compiled code to DSO files.

@return True if the file was successfully compiled, false if not.

@note The definitions contained in the given file will not be made available and no code will actually be executed.  Use exec() for that.

@see getDSOPath
@see exec
@ingroup Scripting */
   virtual bool compile(( string fileName, bool overrideNoDSO=false )) {}
   /*! Execute the given script file.
@param fileName Path to the file to execute
@param noCalls Deprecated
@param journalScript Deprecated
@return True if the script was successfully executed, false if not.

@tsexample
// Execute the init.cs script file found in the same directory as the current script file.
exec( "./init.cs" );
@endtsexample

@see compile
@see eval
@ingroup Scripting */
   virtual bool exec(( string fileName, bool noCalls=false, bool journalScript=false )) {}
   /*! eval(consoleString) */
   virtual string eval() {}
   /*! @brief Returns the value of the named variable or an empty string if not found.

@varName Name of the variable to search for
@return Value contained by varName, "" if the variable does not exist
@ingroup Scripting */
   virtual string getVariable((string varName)) {}
   /*! @brief Sets the value of the named variable.

@param varName Name of the variable to locate
@param value New value of the variable
@return True if variable was successfully found and set
@ingroup Scripting */
   virtual void setVariable((string varName, string value)) {}
   /*! @brief Determines if a function exists or not

@param funcName String containing name of the function
@return True if the function exists, false if not
@ingroup Scripting */
   virtual bool isFunction((string funcName)) {}
   /*! @brief Provides the name of the package the function belongs to

@param funcName String containing name of the function
@return The name of the function's package
@ingroup Packages */
   virtual string getFunctionPackage((string funcName)) {}
   /*! @brief Determines if a class/namespace method exists

@param namespace Class or namespace, such as Player
@param method Name of the function to search for
@return True if the method exists, false if not
@ingroup Scripting
 */
   virtual bool isMethod((string namespace, string method)) {}
   /*! @brief Provides the name of the package the method belongs to

@param namespace Class or namespace, such as Player
@param method Name of the funciton to search for
@return The name of the method's package
@ingroup Packages */
   virtual string getMethodPackage((string namespace, string method)) {}
   /*! @brief Determines if a variable exists and contains a value
@param varName Name of the variable to search for
@return True if the variable was defined in script, false if not
@tsexample
isDefined( "$myVar" );
@endtsexample

@ingroup Scripting */
   virtual bool isDefined((string varName)) {}
   /*! Returns true if the calling script is a tools script.
@hide */
   virtual bool isCurrentScriptToolScript(()) {}
   /*! @brief Attempts to extract a mod directory from path. Returns empty string on failure.

@param File path of mod folder
@note This is no longer relevant in Torque 3D (which does not use mod folders), should be deprecated
@internal */
   virtual string getModNameFromPath((string path)) {}
   /*! @brief Pushes the current $instantGroup on a stack and sets it to the given value (or clears it).

@note Currently only used for editors
@ingroup Editors
@internal */
   virtual void pushInstantGroup(([group])) {}
   /*! @brief Pop and restore the last setting of $instantGroup off the stack.

@note Currently only used for editors

@ingroup Editors
@internal */
   virtual void popInstantGroup(()) {}
   /*! @note Appears to be useless in Torque 3D, should be deprecated
@internal */
   virtual string getPrefsPath(([relativeFileName])) {}
   /*! @brief Manually execute a special script file that contains game or editor preferences

@param relativeFileName Name and path to file from project folder
@param noCalls Deprecated
@param journalScript Deprecated
@return True if script was successfully executed
@note Appears to be useless in Torque 3D, should be deprecated
@ingroup Scripting */
   virtual bool execPrefs(( string relativeFileName, bool noCalls=false, bool journalScript=false )) {}
   /*! Write out the definitions of all global variables matching the given name @a pattern.
If @a fileName is not "", the variable definitions are written to the specified file.  Otherwise the definitions will be printed to the console.

The output are valid TorqueScript statements that can be executed to restore the global variable values.

@param pattern A global variable name pattern.  Must begin with '$'.
@param filename %Path of the file to which to write the definitions or "" to write the definitions to the console.
@param append If true and @a fileName is not "", then the definitions are appended to the specified file. Otherwise existing contents of the file (if any) will be overwritten.

@tsexample
// Write out all preference variables to a prefs.cs file.
export( "$prefs::*", "prefs.cs" );
@endtsexample

@ingroup Scripting */
   virtual void export(( string pattern, string filename="", bool append=false )) {}
   /*! Undefine all global variables matching the given name @a pattern.
@param pattern A global variable name pattern.  Must begin with '$'.
@tsexample
// Define a global variable in the "My" namespace.
$My::Variable = "value";

// Undefine all variable in the "My" namespace.
deleteVariables( "$My::*" );
@endtsexample

@see strIsMatchExpr
@ingroup Scripting */
   virtual void deleteVariables(( string pattern )) {}
   /*! Enable or disable tracing in the script code VM.

When enabled, the script code runtime will trace the invocation and returns from all functions that are called and log them to the console. This is helpful in observing the flow of the script program.

@param enable New setting for script trace execution, on by default.
@ingroup Debugging */
   virtual void trace(( bool enable=true )) {}
   /*! Drops the engine into the native C++ debugger.

This function triggers a debug break and drops the process into the IDE's debugger.  If the process is not running with a debugger attached it will generate a runtime error on most platforms.

@note This function is not available in shipping builds.@ingroup Debugging */
   virtual void debug(()) {}
   /*! Test whether the engine has been compiled with TORQUE_SHIPPING, i.e. in a form meant for final release.

@return True if this is a shipping build; false otherwise.

@ingroup Platform */
   virtual bool isShippingBuild(()) {}
   /*! Test whether the engine has been compiled with TORQUE_DEBUG, i.e. if it includes debugging functionality.

@return True if this is a debug build; false otherwise.

@ingroup Platform */
   virtual bool isDebugBuild(()) {}
   /*! Test whether the engine has been compiled with TORQUE_TOOLS, i.e. if it includes tool-related functionality.

@return True if this is a tool build; false otherwise.

@ingroup Platform */
   virtual bool isToolBuild(()) {}
   /*! Extract the word at the given @a index in the whitespace-separated list in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to extract.
@return The word at the given index or "" if the index is out of range.

@tsexample
getWord( "a b c", 1 ) // Returns "b"
@endtsexample

@see getWords
@see getWordCount
@see getField
@see getRecord
@ingroup FieldManip */
   virtual string getBarWord(( string text, int index )) {}
   /*! Return the number of whitespace-separated words in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@return The number of whitespace-separated words in @a text.

@tsexample
getWordCount( "a b c d e" ) // Returns 5
@endtsexample

@see getFieldCount
@see getRecordCount
@ingroup FieldManip */
   virtual int getBarWordCount(( string text )) {}
   /*! Extract the word at the given @a index in the whitespace-separated list in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to extract.
@return The word at the given index or "" if the index is out of range.

@tsexample
getWord( "a b c", 1 ) // Returns "b"
@endtsexample

@see getWords
@see getWordCount
@see getField
@see getRecord
@ingroup FieldManip */
   virtual string getCommaWord(( string text, int index )) {}
   /*! Return the number of whitespace-separated words in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@return The number of whitespace-separated words in @a text.

@tsexample
getWordCount( "a b c d e" ) // Returns 5
@endtsexample

@see getFieldCount
@see getRecordCount
@ingroup FieldManip */
   virtual int getCommaWordCount(( string text )) {}
   /*! @brief Prints the scripting call stack to the console log.

Used to trace functions called from within functions. Can help discover what functions were called (and not yet exited) before the current point in scripts.

@ingroup Debugging */
   virtual void backtrace(()) {}
   /*! @brief Returns true if the identifier is the name of a declared package.

@ingroup Packages
 */
   virtual bool isPackage(( String identifier )) {}
   /*! @brief Activates an existing package.

The activation occurs by updating the namespace linkage of existing functions and methods. If the package is already activated the function does nothing.
@ingroup Packages
 */
   virtual void activatePackage(( String packageName )) {}
   /*! @brief Deactivates a previously activated package.

The package is deactivated by removing its namespace linkages to any function or method. If there are any packages above this one in the stack they are deactivated as well. If the package is not on the stack this function does nothing.
@ingroup Packages
 */
   virtual void deactivatePackage(( String packageName )) {}
   /*! @brief Returns a space delimited list of the active packages in stack order.

@ingroup Packages
 */
   virtual string getPackageList(()) {}
   /*! @brief Returns true if the passed identifier is the name of a declared class.

@ingroup Console */
   virtual bool isClass(( string identifier )) {}
   /*! @brief Returns true if the class is derived from the super class.

If either class doesn't exist this returns false.
@param className The class name.
@param superClassName The super class to look for.
@ingroup Console */
   virtual bool isMemberOfClass(( string className, string superClassName )) {}
   /*! @brief Returns the description string for the named class.

@param className The name of the class.
@return The class description in string format.
@ingroup Console */
   virtual string getDescriptionOfClass(( string className )) {}
   /*! @brief Returns the category of the given class.

@param className The name of the class.
@ingroup Console */
   virtual string getCategoryOfClass(( string className )) {}
   /*! @brief Returns a list of classes that derive from the named class.

If the named class is omitted this dumps all the classes.
@param className The optional base class name.
@return A tab delimited list of classes.
@ingroup Editors
@internal */
   virtual string enumerateConsoleClasses(( string className="" )) {}
   /*! @brief Provide a list of classes that belong to the given category.

@param category The category name.
@return A tab delimited list of classes.
@ingroup Editors
@internal */
   virtual string enumerateConsoleClassesByCategory(( String category )) {}
   /*! @brief Dumps network statistics for each class to the console.

The returned <i>avg</i>, <i>min</i> and <i>max</i> values are in bits sent per update.  The <i>num</i> value is the total number of events collected.
@note This method only works when TORQUE_NET_STATS is defined in torqueConfig.h.
@ingroup Networking
 */
   virtual void dumpNetStats(()) {}
   /*! @brief Determines the memory consumption of a class or object.

@param objectOrClass The object or class being measured.
@return Returns the total size of an object in bytes.
@ingroup Debugging
 */
   virtual int sizeof(( string objectOrClass )) {}
   /*! Dumps the engine scripting documentation to the specified file overwriting any existing content.
@param outputFile The relative or absolute output file path and name.
@return Returns true if successful.
@ingroup Console */
   virtual bool dumpEngineDocs(( string outputFile )) {}
   /*! Create a XML document containing a dump of the entire exported engine API.

@return A SimXMLDocument containing a dump of the engine's export information or NULL if the operation failed.

@ingroup Console */
   virtual string exportEngineAPIToXML(()) {}
   /*! @brief Returns the first file in the directory system matching the given pattern.

Use the corresponding findNextFile() to step through the results.  If you're only interested in the number of files returned by the pattern match, use getFileCount().

This function differs from findFirstFileMultiExpr() in that it supports a single search pattern being passed in.

@note You cannot run multiple simultaneous file system searches with these functions.  Each call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders a previous search invalid.

@param pattern The path and file name pattern to match against.
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern.
@return The path of the first file matched by the search or an empty string if no matching file could be found.

@tsexample
// Execute all .cs files in a subdirectory and its subdirectories.
for( %file = findFirstFile( "subdirectory/*.cs" ); %file !$= ""; %file = findNextFile() )
   exec( %file );
@endtsexample

@see findNextFile()@see getFileCount()@see findFirstFileMultiExpr()@ingroup FileSearches */
   virtual string findFirstFile(( string pattern, bool recurse=true )) {}
   /*! @brief Returns the next file matching a search begun in findFirstFile().

@param pattern The path and file name pattern to match against.  This is optional and may be left out as it is not used by the code.  It is here for legacy reasons.
@return The path of the next filename matched by the search or an empty string if no more files match.

@tsexample
// Execute all .cs files in a subdirectory and its subdirectories.
for( %file = findFirstFile( "subdirectory/*.cs" ); %file !$= ""; %file = findNextFile() )
   exec( %file );
@endtsexample

@see findFirstFile()@ingroup FileSearches */
   virtual string findNextFile(( string pattern="" )) {}
   /*! @brief Returns the number of files in the directory tree that match the given patterns

This function differs from getFileCountMultiExpr() in that it supports a single search pattern being passed in.

If you're interested in a list of files that match the given pattern and not just the number of files, use findFirstFile() and findNextFile().

@param pattern The path and file name pattern to match against.
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern counting files in subdirectories.
@return Number of files located using the pattern

@tsexample
// Count the number of .cs files in a subdirectory and its subdirectories.
getFileCount( "subdirectory/*.cs" );
@endtsexample

@see findFirstFile()@see findNextFile()@see getFileCountMultiExpr()@ingroup FileSearches */
   virtual int getFileCount(( string pattern, bool recurse=true )) {}
   /*! @brief Returns the first file in the directory system matching the given patterns.

Use the corresponding findNextFileMultiExpr() to step through the results.  If you're only interested in the number of files returned by the pattern match, use getFileCountMultiExpr().

This function differs from findFirstFile() in that it supports multiple search patterns to be passed in.

@note You cannot run multiple simultaneous file system searches with these functions.  Each call to findFirstFile() and findFirstFileMultiExpr() initiates a new search and renders a previous search invalid.

@param pattern The path and file name pattern to match against, such as *.cs.  Separate multiple patterns with TABs.  For example: "*.cs" TAB "*.dso"
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename patterns.
@return String of the first matching file path, or an empty string if no matching files were found.

@tsexample
// Find all DTS or Collada models
%filePatterns = "*.dts" TAB "*.dae";
%fullPath = findFirstFileMultiExpr( %filePatterns );
while ( %fullPath !$= "" )
{
   echo( %fullPath );
   %fullPath = findNextFileMultiExpr( %filePatterns );
}
@endtsexample

@see findNextFileMultiExpr()@see getFileCountMultiExpr()@see findFirstFile()@ingroup FileSearches */
   virtual string findFirstFileMultiExpr(( string pattern, bool recurse=true )) {}
   /*! @brief Returns the next file matching a search begun in findFirstFileMultiExpr().

@param pattern The path and file name pattern to match against.  This is optional and may be left out as it is not used by the code.  It is here for legacy reasons.
@return String of the next matching file path, or an empty string if no matching files were found.

@tsexample
// Find all DTS or Collada models
%filePatterns = "*.dts" TAB "*.dae";
%fullPath = findFirstFileMultiExpr( %filePatterns );
while ( %fullPath !$= "" )
{
   echo( %fullPath );
   %fullPath = findNextFileMultiExpr( %filePatterns );
}
@endtsexample

@see findFirstFileMultiExpr()@ingroup FileSearches */
   virtual string findNextFileMultiExpr(( string pattern="" )) {}
   /*! @brief Returns the number of files in the directory tree that match the given patterns

If you're interested in a list of files that match the given patterns and not just the number of files, use findFirstFileMultiExpr() and findNextFileMultiExpr().

@param pattern The path and file name pattern to match against, such as *.cs.  Separate multiple patterns with TABs.  For example: "*.cs" TAB "*.dso"
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern.
@return Number of files located using the patterns

@tsexample
// Count all DTS or Collada models
%filePatterns = "*.dts" TAB "*.dae";
echo( "Nunmer of shape files:" SPC getFileCountMultiExpr( %filePatterns ) );
@endtsexample

@see findFirstFileMultiExpr()@see findNextFileMultiExpr()@ingroup FileSearches */
   virtual int getFileCountMultiExpr(( string pattern, bool recurse=true )) {}
   /*! @brief Provides the CRC checksum of the given file.

@param fileName The path to the file.
@return The calculated CRC checksum of the file, or -1 if the file could not be found.
@ingroup FileSystem */
   virtual int getFileCRC(( string fileName )) {}
   /*! @brief Determines if the specified file exists or not

@param fileName The path to the file.
@return Returns true if the file was found.
@ingroup FileSystem */
   virtual bool isFile(( string fileName )) {}
   /*! @brief Determines if a specified directory exists or not

@param directory String containing path in the form of "foo/bar"
@return Returns true if the directory was found.
@note Do not include a trailing slash '/'.
@ingroup FileSystem */
   virtual bool IsDirectory(( string directory )) {}
   /*! @brief Determines if a file name can be written to using File I/O

@param fileName Name and path of file to check
@return Returns true if the file can be written to.
@ingroup FileSystem */
   virtual bool isWriteableFileName(( string fileName )) {}
   /*! @brief Start watching resources for file changes

Typically this is called during initializeCore().

@see stopFileChangeNotifications()
@ingroup FileSystem */
   virtual void startFileChangeNotifications(()) {}
   /*! @brief Stop watching resources for file changes

Typically this is called during shutdownCore().

@see startFileChangeNotifications()
@ingroup FileSystem */
   virtual void stopFileChangeNotifications(()) {}
   /*! @brief Gathers a list of directories starting at the given path.

@param path String containing the path of the directory
@param depth Depth of search, as in how many subdirectories to parse through
@return Tab delimited string containing list of directories found during search, "" if no files were found
@ingroup FileSystem */
   virtual string getDirectoryList(( string path, int depth=0 )) {}
   /*! @brief Determines the size of a file on disk

@param fileName Name and path of the file to check
@return Returns filesize in KB, or -1 if no file
@ingroup FileSystem */
   virtual int fileSize(( string fileName )) {}
   /*! @brief Returns a platform specific formatted string with the last modified time for the file.

@param fileName Name and path of file to check
@return Formatted string (OS specific) containing modified time, "9/3/2010 12:33:47 PM" for example
@ingroup FileSystem */
   virtual string fileModifiedTime(( string fileName )) {}
   /*! @brief Returns a platform specific formatted string with the creation time for the file.@param fileName Name and path of file to check
@return Formatted string (OS specific) containing created time, "9/3/2010 12:33:47 PM" for example
@ingroup FileSystem */
   virtual string fileCreatedTime(( string fileName )) {}
   /*! @brief Delete a file from the hard drive

@param path Name and path of the file to delete
@note THERE IS NO RECOVERY FROM THIS. Deleted file is gone for good.
@return True if file was successfully deleted
@ingroup FileSystem */
   virtual bool fileDelete(( string path )) {}
   /*! @brief Get the extension of a file

@param fileName Name and path of file
@return String containing the extension, such as ".exe" or ".cs"
@ingroup FileSystem */
   virtual string fileExt(( string fileName )) {}
   /*! @brief Get the base of a file name (removes extension)

@param fileName Name and path of file to check
@return String containing the file name, minus extension
@ingroup FileSystem */
   virtual string fileBase(( string fileName )) {}
   /*! @brief Get the file name of a file (removes extension and path)

@param fileName Name and path of file to check
@return String containing the file name, minus extension and path
@ingroup FileSystem */
   virtual string fileName(( string fileName )) {}
   /*! @brief Get the path of a file (removes name and extension)

@param fileName Name and path of file to check
@return String containing the path, minus name and extension
@ingroup FileSystem */
   virtual string filePath(( string fileName )) {}
   /*! @brief Reports the current directory

@return String containing full file path of working directory
@ingroup FileSystem */
   virtual string getWorkingDirectory(()) {}
   /*! @brief Converts a relative file path to a full path

For example, "./console.log" becomes "C:/Torque/t3d/examples/FPS Example/game/console.log"
@param path Name of file or path to check
@param cwd Optional current working directory from which to build the full path.
@return String containing non-relative directory of path
@ingroup FileSystem */
   virtual string makeFullPath(( string path, string cwd="" )) {}
   /*! @brief Turns a full or local path to a relative one

For example, "./game/art" becomes "game/art"
@param path Full path (may include a file) to convert
@param to Optional base path used for the conversion.  If not supplied the current working directory is used.
@returns String containing relative path
@ingroup FileSystem */
   virtual string makeRelativePath(( string path, string to="" )) {}
   /*! @brief Combines two separate strings containing a file path and file name together into a single string

@param path String containing file path
@param file String containing file name
@return String containing concatenated file name and path
@ingroup FileSystem */
   virtual string pathConcat(( string path, string file )) {}
   /*! @brief Gets the name of the game's executable

@return String containing this game's executable name
@ingroup FileSystem */
   virtual string getExecutableName(()) {}
   /*! @brief Get the absolute path to the directory that contains the main.cs script from which the engine was started.

This directory will usually contain all the game assets and, in a user-side game installation, will usually be read-only.

@return The path to the main game assets.

@ingroup FileSystem
 */
   virtual string getMainDotCsDir(()) {}
   /*! @brief Open the given folder in the system's file manager.

@param path full path to a directory.

@note Only present in a Tools build of Torque.
@ingroup FileSystem
 */
   virtual void openFolder(( string path )) {}
   /*! @brief Open the given @a file through the system.  This will usually open the file in its associated application.
@param file %Path of the file to open.

@note Only present in a Tools build of Torque.
@ingroup FileSystem
 */
   virtual void openFile(( string file )) {}
   /*! @brief Copy a file to a new location.
@param fromFile %Path of the file to copy.
@param toFile %Path where to copy @a fromFile to.
@param noOverwrite If true, then @a fromFile will not overwrite a file that may already exist at @a toFile.
@return True if the file was successfully copied, false otherwise.
@note Only present in a Tools build of Torque.
@ingroup FileSystem */
   virtual bool pathCopy(( string fromFile, string toFile, bool noOverwrite=true )) {}
   /*! @brief Return the current working directory.

@return The absolute path of the current working directory.

@note Only present in a Tools build of Torque.
@see getWorkingDirectory()@ingroup FileSystem */
   virtual string getCurrentDirectory(()) {}
   /*! @brief Set the current working directory.

@param path The absolute or relative (to the current working directory) path of the directory which should be made the new working directory.

@return True if the working directory was successfully changed to @a path, false otherwise.

@note Only present in a Tools build of Torque.
@ingroup FileSystem */
   virtual bool setCurrentDirectory(( string path )) {}
   /*! @brief Create the given directory or the path leading to the given filename.

If @a path ends in a trailing slash, then all components in the given path will be created as directories (if not already in place).  If @a path, does @b not end in a trailing slash, then the last component of the path is taken to be a file name and only the directory components of the path will be created.

@param path The path to create.

@note Only present in a Tools build of Torque.
@ingroup FileSystem */
   virtual bool createPath(( string path )) {}
   /*! @brief Mounts a world zip

@param fileName The path to the zip file.
@return Returns true if the zip was mounted.
@ingroup FileSystem */
   virtual bool mountWorld(( string fileName )) {}
   /*! @brief Mounts a world zip

@param fileName The path to the zip file.
@return Returns true if the zip was mounted.
@ingroup FileSystem */
   virtual bool unmountWorld(( string fileName )) {}
   /*! @brief Grabs the full path of a specified file

@param filename Name of the local file to locate
@return String containing the full filepath on disk
@ingroup FileSystem */
   virtual string expandFilename((string filename)) {}
   /*! @brief Retrofits a filepath that uses old Torque style

@return String containing filepath with new formatting
@ingroup FileSystem */
   virtual string expandOldFilename((string filename)) {}
   /*! @internal Editor use only */
   virtual string collapseFilename((string filename)) {}
   /*! @internal Editor use only */
   virtual void setScriptPathExpando((string expando, string path[, bool toolsOnly])) {}
   /*! @internal Editor use only */
   virtual void removeScriptPathExpando((string expando)) {}
   /*! @internal Editor use only */
   virtual bool isScriptPathExpando((string expando)) {}

   /*! @name SimFunctions
   
   Functions relating to Sim.
   @{ */
   /*! */
   /*! nameToID(object) */
   virtual int nameToID() {}
   /*! isObject(object) */
   virtual bool isObject() {}
   /*! spawnObject(class [, dataBlock, name, properties, script])@hide */
   virtual int spawnObject() {}
   /*! cancel(eventId) */
   virtual void cancel() {}
   /*! cancelAll(objectId): cancel pending events on the specified object.  Events will be automatically cancelled if object is deleted. */
   virtual void cancelAll() {}
   /*! isEventPending(%scheduleId); */
   virtual bool isEventPending() {}
   /*! getEventTimeLeft(scheduleId) Get the time left in ms until this event will trigger. */
   virtual int getEventTimeLeft() {}
   /*! getScheduleDuration(%scheduleId); */
   virtual int getScheduleDuration() {}
   /*! getTimeSinceStart(%scheduleId); */
   virtual int getTimeSinceStart() {}
   /*! schedule(time, refobject|0, command, <arg1...argN>) */
   virtual int schedule() {}
   /*! @brief Returns a unique unused SimObject name based on a given base name.

@baseName Name to conver to a unique string if another instance exists
@note Currently only used by editors
@ingroup Editors
@internal */
   virtual string getUniqueName(( String baseName )) {}
   /*! @brief Returns a unique unused internal name within the SimSet/Group based on a given base name.

@note Currently only used by editors
@ingroup Editors
@internal */
   virtual string getUniqueInternalName(( String baseName, SimSet set, bool searchChildren )) {}
   /*! @brief Return true if the given name makes for a valid object name.

@param name Name of object
@return True if name is allowed, false if denied (usually because it starts with a number, _, or invalid character@ingroup Console */
   virtual bool isValidObjectName(( string name )) {}
   /// @}

   /*! Preload all datablocks in client mode.

(Server parameter is set to false).  This will take some time to complete. */
   virtual void preloadClientDataBlocks(()) {}
   /*! Delete all the datablocks we've downloaded.

This is usually done in preparation of downloading a new set of datablocks, such as occurs on a mission change, but it's also good post-mission cleanup. */
   virtual void deleteDataBlocks(()) {}
   /*! DumpTimers() */
   virtual void DumpTimers() {}
   /*! @brief Serialize the object to a file.

@param object The object to serialize.
@param filename The file name and path.
@ingroup Console
 */
   virtual bool saveObject(( SimObject  object, string filename )) {}
   /*! @brief Loads a serialized object from a file.

@param Name and path to text file containing the object
@ingroup Console
 */
   virtual string loadObject(( string filename )) {}
   /*! @brief Initializes and open the telnet console.

@param port        Port to listen on for console connections (0 will shut down listening).
@param consolePass Password for read/write access to console.
@param listenPass  Password for read access to console.
@param remoteEcho  [optional] Enable echoing back to the client, off by default.

@ingroup Debugging */
   virtual void telnetSetParameters(( int port, string consolePass, string listenPass, bool remoteEcho=false )) {}
   /*! Open a debug server port on the specified port, requiring the specified password, and optionally waiting for the debug client to connect.
@internal Primarily used for Torsion and other debugging tools */
   virtual void dbgSetParameters((int port, string password, bool waitForClient)) {}
   /*! Returns true if a script debugging client is connected else return false.
@internal Primarily used for Torsion and other debugging tools */
   virtual bool dbgIsConnected(()) {}
   /*! Forcibly disconnects any attached script debugging client.
@internal Primarily used for Torsion and other debugging tools */
   virtual void dbgDisconnect(()) {}
   /*! @brief Enables logging of the connection protocols

When enabled a lot of network debugging information is sent to the console.
@param enabled True to enable, false to disable
@ingroup Networking */
   virtual void DNetSetLogging((bool enabled)) {}

   /*! @name ResourceManagerFunctions
   
   Resource management functions.
   @{ */
   /*! */
   /*! Force the resource at specified input path to be reloaded
@param path Path to the resource to be reloaded

@tsexample
reloadResource( "art/shapes/box.dts" );
@endtsexample

@note Currently used by editors only
@ingroup Editors
@internal */
   virtual void reloadResource(( string path )) {}
   /// @}

   /*! Populate the font cache for the specified font with characters from the specified string.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param string The string to populate.
@ingroup Font
 */
   virtual void populateFontCacheString(( string faceName, int fontSize, string string )) {}
   /*! Populate the font cache for the specified font with Unicode code points in the specified range.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param rangeStart The start Unicode point.
@param rangeEnd The end Unicode point.
@note We only support BMP-0, so code points range from 0 to 65535.
@ingroup Font
 */
   virtual void populateFontCacheRange(( string faceName, int fontSize, int rangeStart, int rangeEnd )) {}
   /*! Dumps to the console a full description of all cached fonts, along with info on the codepoints each contains.
@ingroup Font
 */
   virtual void dumpFontCacheStatus(()) {}
   /*! Force all cached fonts to serialize themselves to the cache.
@ingroup Font
 */
   virtual void writeFontCache(()) {}
   /*! Populate the font cache for all fonts with characters from the specified string.
@ingroup Font
 */
   virtual void populateAllFontCacheString(( string string )) {}
   /*! Populate the font cache for all fonts with Unicode code points in the specified range.
@param rangeStart The start Unicode point.
@param rangeEnd The end Unicode point.
@note We only support BMP-0, so code points range from 0 to 65535.
@ingroup Font
 */
   virtual void populateAllFontCacheRange(( int rangeStart, int rangeEnd )) {}
   /*! Export specified font to the specified filename as a PNG. The image can then be processed in Photoshop or another tool and reimported using importCachedFont. Characters in the font are exported as one long strip.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param fileName The file name and path for the output PNG.
@param padding The padding between characters.
@param kerning The kerning between characters.
@ingroup Font
 */
   virtual void exportCachedFont(( string faceName, int fontSize, string fileName, int padding, int kerning )) {}
   /*! Import an image strip from exportCachedFont. Call with the same parameters you called exportCachedFont.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param fileName The file name and path for the input PNG.
@param padding The padding between characters.
@param kerning The kerning between characters.
@ingroup Font
 */
   virtual void importCachedFont(( string faceName, int fontSize, string fileName, int padding, int kerning )) {}
   /*! Copy the specified old font to a new name. The new copy will not have a platform font backing it, and so will never have characters added to it. But this is useful for making copies of fonts to add postprocessing effects to via exportCachedFont.
@param oldFontName The name of the font face to copy.
@param oldFontSize The size of the font to copy.
@param newFontName The name of the new font face.
@ingroup Font
 */
   virtual void duplicateCachedFont(( string oldFontName, int oldFontSize, string newFontName )) {}
   /*! Returns a tab-seperated string of the detected devices across all adapters.
@ingroup GFX
 */
   virtual string getDisplayDeviceList(()) {}
   /*! Returns a list of the unflagged GFX resources. See flagCurrentGFXResources for usage details.
@ingroup GFX
@see flagCurrentGFXResources, clearGFXResourceFlags, describeGFXResources */
   virtual void listGFXResources(( bool unflaggedOnly=false )) {}
   /*! @brief Flags all currently allocated GFX resources.
Used for resource allocation and leak tracking by flagging current resources then dumping a list of unflagged resources at some later point in execution.
@ingroup GFX
@see listGFXResources, clearGFXResourceFlags, describeGFXResources */
   virtual void flagCurrentGFXResources(()) {}
   /*! Clears the flagged state on all allocated GFX resources. See flagCurrentGFXResources for usage details.
@ingroup GFX
@see flagCurrentGFXResources, listGFXResources, describeGFXResources */
   virtual void clearGFXResourceFlags(()) {}
   /*! @brief Dumps a description of GFX resources to a file or the console.
@param resourceTypes A space seperated list of resource types or an empty string for all resources.
@param filePath A file to dump the list to or an empty string to write to the console.
@param unflaggedOnly If true only unflagged resources are dumped. See flagCurrentGFXResources.
@note The resource types can be one or more of the following:

  - texture
  - texture target
  - window target
  - vertex buffers
  - primitive buffers
  - fences
  - cubemaps
  - shaders
  - stateblocks

@ingroup GFX
 */
   virtual void describeGFXResources(( string resourceTypes, string filePath, bool unflaggedOnly=false )) {}
   /*! Dumps a description of all state blocks.
@param filePath A file to dump the state blocks to or an empty string to write to the console.
@ingroup GFX
 */
   virtual void describeGFXStateBlocks(( string filePath )) {}
   /*! Returns the pixel shader version for the active device.
@ingroup GFX
 */
   virtual float getPixelShaderVersion(()) {}
   /*! @brief Sets the pixel shader version for the active device.
This can be used to force a lower pixel shader version than is supported by the device for testing or performance optimization.
@param version The floating point shader version number.
@note This will only affect shaders/materials created after the call and should be used before the game begins.
@see $pref::Video::forcedPixVersion
@ingroup GFX
 */
   virtual void setPixelShaderVersion(( float version )) {}
   /*! Get the string describing the active GFX device.
@ingroup GFX
 */
   virtual string getDisplayDeviceInformation(()) {}
   /*! Returns the best texture format for storage of HDR data for the active device.
@ingroup GFX
 */
   virtual string getBestHDRFormat(()) {}
   /*! Returns the width, height, and bitdepth of the screen/desktop.

@ingroup GFX */
   virtual string getDesktopResolution(()) {}
   /*! Adds a global shader macro which will be merged with the script defined macros on every shader.  The macro will replace the value of an existing macro of the same name.  For the new macro to take effect all the shaders in the system need to be reloaded.
@see resetLightManager, removeGlobalShaderMacro
@ingroup Rendering
 */
   virtual void addGlobalShaderMacro(( string name, string value=NULL )) {}
   /*! Removes an existing global macro by name.
@see addGlobalShaderMacro
@ingroup Rendering
 */
   virtual void removeGlobalShaderMacro(( string name )) {}
   /*! Releases all textures and resurrects the texture manager.
@ingroup GFX
 */
   virtual void flushTextureCache(()) {}
   /*! Release the unused pooled textures in texture manager freeing up video memory.
@ingroup GFX
 */
   virtual void cleanupTexturePool(()) {}
   /*! Reload all the textures from disk.
@ingroup GFX
 */
   virtual void reloadTextures(()) {}
   /*! Returns a list of texture profiles in the format: ProfileName TextureCount TextureMB
@ingroup GFX
 */
   virtual string getTextureProfileStats(()) {}
   /*! Takes a screenshot with optional tiling to produce huge screenshots.
@param file The output image file path.
@param format Either JPEG or PNG.
@param tileCount If greater than 1 will tile the current screen size to take a large format screenshot.
@param tileOverlap The amount of horizontal and vertical overlap between the tiles used to remove tile edge artifacts from post effects.
@ingroup GFX
 */
   virtual void screenShot(( string file, string format, int tileCount=1, float tileOverlap=0 )) {}
   /*! Returns the count of active DDSs files in memory.
@ingroup Rendering
 */
   virtual int getActiveDDSFiles(()) {}
   /*! Returns image info in the following format: width TAB height TAB bytesPerPixel. It will return an empty string if the file is not found.
@ingroup Rendering
 */
   virtual string getBitmapInfo(( string filename )) {}
   /*! Begins a video capture session.
@see stopVideoCapture
@ingroup Rendering
 */
   virtual void startVideoCapture(( GuiCanvas  canvas, string filename, string encoder="THEORA", float framerate=30.0f, Point2I resolution=Point2I( 0, 0 ) )) {}
   /*! Stops the video capture session.
@see startVideoCapture
@ingroup Rendering
 */
   virtual void stopVideoCapture(()) {}
   /*! Load a journal file and capture it video.
@ingroup Rendering
 */
   virtual void playJournalToVideo(( string journalFile, string videoFile=NULL, string encoder="THEORA", float framerate=30.0f, Point2I resolution=Point2I( 0, 0 ) )) {}
   /*! @brief Strip TorqueML control characters from the specified string, returning a 'clean' version.

@param inString String to strip TorqueML control characters from.
@tsexample
// Define the string to strip TorqueML control characters from
%string = "<font:Arial:24>How Now <color:c43c12>Brown <color:000000>Cow";

// Request the stripped version of the string
%strippedString = StripMLControlChars(%string);
@endtsexample

@return Version of the inputted string with all TorqueML characters removed.

@see References

@ingroup GuiCore */
   virtual string StripMLControlChars(( string inString )) {}
   /*! @brief Used to exclude/prevent all other instances using the same identifier specified

@note Not used on OSX, Xbox, or in Win debug builds

@param appIdentifier Name of the app set up for exclusive use.
@return False if another app is running that specified the same appIdentifier

@ingroup Platform
@ingroup GuiCore */
   virtual bool excludeOtherInstance(( string appIdentifer )) {}
   /*! @brief Gets the primary LangTable used by the game

@return ID of the core LangTable
@ingroup Localization */
   virtual int getCoreLangTable(()) {}
   /*! @brief Sets the primary LangTable used by the game

@param LangTable ID of the core LangTable
@ingroup Localization */
   virtual void setCoreLangTable((string LangTable)) {}
      /*! A callback called by the engine when a light manager is activated.
@param name The name of the light manager being activated.
@ingroup Lighting
 */
      void onLightManagerActivate( string name );

      /*! A callback called by the engine when a light manager is deactivated.
@param name The name of the light manager being deactivated.
@ingroup Lighting
 */
      void onLightManagerDeactivate( string name );

   /*! Finds and activates the named light manager.
@return Returns true if the light manager is found and activated.
@ingroup Lighting
 */
   virtual bool setLightManager(( string name )) {}
   /*! Will generate static lighting for the scene if supported by the active light manager.

If mode is "forceAlways", the lightmaps will be regenerated regardless of whether lighting cache files can be written to. If mode is "forceWritable", then the lightmaps will be regenerated only if the lighting cache files can be written.
@param completeCallbackFn The name of the function to execute when the lighting is complete.
@param mode One of "forceAlways",  "forceWritable" or "loadOnly".
@return Returns true if the scene lighting process was started.
@ingroup Lighting
 */
   virtual bool lightScene(( string completeCallbackFn=NULL, string mode=NULL )) {}
   /*! Returns a tab seperated list of light manager names.
@ingroup Lighting
 */
   virtual string getLightManagerNames(()) {}
   /*! Returns the active light manager name.
@ingroup Lighting
 */
   virtual string getActiveLightManager(()) {}
   /*! @brief Deactivates and then activates the currently active light manager.This causes most shaders to be regenerated and is often used when global rendering changes have occured.
@ingroup Lighting
 */
   virtual void resetLightManager(()) {}
   /*! string sShadowSystemName */
   virtual bool setShadowManager() {}
   virtual string setShadowVizLight() {}
   /*! @brief Flushes all procedural shaders and re-initializes all active material instances.

@ingroup Materials */
   virtual void reInitMaterials() {}
   /*! @brief Maps the given texture to the given material.

Generates a console warning before overwriting.

Material maps are used by terrain and interiors for triggering effects when an object moves onto a terrain block or interior surface using the associated texture.

@ingroup Materials */
   virtual void addMaterialMapping((string texName, string matName)) {}
   /*! @brief Returns the name of the material mapped to this texture.

If no materials are found, an empty string is returned.

@param texName Name of the texture

@ingroup Materials */
   virtual string getMaterialMapping((string texName)) {}
   /*! @brief Dumps a formatted list of currently allocated material instances to the console.

@ingroup Materials */
   virtual void dumpMaterialInstances() {}
   /*! @hide */
   virtual string getMapEntry() {}
   /*! Add two vectors.
@param a The first vector.
@param b The second vector.
@return The vector @a a + @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorAdd( %a, %b );
//
// The sum of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
//
//     a + b = ( ax + bx, ay + by, az + bz )
//
//-----------------------------------------------------------------------------
%a = "1 0 0";
%b = "0 1 0";

// %r = "( 1 + 0, 0 + 1, 0 + 0 )";
// %r = "1 1 0";
%r = VectorAdd( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual string VectorAdd(( VectorF a, VectorF b )) {}
   /*! Subtract two vectors.
@param a The first vector.
@param b The second vector.
@return The vector @a a - @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorSub( %a, %b );
//
// The difference of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
//
//     a - b = ( ax - bx, ay - by, az - bz )
//
//-----------------------------------------------------------------------------

%a = "1 0 0";
%b = "0 1 0";

// %r = "( 1 - 0, 0 - 1, 0 - 0 )";
// %r = "1 -1 0";
%r = VectorSub( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual string VectorSub(( VectorF a, VectorF b )) {}
   /*! Scales a vector by a scalar.
@param a The vector to scale.
@param scalar The scale factor.
@return The vector @a a * @a scalar.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorScale( %a, %v );
//
// Scaling vector a, (ax, ay, az), but the scalar, v, is:
//
//     a * v = ( ax * v, ay * v, az * v )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%v = "2";

// %r = "( 1 * 2, 1 * 2, 0 * 2 )";
// %r = "2 2 0";
%r = VectorScale( %a, %v );
@endtsexample

@ingroup Vectors */
   virtual string VectorScale(( VectorF a, float scalar )) {}
   /*! Brings a vector into its unit form, i.e. such that it has the magnitute 1.
@param v The vector to normalize.
@return The vector @a v scaled to length 1.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorNormalize( %a );
//
// The normalized vector a, (ax, ay, az), is:
//
//     a^ = a / ||a||
//        = ( ax / ||a||, ay / ||a||, az / ||a|| )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%l = 1.414;

// %r = "( 1 / 1.141, 1 / 1.141, 0 / 1.141 )";
// %r = "0.707 0.707 0";
%r = VectorNormalize( %a );
@endtsexample

@ingroup Vectors */
   virtual string VectorNormalize(( VectorF v )) {}
   /*! Compute the dot product of two vectors.
@param a The first vector.
@param b The second vector.
@return The dot product @a a * @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorDot( %a, %b );
//
// The dot product between vector a, (ax, ay, az), and vector b, (bx, by, bz), is:
//
//     a . b = ( ax * bx + ay * by + az * bz )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = "( 1 * 2 + 1 * 0 + 0 * 1 )";
// %r = 2;
%r = VectorDot( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual float VectorDot(( VectorF a, VectorF b )) {}
   /*! Calculcate the cross product of two vectors.
@param a The first vector.
@param b The second vector.
@return The cross product @a x @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorCross( %a, %b );
//
// The cross product of vector a, (ax, ay, az), and vector b, (bx, by, bz), is
//
//     a x b = ( ( ay * bz ) - ( az * by ), ( az * bx ) - ( ax * bz ), ( ax * by ) - ( ay * bx ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = "( ( 1 * 1 ) - ( 0 * 0 ), ( 0 * 2 ) - ( 1 * 1 ), ( 1 * 0 ) - ( 1 * 2 ) )";
// %r = "1 -1 -2";
%r = VectorCross( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual string VectorCross(( VectorF a, VectorF b )) {}
   /*! Compute the distance between two vectors.
@param a The first vector.
@param b The second vector.
@return The length( @a b - @a a ).

@tsexample
//-----------------------------------------------------------------------------
//
// VectorDist( %a, %b );
//
// The distance between vector a, (ax, ay, az), and vector b, (bx, by, bz), is
//
//     a -> b = ||( b - a )||
//            = ||( bx - ax, by - ay, bz - az )||
//            = mSqrt( ( bx - ax ) * ( bx - ax ) + ( by - ay ) * ( by - ay ) + ( bz - az ) * ( bz - az ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = mSqrt( ( 2 - 1 ) * ( 2 - 1) + ( 0 - 1 ) * ( 0 - 1 ) + ( 1 - 0 ) * ( 1 - 0 ) );
// %r = mSqrt( 3 );
%r = VectorDist( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual float VectorDist(( VectorF a, VectorF b )) {}
   /*! Calculate the magnitude of the given vector.
@param v A vector.
@return The length of vector @a v.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorLen( %a );
//
// The length or magnitude of  vector a, (ax, ay, az), is:
//
//     ||a|| = Sqrt( ax * ax + ay * ay + az * az )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";

// %r = mSqrt( 1 * 1 + 1 * 1 + 0 * 0 );
// %r = mSqrt( 2 );
// %r = 1.414;
%r = VectorLen( %a );
@endtsexample

@ingroup Vectors */
   virtual float VectorLen(( VectorF v )) {}
   /*! Create an orthogonal basis from the given vector.
@param aaf The vector to create the orthogonal basis from.
@return A matrix representing the orthogonal basis.
@ingroup Vectors */
   virtual string VectorOrthoBasis(( AngAxisF aa )) {}
   /*! Linearly interpolate between two vectors by @a t.
@param a Vector to start interpolation from.
@param b Vector to interpolate to.
@param t Interpolation factor (0-1).  At zero, @a a is returned and at one, @a b is returned.  In between, an interpolated vector between @a a and @a b is returned.
@return An interpolated vector between @a a and @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorLerp( %a, %b );
//
// The point between vector a, (ax, ay, az), and vector b, (bx, by, bz), which is
// weighted by the interpolation factor, t, is
//
//     r = a + t * ( b - a )
//       = ( ax + t * ( bx - ax ), ay + t * ( by - ay ), az + t * ( bz - az ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";
%v = "0.25";

// %r = "( 1 + 0.25 * ( 2 - 1 ), 1 + 0.25 * ( 0 - 1 ), 0 + 0.25 * ( 1 - 0 ) )";
// %r = "1.25 0.75 0.25";
%r = VectorLerp( %a, %b );
@endtsexample

@ingroup Vectors */
   virtual string VectorLerp(( VectorF a, VectorF b, float t )) {}
   /*! Create a transform from the given translation and orientation.
@param position The translation vector for the transform.
@param orientation The axis and rotation that orients the transform.
@return A transform based on the given position and orientation.
@ingroup Matrices */
   virtual string MatrixCreate(( VectorF position, AngAxisF orientation )) {}
   /*! @Create a matrix from the given rotations.

@param Vector3F X, Y, and Z rotation in *radians*.
@return A transform based on the given orientation.
@ingroup Matrices */
   virtual string MatrixCreateFromEuler(( Point3F angles )) {}
   /*! @brief Multiply the two matrices.

@param left First transform.
@param right Right transform.
@return Concatenation of the two transforms.
@ingroup Matrices */
   virtual string MatrixMultiply(( TransformF left, TransformF right )) {}
   /*! @brief Multiply the vector by the transform assuming that w=0.

This function will multiply the given vector by the given transform such that translation will not affect the vector.

@param transform A transform.
@param vector A vector.
@return The transformed vector.
@ingroup Matrices */
   virtual string MatrixMulVector(( TransformF transform, VectorF vector )) {}
   /*! @brief Multiply the given point by the given transform assuming that w=1.

This function will multiply the given vector such that translation with take effect.
@param transform A transform.
@param point A vector.
@return The transformed vector.
@ingroup Matrices */
   virtual string MatrixMulPoint(( TransformF transform, Point3F point )) {}

   /*! @name MatrixMath
   
   Resource management functions.
   @{ */
   /*! */
   /*! Get the center point of an axis-aligned box.

@param b A Box3F, in string format using "minExtentX minExtentY minExtentZ maxExtentX maxExtentY maxExtentZ"
@return Center of the box.
@ingroup Math */
   virtual string getBoxCenter(( Box3F box )) {}
   /*! Set the current seed for the random number generator.
Based on this seed, a repeatable sequence of numbers will be produced by getRandom().
@param seed The seed with which to initialize the randon number generator with.  The same seed will always leed tothe same sequence of pseudo-random numbers.
If -1, the current timestamp will be used as the seed which is a good basis for randomization.
@ingroup Random */
   virtual void setRandomSeed(( int seed=-1 )) {}
   /*! Get the current seed used by the random number generator.
@return The current random number generator seed value.
@ingroup Random */
   virtual int getRandomSeed(()) {}
   /*! @brief Returns a random number based on parameters passed in..

If no parameters are passed in, getRandom() will return a float between 0.0 and 1.0. If one parameter is passed an integer between 0 and the passed in value will be returned. Two parameters will return an integer between the specified numbers.

@param a If this is the only parameter, a number between 0 and a is returned. Elsewise represents the lower bound.
@param b Upper bound on the random number.  The random number will be <= @a b.
@return A pseudo-random integer between @a a and @a b, between 0 and a, or a float between 0.0 and 1.1 depending on usage.

@note All parameters are optional.@see setRandomSeed
@ingroup Random */
   virtual float getRandom(( int a, int b )) {}
   /*! Solve a quadratic equation (2nd degree polynomial) of form a*x^2 + b*x + c = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@returns A triple, containing: (sol x0 x1). (sol) is the number of solutions(being 0, 1, or 2), and (x0) and (x1) are the solutions, if any.@ingroup Math */
   virtual string mSolveQuadratic(( float a, float b, float c )) {}
   /*! Solve a cubic equation (3rd degree polynomial) of form a*x^3 + b*x^2 + c*x + d = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@param d Fourth Coefficient.@returns A 4-tuple, containing: (sol x0 x1 x2). (sol) is the number of solutions(being 0, 1, 2 or 3), and (x0), (x1) and (x2) are the solutions, if any.@ingroup Math */
   virtual string mSolveCubic(( float a, float b, float c, float d )) {}
   /*! Solve a quartic equation (4th degree polynomial) of form a*x^4 + b*x^3 + c*x^2 + d*x + e = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@param d Fourth Coefficient.@param e Fifth Coefficient.@returns A 5-tuple, containing: (sol x0 x1 x2 c3). (sol) is the number of solutions(being 0, 1, 2, 3 or 4), and (x0), (x1), (x2) and (x3) are the solutions, if any.@ingroup Math */
   virtual string mSolveQuartic(( float a, float b, float c, float d, float e )) {}
   /*! Round v down to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math */
   virtual int mFloor(( float v )) {}
   /*! Round v to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math */
   virtual int mRound(( float v )) {}
   /*! Round v up to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math */
   virtual int mCeil(( float v )) {}
   /*! Formats the specified number to the given number of decimal places.
@param v Number to format.@param precision Number of decimal places to format to (1-9).@returns Number formatted to the specified number of decimal places.@ingroup Math */
   virtual string mFloatLength(( float v, int precision )) {}
   /*! Calculate absolute value of specified value.
@param v Input Value.@returns Absolute value of specified value.@ingroup Math */
   virtual float mAbs(( float v )) {}
   /*! Calculate the remainder of v/d.
@param v Input Value.@param d Divisor Value.@returns The remainder of v/d.@ingroup Math */
   virtual float mFMod(( float v, float d )) {}
   /*! Calculate the square-root of v.
@param v Input Value.@returns The square-root of the input value.@ingroup Math */
   virtual float mSqrt(( float v )) {}
   /*! Calculate b raised to the p-th power.
@param v Input Value.@param p Power to raise value by.@returns v raised to the p-th power.@ingroup Math */
   virtual float mPow(( float v, float p )) {}
   /*! Calculate the natural logarithm of v.
@param v Input Value.@returns The natural logarithm of the input value.@ingroup Math */
   virtual float mLog(( float v )) {}
   /*! Calculate the sine of v.
@param v Input Value (in radians).@returns The sine of the input value.@ingroup Math */
   virtual float mSin(( float v )) {}
   /*! Calculate the cosine of v.
@param v Input Value (in radians).@returns The cosine of the input value.@ingroup Math */
   virtual float mCos(( float v )) {}
   /*! Calculate the tangent of v.
@param v Input Value (in radians).@returns The tangent of the input value.@ingroup Math */
   virtual float mTan(( float v )) {}
   /*! Calculate the arc-sine of v.
@param v Input Value (in radians).@returns The arc-sine of the input value.@ingroup Math */
   virtual float mAsin(( float v )) {}
   /*! Calculate the arc-cosine of v.
@param v Input Value (in radians).@returns The arc-cosine of the input value.@ingroup Math */
   virtual float mAcos(( float v )) {}
   /*! Calculate the arc-tangent (slope) of a line defined by rise and run.
@param rise of line.@param run of line.@returns The arc-tangent (slope) of a line defined by rise and run.@ingroup Math */
   virtual float mAtan(( float rise, float run )) {}
   /*! Convert specified radians into degrees.
@param radians Input Value (in radians).@returns The specified radians value converted to degrees.@ingroup Math */
   virtual float mRadToDeg(( float radians )) {}
   /*! Convert specified degrees into radians.
@param degrees Input Value (in degrees).@returns The specified degrees value converted to radians.@ingroup Math */
   virtual float mDegToRad(( float degrees )) {}
   /*! Clamp the specified value between two bounds.
@param v Input value.@param min Minimum Bound.@param max Maximum Bound.@returns The specified value clamped to the specified bounds.@ingroup Math */
   virtual float mClamp(( float v, float min, float max )) {}
   /*! Clamp the specified value between 0 and 1 (inclusive).
@param v Input value.@returns The specified value clamped between 0 and 1 (inclusive).@ingroup Math */
   virtual float mSaturate(( float v )) {}
   /*! Calculate the greater of two specified numbers.
@param v1 Input value.@param v2 Input value.@returns The greater value of the two specified values.@ingroup Math */
   virtual float getMax(( float v1, float v2 )) {}
   /*! Calculate the lesser of two specified numbers.
@param v1 Input value.@param v2 Input value.@returns The lesser value of the two specified values.@ingroup Math */
   virtual float getMin(( float v1, float v2 )) {}
   /*! Calculate linearly interpolated value between two specified numbers using specified normalized time.
@param v1 Interpolate From Input value.@param v2 Interpolate To Input value.@param time Normalized time used to interpolate values (0-1).@returns The interpolated value between the two specified values at normalized time t.@ingroup Math */
   virtual float mLerp(( float v1, float v2, float time )) {}
   /*! Return the value of PI (half-circle in radians).
@returns The value of PI.@ingroup Math */
   virtual float mPi(()) {}
   /*! Return the value of 2*PI (full-circle in radians).
@returns The value of 2*PI.@ingroup Math */
   virtual float m2Pi(()) {}
   /*! Returns whether the value is an exact power of two.
@param v Input value.@returns Whether the specified value is an exact power of two.@ingroup Math */
   virtual bool mIsPow2(( int v )) {}
   /*! restartInstance() */
   virtual void restartInstance() {}
   /*! @brief Returns the OS temporary directory, "C:/Users/Mich/AppData/Local/Temp" for example

@note This can be useful to adhering to OS standards and practices, but not really used in Torque 3D right now.
@note Be very careful when getting into OS level File I/O.@return String containing path to OS temp directory
@note This is legacy function brought over from TGB, and does not appear to have much use. Possibly deprecate?
@ingroup FileSystem
@internal */
   virtual string getTemporaryDirectory(()) {}
   /*! @brief Creates a name and extension for a potential temporary file

This does not create the actual file. It simply creates a random name for a file that does not exist.

@note This is legacy function brought over from TGB, and does not appear to have much use. Possibly deprecate?
@ingroup FileSystem
@internal */
   virtual string getTemporaryFileName(()) {}
   /*! getUserDataDirectory() */
   virtual string getUserDataDirectory() {}
   /*! getUserHomeDirectory() */
   virtual string getUserHomeDirectory() {}
   /// @}

   /*! @brief Dumps some useful statistics regarding free memory.

Dumps an analysis of 'free chunks' of memory. Does not print how much memory is free.

@ingroup Debugging */
   virtual void freeMemoryDump(()) {}

   /*! @name Memory
   
   Memory manager utility functions.
   @{ */
   /*! */
   /// @}

   /*! @brief Deprecated

@internal */
   virtual bool redbookOpen((string device=NULL)) {}
   /*! Close the current Redbook device.@brief Deprecated

@internal */
   virtual bool redbookClose() {}
   /*! Play the selected track.@brief Deprecated

@internal */
   virtual bool redbookPlay((int track)) {}
   /*! Stop playing.@brief Deprecated

@internal */
   virtual bool redbookStop() {}
   /*! Return the number of tracks.@brief Deprecated

@internal */
   virtual int redbookGetTrackCount() {}
   /*! Get the volume.@brief Deprecated

@internal */
   virtual float redbookGetVolume() {}
   /*! Set playback volume.@brief Deprecated

@internal */
   virtual bool redbookSetVolume((float volume)) {}
   /*! get the number of redbook devices.@brief Deprecated

@internal */
   virtual int redbookGetDeviceCount() {}
   /*! Get name of specified Redbook device.@brief Deprecated

@internal */
   virtual string redbookGetDeviceName((int index)) {}
   /*! Get a string explaining the last redbook error.@brief Deprecated

@internal */
   virtual string redbookGetLastError() {}

   /*! @name Redbook
   
   Control functions for Redbook audio (ie, CD audio).
   @{ */
   /*! */
   /*! startPrecisionTimer() - Create and start a high resolution platform timer. Returns the timer id. */
   virtual int startPrecisionTimer() {}
   /*! stopPrecisionTimer( S32 id ) - Stop and destroy timer with the passed id.  Returns the elapsed milliseconds. */
   virtual int stopPrecisionTimer() {}
   /*! @brief Enable or disable a specific profile.

@param enable     Optional paramater to enable or disable the profile.
@param markerName Name of a specific marker to enable or disable.
@note Calling this function will first call profilerReset(), clearing all data from profiler. All profile markers are enabled by default.

@ingroup Debugging */
   virtual void profilerMarkerEnable(( string markerName, bool enable=true )) {}
   /*! @brief Enables or disables the profiler.

Data is only gathered while the profiler is enabled.

@note Profiler is not available in shipping builds.
T3D has predefined profiling areas surrounded by markers, but you may need to define additional markers (in C++) around areas you wish to profile, by using the PROFILE_START( markerName ); and PROFILE_END(); macros.

@ingroup Debugging
 */
   virtual void profilerEnable(( bool enable )) {}
   /*! @brief Dumps current profiling stats to the console window.

@note Markers disabled with profilerMarkerEnable() will be skipped over. If the profiler is currently running, it will be disabled.
@ingroup Debugging */
   virtual void profilerDump(()) {}
   /*! @brief Dumps current profiling stats to a file.

@note If the profiler is currently running, it will be disabled.
@param fileName Name and path of file to save profiling stats to. Must use forward slashes (/). Will attempt to create the file if it does not already exist.
@tsexample
profilerDumpToFile( "C:/Torque/log1.txt" );
@endtsexample

@ingroup Debugging */
   virtual void profilerDumpToFile(( string fileName )) {}
   /*! @brief Resets the profiler, clearing it of all its data.

If the profiler is currently running, it will first be disabled. All markers will retain their current enabled/disabled status.

@ingroup Debugging */
   virtual void profilerReset(()) {}
   /*! @brief Used to determine if the Oculus VR input device is active

The Oculus VR device is considered active when the library has been initialized and either a real of simulated HMD is present.

@return True if the Oculus VR input device is active.
@ingroup Game */
   virtual bool isOculusVRDeviceActive(()) {}
   /*! @brief Sets the first HMD to be a GameConnection's display device

@param conn The GameConnection to set.
@return True if the GameConnection display device was set.
@ingroup Game */
   virtual bool setOVRHMDAsGameConnectionDisplayDevice(( GameConnection conn )) {}
   /*! @brief Get the number of HMD devices that are currently connected.

@return The number of Oculus VR HMD devices that are currently connected.
@ingroup Game */
   virtual int getOVRHMDCount(()) {}
   /*! @brief Determines if the requested OVR HMD is simulated or real.

@param index The HMD index.
@return True if the HMD is simulated.
@ingroup Game */
   virtual bool isOVRHMDSimulated(( int index )) {}
   /*! @brief Retrieves the HMD product name.

@param index The HMD index.
@return The name of the HMD product.
@ingroup Game */
   virtual string getOVRHMDProductName(( int index )) {}
   /*! @brief Retrieves the HMD manufacturer name.

@param index The HMD index.
@return The manufacturer of the HMD product.
@ingroup Game */
   virtual string getOVRHMDManufacturer(( int index )) {}
   /*! @brief Retrieves the HMD version number.

@param index The HMD index.
@return The version number of the HMD product.
@ingroup Game */
   virtual int getOVRHMDVersion(( int index )) {}
   /*! @brief Windows display device name used in EnumDisplaySettings/CreateDC.

@param index The HMD index.
@return The name of the HMD display device, if any.
@ingroup Game */
   virtual string getOVRHMDDisplayDeviceName(( int index )) {}
   /*! @brief MacOS display ID.

@param index The HMD index.
@return The ID of the HMD display device, if any.
@ingroup Game */
   virtual int getOVRHMDDisplayDeviceId(( int index )) {}
   /*! @brief Desktop coordinate position of the screen (can be negative; may not be present on all platforms).

@param index The HMD index.
@return Position of the screen.
@ingroup Game */
   virtual string getOVRHMDDisplayDesktopPos(( int index )) {}
   /*! @brief Provides the OVR HMD screen resolution.

@param index The HMD index.
@return A two component string with the screen's resolution.
@ingroup Game */
   virtual string getOVRHMDResolution(( int index )) {}
   /*! @brief Provides the OVR HMD distortion coefficients.

@param index The HMD index.
@return A four component string with the distortion coefficients.
@ingroup Game */
   virtual string getOVRHMDDistortionCoefficients(( int index )) {}
   /*! @brief Provides the OVR HMD chromatic aberration correction values.

@param index The HMD index.
@return A four component string with the chromatic aberration correction values.
@ingroup Game */
   virtual string getOVRHMDChromaticAbCorrection(( int index )) {}
   /*! @brief Physical distance between the user's eye centers as defined by the current profile.

@param index The HMD index.
@return The profile IPD.
@ingroup Game */
   virtual float getOVRHMDProfileIPD(( int index )) {}
   /*! @brief Physical distance between the user's eye centers.

@param index The HMD index.
@return The current IPD.
@ingroup Game */
   virtual float getOVRHMDCurrentIPD(( int index )) {}
   /*! @brief Set the physical distance between the user's eye centers.

@param index The HMD index.
@param ipd The IPD to use.
@ingroup Game */
   virtual void setOVRHMDCurrentIPD(( int index, float ipd )) {}
   /*! @brief Provides the OVR HMD eye x offsets in uv coordinates.

@param index The HMD index.
@return A two component string with the left and right eye x offsets.
@ingroup Game */
   virtual string getOVRHMDEyeXOffsets(( int index )) {}
   /*! @brief Provides the OVR HMD calculated XCenterOffset.

@param index The HMD index.
@return The calculated XCenterOffset.
@ingroup Game */
   virtual float getOVRHMDXCenterOffset(( int index )) {}
   /*! @brief Provides the OVR HMD calculated distortion scale.

@param index The HMD index.
@return The calculated distortion scale.
@ingroup Game */
   virtual float getOVRHMDDistortionScale(( int index )) {}
   /*! @brief Provides the OVR HMD calculated Y FOV.

@param index The HMD index.
@return The calculated Y FOV.
@ingroup Game */
   virtual float getOVRHMDYFOV(( int index )) {}
   /*! @brief Get the number of sensor devices that are currently connected.

@return The number of Oculus VR sensor devices that are currently connected.
@ingroup Game */
   virtual int getOVRSensorCount(()) {}
   /*! @brief Get the Euler rotation values for the given sensor index.

@param index The sensor index.
@return The Euler rotation values of the Oculus VR sensor, in degrees.
@ingroup Game */
   virtual string getOVRSensorEulerRotation(( int index )) {}
   /*! @brief Get the acceleration values for the given sensor index.

@param index The sensor index.
@return The acceleration values of the Oculus VR sensor, in m/s^2.
@ingroup Game */
   virtual string getOVRSensorAcceleration(( int index )) {}
   /*! @brief Get the angular velocity values for the given sensor index.

@param index The sensor index.
@return The angular velocity values of the Oculus VR sensor, in degrees/s.
@ingroup Game */
   virtual string getOVRSensorAngVelocity(( int index )) {}
   /*! @brief Get the magnetometer reading (direction and field strength) for the given sensor index.

@param index The sensor index.
@return The magnetometer reading (direction and field strength) of the Oculus VR sensor, in Gauss.
@ingroup Game */
   virtual string getOVRSensorMagnetometer(( int index )) {}
   /*! @brief Get the prediction time set for the given sensor index.

@param index The sensor index.
@return The prediction time of the Oculus VR sensor, given in seconds.
@ingroup Game */
   virtual float getOVRSensorPredictionTime(( int index )) {}
   /*! @brief Set the prediction time set for the given sensor index.

@param index The sensor index.
@param dt The prediction time to set given in seconds.  Setting to 0 disables prediction.
@ingroup Game */
   virtual void setSensorPredictionTime(( int index, float dt )) {}
   /*! @brief Set the prediction time set for all sensors.

@param dt The prediction time to set given in seconds.  Setting to 0 disables prediction.
@ingroup Game */
   virtual void setAllSensorPredictionTime(( float dt )) {}
   /*! @brief Get the gravity correction state for the given sensor index.

@param index The sensor index.
@return True if gravity correction (for pitch and roll) is active.
@ingroup Game */
   virtual bool getOVRSensorGravityCorrection(( int index )) {}
   /*! @brief Set the gravity correction state for the given sensor index.

@param index The sensor index.
@param state The gravity correction state to change to.
@ingroup Game */
   virtual void setOVRSensorGravityCorrection(( int index, bool state )) {}
   /*! @brief Get the yaw correction state for the given sensor index.

@param index The sensor index.
@return True if yaw correction (using magnetometer calibration data) is active.
@ingroup Game */
   virtual bool getOVRSensorYawCorrection(( int index )) {}
   /*! @brief Set the yaw correction state for the given sensor index.

@param index The sensor index.
@param state The yaw correction state to change to.
@note Yaw correction cannot be enabled if the user has disabled it through the Oculus VR control panel.
@ingroup Game */
   virtual void setOVRSensorYawCorrection(( int index, bool state )) {}
   /*! @brief Get the magnetometer calibrated data state for the given sensor index.

@param index The sensor index.
@return True if magnetometer calibration data is available.
@ingroup Game */
   virtual bool getOVRSensorMagnetometerCalibrated(( int index )) {}
   /*! @brief Resets all Oculus VR sensors.

This resets all sensor orientations such that their 'normal' rotation is defined when this function is called.  This defines an HMD's forwards and up direction, for example.@ingroup Game */
   virtual void ovrResetAllSensors(()) {}
   /*! Display a modal message box using the platform's native message box implementation.

@param title The title to display on the message box window.
@param message The text message to display in the box.
@param buttons Which buttons to put on the message box.
@param icons Which icon to show next to the message.
@return One of $MROK, $MRCancel, $MRRetry, and $MRDontSave identifying the button that the user pressed.
@tsexample
messageBox( "Error", "" );
@endtsexample

@ingroup Platform */
   virtual int messageBox(( string title, string message, MBButtons buttons=MBOkCancel, MBIcons icons=MIInformation )) {}
   /*! @brief Initializes variables that track device and vendor information/IDs

@ingroup Rendering */
   virtual void initDisplayDeviceInfo(()) {}
   /*! enableWinConsole(bool); */
   virtual void enableWinConsole() {}
   /*! @brief Enables use of the joystick.

@note DirectInput must be enabled and active to use this function.

@ingroup Input */
   virtual bool enableJoystick(()) {}
   /*! @brief Disables use of the joystick.

@note DirectInput must be enabled and active to use this function.

@ingroup Input */
   virtual void disableJoystick(()) {}
   /*! @brief Queries input manager to see if a joystick is enabled

@return 1 if a joystick exists and is enabled, 0 if it's not.
@ingroup Input */
   virtual bool isJoystickEnabled(()) {}
   /*! @brief Enables XInput for Xbox 360 controllers.

@note XInput is enabled by default. Disable to use an Xbox 360 Controller as a joystick device.

@ingroup Input */
   virtual bool enableXInput(()) {}
   /*! @brief Disables XInput for Xbox 360 controllers.

@ingroup Input */
   virtual void disableXInput(()) {}
   /*! @brief Rebuilds the XInput section of the InputManager

Requests a full refresh of events for all controllers. Useful when called at the beginning of game code after actionMaps are set up to hook up all appropriate events.

@ingroup Input */
   virtual void resetXInput(()) {}
   /*! @brief Checks to see if an Xbox 360 controller is connected

@param controllerID Zero-based index of the controller to check.
@return 1 if the controller is connected, 0 if it isn't, and 205 if XInput hasn't been initialized.@ingroup Input */
   virtual bool isXInputConnected(( int controllerID )) {}
   /*! @brief Queries the current state of a connected Xbox 360 controller.

XInput Properties:

 - XI_THUMBLX, XI_THUMBLY - X and Y axes of the left thumbstick. 
 - XI_THUMBRX, XI_THUMBRY - X and Y axes of the right thumbstick. 
 - XI_LEFT_TRIGGER, XI_RIGHT_TRIGGER - Left and Right triggers. 
 - SI_UPOV, SI_DPOV, SI_LPOV, SI_RPOV - Up, Down, Left, and Right on the directional pad.
 - XI_START, XI_BACK - The Start and Back buttons.
 - XI_LEFT_THUMB, XI_RIGHT_THUMB - Clicking in the left and right thumbstick.
 - XI_LEFT_SHOULDER, XI_RIGHT_SHOULDER - Left and Right bumpers.
 - XI_A, XI_B , XI_X, XI_Y - The A, B, X, and Y buttons.

@param controllerID Zero-based index of the controller to return information about.
@param property Name of input action being queried, such as "XI_THUMBLX".
@param current True checks current device in action.
@return Button queried - 1 if the button is pressed, 0 if it's not.
@return Thumbstick queried - Int representing displacement from rest position.@return %Trigger queried - Int from 0 to 255 representing how far the trigger is displaced.@ingroup Input */
   virtual int getXInputState(( int controllerID, string property, bool current )) {}
   /*! @brief Prints information to the console stating if DirectInput and a Joystick are enabled and active.

@ingroup Input */
   virtual void echoInputState(()) {}
   /*! @brief Activates the vibration motors in the specified controller.

The controller will constantly at it's xRumble and yRumble intensities until changed or told to stop.Valid inputs for xRumble/yRumble are [0 - 1].
@param device Name of the device to rumble.
@param xRumble Intensity to apply to the left motor.
@param yRumble Intensity to apply to the right motor.
@note in an Xbox 360 controller, the left motor is low-frequency, while the right motor is high-frequency.@ingroup Input */
   virtual void rumble((string device, float xRumble, float yRumble)) {}
   /*! @brief Launches an outside executable or batch file

@param executable Name of the executable or batch file
@param args Optional list of arguments, in string format, to pass to the executable
@param directory Optional string containing path to output or shell
@ingroup Platform */
   virtual bool shellExecute((string executable, string args, string directory)) {}
   /*! @brief Launches an outside executable or batch file

@param executable Name of the executable or batch file
@param args Optional list of arguments, in string format, to pass to the executable
@param directory Optional string containing path to output or shell
@ingroup Platform */
   virtual bool shellExecuteWait((string executable, string args, string directory)) {}
   /*! isJoystickDetected() */
   virtual bool isJoystickDetected() {}
   /*! getJoystickAxes( instance ) */
   virtual string getJoystickAxes() {}
   /*! @brief Install the math library with specified extensions.

Possible parameters are:

    - 'DETECT' Autodetect math lib settings.

    - 'C' Enable the C math routines. C routines are always enabled.

    - 'FPU' Enable floating point unit routines.

    - 'MMX' Enable MMX math routines.

    - '3DNOW' Enable 3dNow! math routines.

    - 'SSE' Enable SSE math routines.

@ingroup Math */
   virtual void mathInit(( ... )) {}
   /*! isKoreanBuild() */
   virtual bool isKoreanBuild() {}
   /*! Creates a 64x64 normal map texture filled with noise. The texture is saved to randNormTex.png in the location of the game executable.

@ingroup GFX */
   virtual void dumpRandomNormalMap(()) {}
   virtual void clearServerPaths() {}
   virtual void clearClientPaths() {}
   /*! Set the reflection texture format.
@ingroup GFX
 */
   virtual void setReflectFormat(( GFXFormat format )) {}
   /// @}

   /*! @brief See if any objects of the given types are present in box of given extent.

@note Extent parameter is last since only one radius is often needed.  If one radius is provided, the yRadius and zRadius are assumed to be the same.  Unfortunately, if you need to use the client container, you'll need to set all of the radius parameters.  Fortunately, this function is mostly used on the server.
@param  mask   Indicates the type of objects we are checking against.
@param  center Center of box.
@param  xRadius Search radius in the x-axis. See note above.
@param  yRadius Search radius in the y-axis. See note above.
@param  zRadius Search radius in the z-axis. See note above.
@param useClientContainer Optionally indicates the search should be within the client container.
@return true if the box is empty, false if any object is found.
@ingroup Game */
   virtual bool containerBoxEmpty(( int mask, Point3F center, float xRadius, float yRadius=-1, float zRadius=-1, bool useClientContainer=false )) {}
   /*! @brief Start a search for items at the given position and within the given radius, filtering by mask.

@param pos Center position for the search
@param radius Search radius
@param mask Bitmask of object types to include in the search
@param useClientContainer Optionally indicates the search should be within the client container.
@see containerSearchNext
@ingroup Game */
   virtual void initContainerRadiusSearch(( Point3F pos, float radius, int mask, bool useClientContainer=false )) {}
   /*! @brief Start a search for all items of the types specified by the bitset mask.

@param mask Bitmask of object types to include in the search
@param useClientContainer Optionally indicates the search should be within the client container.
@see containerSearchNext
@ingroup Game */
   virtual void initContainerTypeSearch(( int mask, bool useClientContainer=false )) {}
   /*! @brief Get next item from a search started with initContainerRadiusSearch() or initContainerTypeSearch().

@param useClientContainer Optionally indicates the search should be within the client container.
@return the next object found in the search, or null if no more
@tsexample
// print the names of all nearby ShapeBase derived objects
%position = %obj.getPosition;
%radius = 20;
%mask = $TypeMasks::ShapeBaseObjectType;
initContainerRadiusSearch( %position, %radius, %mask );
while ( (%targetObject = containerSearchNext()) != 0 )
{
   echo( "Found: " @ %targetObject.getName() );
}
@endtsexample
@see initContainerRadiusSearch()
@see initContainerTypeSearch()
@ingroup Game */
   virtual string containerSearchNext(( bool useClientContainer=false )) {}
   /*! @brief Get distance of the center of the current item from the center of the current initContainerRadiusSearch.

@param useClientContainer Optionally indicates the search should be within the client container.
@return distance from the center of the current object to the center of the search
@see containerSearchNext
@ingroup Game */
   virtual float containerSearchCurrDist(( bool useClientContainer=false )) {}
   /*! @brief Get the distance of the closest point of the current item from the center of the current initContainerRadiusSearch.

@param useClientContainer Optionally indicates the search should be within the client container.
@return distance from the closest point of the current object to the center of the search
@see containerSearchNext
@ingroup Game */
   virtual float containerSearchCurrRadiusDist(( bool useClientContainer=false )) {}
   /*! @brief Cast a ray from start to end, checking for collision against items matching mask.

If pExempt is specified, then it is temporarily excluded from collision checks (For instance, you might want to exclude the player if said player was firing a weapon.)
@param start An XYZ vector containing the tail position of the ray.
@param end An XYZ vector containing the head position of the ray
@param mask A bitmask corresponding to the type of objects to check for
@param pExempt An optional ID for a single object that ignored for this raycast
@param useClientContainer Optionally indicates the search should be within the client container.
@returns A string containing either null, if nothing was struck, or these fields:
<ul><li>The ID of the object that was struck.</li><li>The x, y, z position that it was struck.</li><li>The x, y, z of the normal of the face that was struck.</li><li>The distance between the start point and the position we hit.</li></ul>@ingroup Game */
   virtual string containerRayCast(( Point3F start, Point3F end, int mask, SceneObject  pExempt=NULL, bool useClientContainer=false )) {}
   /*! @brief Cast a ray from start to end, checking for collision against items matching mask.

If pExempt is specified, then it is temporarily excluded from collision checks (For instance, you might want to exclude the player if said player was firing a weapon.)
@param start An XYZ vector containing the tail position of the ray.
@param end An XYZ vector containing the head position of the ray
@param mask A bitmask corresponding to the type of objects to check for
@param pExempt An optional ID for a single object that ignored for this raycast
@param useClientContainer Optionally indicates the search should be within the client container.
@returns A string containing either null, if nothing was struck, or these fields:
<ul><li>The ID of the object that was struck.</li><li>The x, y, z position that it was struck.</li><li>The x, y, z of the normal of the face that was struck.</li><li>The distance between the start point and the position we hit.</li></ul>@ingroup Game */
   virtual string meleeRayCast(( Point3F start, Point3F end, int mask, SceneObject  pExempt=NULL, bool useClientContainer=false )) {}

   /*! @name Containers
   
   Functions for ray casting and spatial queries.


   @{ */
   /*! */
   /*! Dump the current zoning states of all zone spaces in the scene to the console.

@param updateFirst If true, zoning states are brought up to date first; if false, the zoning states are dumped as is.

@note Only valid on the client.
@ingroup Game */
   virtual void sceneDumpZoneStates(( bool updateFirst=true )) {}
   /*! Return the SceneObject that contains the given zone.

@param zoneId ID of zone.
@return A SceneObject or NULL if the given @a zoneId is invalid.

@note Only valid on the client.
@ingroup Game */
   virtual string sceneGetZoneOwner(( int zoneId=true )) {}
   /*! @brief Load all Path information from the mission.

This function is usually called from the loadMissionStage2() server-side function after the mission file has loaded.  Internally it places all Paths into the server's PathManager.  From this point the Paths are ready for transmission to the clients.

@tsexample
// Inform the engine to load all Path information from the mission.
pathOnMissionLoadDone();

@endtsexample
@see NetConnection::transmitPaths()
@see NetConnection::clearPaths()
@see Path
@ingroup Networking */
   virtual void pathOnMissionLoadDone(()) {}
   /*! Return a newline-separated list of all active states.
@return A list of the form
@verbatim
stateName1 NL stateName2 NL stateName3 ...
@endverbatim
where each element is the name of an active state object.

@tsexample
// Disable all active states.
foreach$( %state in sfxGetActiveStates() )
   %state.disable();
@endtsexample

@ingroup SFX */
   virtual string sfxGetActiveStates(()) {}
   /*! Get a list of all available sound devices.
The return value will be a newline-separated list of entries where each line describes one available sound device.  Each such line will have the following format:@verbatim
provider TAB device TAB hasHardware TAB numMaxBuffers
@endverbatim
- provider: The name of the device provider (e.g. "FMOD").
- device: The name of the device as returned by the device layer.
- hasHardware: Whether the device supports hardware mixing or not.
- numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.

@return A newline-separated list of information about all available sound devices.
@see sfxCreateDevice
@see sfxGetDeviceInfo

@see $SFX::DEVICE_INFO_PROVIDER

@see $SFX::DEVICE_INFO_NAME

@see $SFX::DEVICE_INFO_USEHARDWARE

@see $SFX::DEVICE_INFO_MAXBUFFERS

@ref SFX_devices
@ingroup SFX */
   virtual string sfxGetAvailableDevices(()) {}
   /*! Try to create a new sound device using the given properties.
If a sound device is currently initialized, it will be uninitialized first.  However, be aware that in this case, if this function fails, it will not restore the previously active device but rather leave the sound system in an uninitialized state.

Sounds that are already playing while the new device is created will be temporarily transitioned to virtualized playback and then resume normal playback once the device has been created.

In the core scripts, sound is automatically set up during startup in the sfxStartup() function.

@param provider The name of the device provider as returned by sfxGetAvailableDevices().
@param device The name of the device as returned by sfxGetAvailableDevices().
@param useHardware Whether to enabled hardware mixing on the device or not.  Only relevant if supported by the given device.
@param maxBuffers The maximum number of concurrent voices for this device to use or -1 for the device to pick its own reasonable default.@return True if the initialization was successful, false if not.
@note This function must be called before any of the sound playback functions can be used.
@see sfxGetAvailableDevices
@see sfxGetDeviceInfo
@see sfxDeleteDevice

@ref SFX_devices
@ingroup SFX */
   virtual bool sfxCreateDevice(( string provider, string device, bool useHardware, int maxBuffers )) {}
   /*! Delete the currently active sound device and release all its resources.
SFXSources that are still playing will be transitioned to virtualized playback mode. When creating a new device, they will automatically transition back to normal playback.

In the core scripts, this is done automatically for you during shutdown in the sfxShutdown() function.

@see sfxCreateDevice

@ref SFX_devices
@ingroup SFX */
   virtual void sfxDeleteDevice(()) {}
   /*! Return information about the currently active sound device.
The return value is a tab-delimited string of the following format:
@verbatim
provider TAB device TAB hasHardware TAB numMaxBuffers TAB caps
@endverbatim
- provider: The name of the device provider (e.g. "FMOD").
- device: The name of the device as returned by the device layer.
- hasHardware: Whether the device supports hardware mixing or not.
- numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
- caps: A bitfield of capability flags.

@return A tab-separated list of properties of the currently active sound device or the empty string if no sound device has been initialized.
@see sfxCreateDevice
@see sfxGetAvailableDevices

@see $SFX::DEVICE_INFO_PROVIDER

@see $SFX::DEVICE_INFO_NAME

@see $SFX::DEVICE_INFO_USEHARDWARE

@see $SFX::DEVICE_INFO_MAXBUFFERS

@see $SFX::DEVICE_INFO_CAPS

@see $SFX::DEVICE_CAPS_REVERB

@see $SFX::DEVICE_CAPS_VOICEMANAGEMENT

@see $SFX::DEVICE_CAPS_OCCLUSION

@see $SFX::DEVICE_CAPS_DSPEFFECTS

@see $SFX::DEVICE_CAPS_MULTILISTENER

@see $SFX::DEVICE_CAPS_FMODDESIGNER

@ref SFX_devices
@ingroup SFX */
   virtual string sfxGetDeviceInfo(()) {}
   /*! Creates a new paused sound source using a profile or a description and filename.  The return value is the source which must be released by delete().
@hide */
   virtual int sfxCreateSource(( SFXTrack track | ( SFXDescription description, string filename ) [, float x, float y, float z ] )) {}
   /*! Start playing the given source or create a new source for the given track and play it.
@hide */
   virtual int sfxPlay(( SFXSource source | ( SFXTrack track [, float x, float y, float z ] ) )) {}
   /*! SFXSource sfxPlayOnce( ( SFXTrack track | SFXDescription description, string filename ) [, float x, float y, float z, float fadeInTime=-1 ] ) Create a new play-once source for the given profile or description+filename and start playback of the source.
@hide */
   virtual int sfxPlayOnce() {}
   /*! Stop playback of the given @a source.
This is equivalent to calling SFXSource::stop().

@param source The source to put into stopped state.

@ingroup SFX */
   virtual void sfxStop(( SFXSource source )) {}
   /*! Stop playback of the given @a source (if it is not already stopped) and delete the @a source.

The advantage of this function over directly calling delete() is that it will correctly handle volume fades that may be configured on the source.  Whereas calling delete() would immediately stop playback and delete the source, this functionality will wait for the fade-out to play and only then stop the source and delete it.

@param source A sound source.

@ref SFXSource_fades

@ingroup SFX */
   virtual void sfxStopAndDelete(( SFXSource source )) {}
   /*! Mark the given @a source for deletion as soon as it moves into stopped state.

This function will retroactively turn the given @a source into a play-once source (see @ref SFXSource_playonce).

@param source A sound source.

@ingroup SFX */
   virtual void sfxDeleteWhenStopped(( SFXSource source )) {}
   /*! Get the falloff curve type currently being applied to 3D sounds.

@return The current distance model type.

@ref SFXSource_volume

@ref SFX_3d

@ingroup SFX */
   virtual string sfxGetDistanceModel(()) {}
   /*! Set the falloff curve type to use for distance-based volume attenuation of 3D sounds.

@param model The distance model to use for 3D sound.

@note This setting takes effect globally and is applied to all 3D sounds.

@ingroup SFX */
   virtual void sfxSetDistanceModel(( SFXDistanceModel model )) {}
   /*! Get the current global doppler effect setting.

@return The current global doppler effect scale factor (>=0).

@see sfxSetDopplerFactor

@ref SFXSource_doppler

@ingroup SFX */
   virtual float sfxGetDopplerFactor(()) {}
   /*! Set the global doppler effect scale factor.
@param value The new doppler shift scale factor.
@pre @a value must be >= 0.
@see sfxGetDopplerFactor

@ref SFXSource_doppler

@ingroup SFX */
   virtual void sfxSetDopplerFactor(( float value )) {}
   /*! Get the current global scale factor applied to volume attenuation of 3D sounds in the logarithmic model.
@return The current scale factor for logarithmic 3D sound falloff curves.

@see sfxGetDistanceModel
@see SFXDistanceModel

@ref SFXSource_volume
@ref SFX_3d
@ingroup SFX */
   virtual float sfxGetRolloffFactor(()) {}
   /*! Set the global scale factor to apply to volume attenuation of 3D sounds in the logarithmic model.
@param value The new scale factor for logarithmic 3D sound falloff curves.

@pre @a value must be > 0.
@note This function has no effect if the currently distance model is set to SFXDistanceModel::Linear.

@see sfxGetDistanceModel
@see SFXDistanceModel

@ref SFXSource_volume
@ref SFX_3d
@ingroup SFX */
   virtual void sfxSetRolloffFactor(( float value )) {}
   /*! Dump information about all current SFXSource instances to the console.
The dump includes information about the playback status for each source, volume levels, virtualization, etc.
@param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. Otherwise only instances of subclasses of SFXSources are included in the dump.
@see SFXSource
@see sfxDumpSourcesToString
@ingroup SFX */
   virtual void sfxDumpSources(( bool includeGroups=false )) {}
   /*! Dump information about all current SFXSource instances to a string.
The dump includes information about the playback status for each source, volume levels, virtualization, etc.
@param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. Otherwise only instances of subclasses of SFXSources are included in the dump.
@return A string containing a dump of information about all currently instantiated SFXSources.
@see SFXSource
@see sfxDumpSources
@ingroup SFX */
   virtual string sfxDumpSourcesToString(( bool includeGroups=false )) {}
   /*! @brief Returns the current %ActionMap.
@see ActionMap@ingroup Input */
   virtual string getCurrentActionMap(()) {}
   /// @}

   /*! allowConnections(bool allow);@brief Sets whether or not the global NetInterface allows connections from remote hosts.

@param allow Set to true to allow remote connections.
@ingroup Networking
 */
   virtual void allowConnections() {}

   /*! @name NetInterface
   
   Global control functions for the netInterfaces.
   @{ */
   /*! */
   /*! Gets the terrain block that is located under the given world point.
@param x/y/z The world coordinates (floating point values) you wish to query at. These can be formatted as either a string ("x y z") or separately as (x, y, z)
@return Returns the ID of the requested terrain block (0 if not found).

@hide */
   virtual int getTerrainUnderWorldPoint((Point3F x/y/z)) {}
   /*! gets the terrain height at the specified position.@param pos The world space point, minus the z (height) value
 Can be formatted as either ("x y") or (x,y)
@return Returns the terrain height at the given point as an F32 value.
@hide */
   virtual float getTerrainHeight((Point2 pos)) {}
   /*! gets the terrain height at the specified position.@param pos The world space point. Can be formatted as either ("x y z") or (x,y,z)
@note This function is useful if you simply want to grab the terrain height underneath an object.
@return Returns the terrain height at the given point as an F32 value.
@hide */
   virtual float getTerrainHeightBelowPosition((Point3F pos)) {}
   /*! tsUpdateImposterImages( bool forceupdate ) */
   virtual void tsUpdateImposterImages() {}
   /*! Collect scene information from a COLLADA file and store it in a GuiTreeView control. This function is used by the COLLADA import gui to show a preview of the scene contents prior to import, and is probably not much use for anything else.
@param shapePath COLLADA filename
@param ctrl GuiTreeView control to add elements to
@return true if successful, false otherwise
@ingroup Editors
@internal */
   virtual bool enumColladaForImport((string shapePath, GuiTreeViewCtrl ctrl)) {}
   /*! Load all light instances from a COLLADA (.dae) file and add to the scene.
@param filename COLLADA filename to load lights from
@param parentGroup (optional) name of an existing simgroup to add the new lights to (defaults to MissionGroup)
@param baseObject (optional) name of an object to use as the origin (useful if you are loading the lights for a collada scene and have moved or rotated the geometry)
@return true if successful, false otherwise

@tsexample
// load the lights in room.dae
loadColladaLights( "art/shapes/collada/room.dae" );

// load the lights in room.dae and add them to the RoomLights group
loadColladaLights( "art/shapes/collada/room.dae", "RoomLights" );

// load the lights in room.dae and use the transform of the "Room"
object as the origin
loadColladaLights( "art/shapes/collada/room.dae", "", "Room" );
@endtsexample

@note Currently for editor use only
@ingroup Editors
@internal */
   virtual bool loadColladaLights((string filename, SimGroup parentGroup=MissionGroup, SimObject baseObject=-1)) {}
   /*! @brief Run unit tests, or just the tests that prefix match against the searchString.

@ingroup Console */
   virtual void unitTest_runTests(([searchString[, bool skipInteractive]])) {}
   /*! @brief Reset FPS stats (fps::)

@ingroup Game */
   virtual void resetFPSTracker(()) {}
   /*! @brief Takes a string informing the backend where to store sample data and optionally a name of the specific logging backend to use.  The default is the CSV backend. In most cases, the logging store will be a file name.@tsexample
beginSampling( "mysamples.csv" );
@endtsexample

@ingroup Rendering */
   virtual void beginSampling((location, [backend])) {}
   /*! @brief Stops the rendering sampler

@ingroup Rendering
 */
   virtual void stopSampling(()) {}
   /*! @brief Enable sampling for all keys that match the given name pattern. Slashes are treated as separators.

@ingroup Rendering */
   virtual void enableSamples((pattern, [state])) {}
   /*! @brief Determines if a dispatcher queue exists

@param queueName String containing the name of queue
@ingroup Messaging */
   virtual bool isQueueRegistered((string queueName)) {}
   /*! @brief Registeres a dispatcher queue

@param queueName String containing the name of queue
@ingroup Messaging */
   virtual void registerMessageQueue((string queueName)) {}
   /*! @brief Unregisters a dispatcher queue

@param queueName String containing the name of queue
@ingroup Messaging */
   virtual void unregisterMessageQueue((string queueName)) {}
   /*! @brief Registers an event message

@param queueName String containing the name of queue to attach listener to
@param listener Name of event messenger
@ingroup Messaging */
   virtual bool registerMessageListener((string queueName, string listener)) {}
   /*! @brief Unregisters an event message

@param queueName String containing the name of queue
@param listener Name of event messenger
@ingroup Messaging */
   virtual void unregisterMessageListener((string queueName, string listener)) {}
   /*! @brief Dispatch a message to a queue

@param queueName Queue to dispatch the message to
@param message Message to dispatch
@param data Data for message
@return True for success, false for failure
@see dispatchMessageObject
@ingroup Messaging */
   virtual bool dispatchMessage((string queueName, string message, string data)) {}
   /*! @brief Dispatch a message object to a queue

@param queueName Queue to dispatch the message to
@param message Message to dispatch
@return true for success, false for failure
@see dispatchMessage
@ingroup Messaging */
   virtual bool dispatchMessageObject((string queueName, string message)) {}
};


/*!
@brief Base class for almost all objects involved in the simulation.

@ingroup Console
 */
class  SimObject {
  public:
   /*! Dump the hierarchy of this object up to RootGroup to the console. */
   virtual void dumpGroupHierarchy(()) {}
   /*! Test whether the given method is defined on this object.
@param The name of the method.
@return True if the object implements the given method. */
   virtual bool isMethod(( string methodName )) {}
   /*! Test whether the object belongs directly or indirectly to the given group.
@param group The SimGroup object.
@return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to. */
   virtual bool isChildOfGroup(( SimGroup group )) {}
   /*! Get the name of the class namespace assigned to this object.
@return The name of the 'class' namespace. */
   virtual string getClassNamespace(()) {}
   /*! Get the name of the superclass namespace assigned to this object.
@return The name of the 'superClass' namespace. */
   virtual string getSuperClassNamespace(()) {}
   /*! Assign a class namespace to this object.
@param name The name of the 'class' namespace for this object. */
   virtual void setClassNamespace(( string name )) {}
   /*! Assign a superclass namespace to this object.
@param name The name of the 'superClass' namespace for this object. */
   virtual void setSuperClassNamespace(( string name )) {}
   /*! Get whether the object has been marked as selected. (in editor)
@return True if the object is currently selected. */
   virtual bool isSelected(()) {}
   /*! Set whether the object has been marked as selected. (in editor)
@param state True if object is to be marked selected; false if not. */
   virtual void setIsSelected(( bool state=true )) {}
   /*! Get whether the object has been marked as expanded. (in editor)
@return True if the object is marked expanded. */
   virtual bool isExpanded(()) {}
   /*! Set whether the object has been marked as expanded. (in editor)
@param state True if the object is to be marked expanded; false if not. */
   virtual void setIsExpanded(( bool state=true )) {}
   /*! Returns the filename the object is attached to.
@return The name of the file the object is associated with; usually the file the object was loaded from. */
   virtual string getFilename(()) {}
   /*! Sets the object's file name and path
@param fileName The name of the file to associate this object with. */
   virtual void setFilename(( string fileName )) {}
   /*! Get the line number at which the object is defined in its file.

@return The line number of the object's definition in script.
@see getFilename() */
   virtual int getDeclarationLine(()) {}
   /*! Copy fields from another object onto this one.  The objects must be of same type. Everything from the object will overwrite what's in this object; extra fields in this object will remain. This includes dynamic fields.
@param fromObject The object from which to copy fields. */
   virtual void assignFieldsFrom(( SimObject fromObject )) {}
   /*! Assign a persistent ID to the object if it does not already have one. */
   virtual void assignPersistentId(()) {}
   /*! Get whether the object will be included in saves.
@return True if the object will be saved; false otherwise. */
   virtual bool getCanSave(()) {}
   /*! Set whether the object will be included in saves.
@param value If true, the object will be included in saves; if false, it will be excluded. */
   virtual void setCanSave(( bool value=true )) {}
   /*! Return true if the object is only used by the editor.
@return True if this object exists only for the sake of editing. */
   virtual bool isEditorOnly(()) {}
   /*! Set/clear the editor-only flag on this object.
@param value If true, the object is marked as existing only for the editor. */
   virtual void setEditorOnly(( bool value=true )) {}
   /*! Get whether this object may be renamed.
@return True if this object can be renamed; false otherwise. */
   virtual bool isNameChangeAllowed(()) {}
   /*! Set whether this object can be renamed from its first name.
@param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error. */
   virtual void setNameChangeAllowed(( bool value=true )) {}
   /*! Create a copy of this object.
@return An exact duplicate of this object. */
   virtual string clone(()) {}
   /*! Create a copy of this object and all its subobjects.
@return An exact duplicate of this object and all objects it references. */
   virtual string deepClone(()) {}
   /*! Lock/unlock the object in the editor.
@param value If true, the object will be locked; if false, the object will be unlocked. */
   virtual void setLocked(( bool value=true )) {}
   /*! Hide/unhide the object.
@param value If true, the object will be hidden; if false, the object will be unhidden. */
   virtual void setHidden(( bool value=true )) {}
   /*! List the methods defined on this object.

Each description is a newline-separated vector with the following elements:
- Minimum number of arguments.
- Maximum number of arguments.
- Prototype string.
- Full script file path (if script method).
- Line number of method definition in script (if script method).

- Documentation string (not including prototype).  This takes up the remainder of the vector.
@return An ArrayObject populated with (name,description) pairs of all methods defined on the object. */
   virtual string dumpMethods(()) {}
   /*! Dump a description of all fields and methods defined on this object to the console.
@param detailed Whether to print detailed information about members. */
   virtual void dump(( bool detailed=false )) {}
   /*! Save out the object to the given file.
@param fileName The name of the file to save to.@param selectedOnly If true, only objects marked as selected will be saved out.
@param preAppendString Text which will be preprended directly to the object serialization.
@param True on success, false on failure. */
   virtual bool save(( string fileName, bool selectedOnly=false, string preAppendString="" )) {}
   /*! Set the global name of the object.
@param newName The new global name to assign to the object.
@note If name changing is disallowed on the object, the method will fail with a console error. */
   virtual void setName(( string newName )) {}
   /*! Get the global name of the object.
@return The global name assigned to the object. */
   virtual string getName(()) {}
   /*! Get the name of the C++ class which the object is an instance of.
@return The name of the C++ class of the object. */
   virtual string getClassName(()) {}
   /*! Test whether the given field is defined on this object.
@param fieldName The name of the field.
@return True if the object implements the given field. */
   virtual bool isField(( string fieldName )) {}
   /*! Return the value of the given field on this object.
@param fieldName The name of the field.  If it includes a field index, the index is parsed out.
@param index Optional parameter to specify the index of an array field separately.
@return The value of the given field or "" if undefined. */
   virtual string getFieldValue(( string fieldName, int index=-1 )) {}
   /*! Set the value of the given field on this object.
@param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
@param value The new value to assign to the field.
@param index Optional argument to specify an index for an array field.
@return True. */
   virtual bool setFieldValue(( string fieldName, string value, int index=-1 )) {}
   /*! Get the console type code of the given field.
@return The numeric type code for the underlying console type of the given field. */
   virtual string getFieldType(( string fieldName )) {}
   /*! Set the console type code for the given field.
@param fieldName The name of the dynamic field to change to type for.
@param type The name of the console type.
@note This only works for dynamic fields.  Types of static fields cannot be changed. */
   virtual void setFieldType(( string fieldName, string type )) {}
   /*! Dynamically call a method on an object.
@param method Name of method to call.
@param args Zero or more arguments for the method.
@return The result of the method call. */
   virtual string call(( string method, string args... )) {}
   /*! Set the internal name of the object.
@param newInternalName The new internal name for the object. */
   virtual void setInternalName(( string newInternalName )) {}
   /*! Get the internal name of the object.
@return The internal name of the object. */
   virtual string getInternalName(()) {}
   /*! Dump the native C++ class hierarchy of this object's C++ class to the console. */
   virtual void dumpClassHierarchy(()) {}
   /*! Test whether this object is a member of the specified class.
@param className Name of a native C++ class.
@return True if this object is an instance of the given C++ class or any of its super classes. */
   virtual bool isMemberOfClass(( string className )) {}
   /*! Test whether the namespace of this object is a direct or indirect child to the given namespace.
@param name The name of a namespace.
@return True if the given namespace name is within the namespace hierarchy of this object. */
   virtual bool isInNamespaceHierarchy(( string name )) {}
   /*! Get the underlying unique numeric ID of the object.
@note Object IDs are unique only during single engine runs.
@return The unique numeric ID of the object. */
   virtual int getId(()) {}
   /*! Get the group that this object is contained in.
@note If not assigned to particular SimGroup, an object belongs to RootGroup.
@return The SimGroup object to which the object belongs. */
   virtual string getGroup(()) {}
   /*! Delete and remove the object. */
   virtual void delete(()) {}
   /*! Delay an invocation of a method.
@param time The number of milliseconds after which to invoke the method.  This is a soft limit.
@param method The method to call.
@param args The arguments with which to call the method.
@return The numeric ID of the created schedule.  Can be used to cancel the call.
 */
   virtual int schedule(( float time, string method, string args... )) {}
   /*! Get the number of dynamic fields defined on the object.
@return The number of dynamic fields defined on the object. */
   virtual int getDynamicFieldCount(()) {}
   /*! Get a value of a dynamic field by index.
@param index The index of the dynamic field.
@return The value of the dynamic field at the given index or "". */
   virtual string getDynamicField(( int index )) {}
   /*! Get the number of static fields on the object.
@return The number of static fields defined on the object. */
   virtual int getFieldCount(()) {}
   /*! Retrieve the value of a static field by index.
@param index The index of the static field.
@return The value of the static field with the given index or "". */
   virtual string getField(( int index )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /*!
   Optional global name of this object.
   
    */
   string name;
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /*!
   Optional name that may be used to lookup this object within a SimSet.
   
    */
   string internalName;
   /*!
   Group hierarchy parent of the object.
   
    */
   SimObject parentGroup;
   /*!
   Script class of object.
   
    */
   string class;
   /*!
   Script super-class of object.
   
    */
   string superClass;
   /*!
   Script class of object.
   
    */
   string className;
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /*!
   Whether the object is visible.
   
    */
   bool hidden;
   /*!
   Whether the object can be edited.
   
    */
   bool locked;
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /*!
   Whether the object can be saved out. If false, the object is purely transient in nature.
   
    */
   bool canSave;
   /*!
   True if dynamic fields (added at runtime) should be saved. Defaults to true.
   
    */
   bool canSaveDynamicFields;
   /*!
   The universally unique identifier for the object.
   
    */
   pid persistentId;
   /// @}

};

/*!
@brief ActionMaps assign platform input events to console commands.

Any platform input event can be bound in a single, generic way. In theory, the game doesn't need to know if the event came from the keyboard, mouse, joystick or some other input device. This allows users of the game to map keys and actions according to their own preferences. Game action maps are arranged in a stack for processing so individual parts of the game can define specific actions. For example, when the player jumps into a vehicle it could push a vehicle action map and pop the default player action map.

@section ActionMap_creation Creating an ActionMap
The input system allows for the creation of multiple ActionMaps, so long as they have unique names and do not already exist. It's a simple three step process.

1. Check to see if the ActionMap exists
2. Delete it if it exists
3. Instantiate the ActionMap

The following is an example of how to create a new ActionMap:
@tsexample
if ( isObject( moveMap ) )
^moveMap.delete();
new ActionMap(moveMap);@endtsexample


@section ActionMap_binding Binding Functions
Once you have created an ActionMap, you can start binding functionality to events. Currently, Torque 3D supports the following devices out of the box

* Mouse

* Keyboard

* Joystick/Gamepad

* Xbox 360 Controller

The two most commonly used binding methods are bind() and bindCmd(). Both are similar in that they will bind functionality to a device and event, but different in how the event is interpreted. With bind(), you specify a device, action to bind, then a function to be called when the event happens.

@tsexample
// Simple function that prints to console
// %val - Sent by the device letting the user know
// if an input was pressed (true) or released (false)
function testInput(%val)
{
   if(%val)
^  echo("Key is down");
   else
^  echo("Key was released");
}

// Bind the 'K' key to the testInput function
moveMap.bind(keyboard, "k", testInput);

@endtsexample


bindCmd is an alternative method for binding commands. This function is similar to bind(), except two functions are set to be called when the event is processed.

One will be called when the event is activated (input down), while the other is activated when the event is broken (input release). When using bindCmd(), pass the functions as strings rather than the function names.

@tsexample
// Print to the console when the spacebar is pressed
function onSpaceDown()
{
   echo("Space bar down!");
}

// Print to the console when the spacebar is released
function onSpaceUp()
{
   echo("Space bar up!");
}

// Bind the commands onSpaceDown and onSpaceUp to spacebar events
moveMap.bindCmd(keyboard, "space", "onSpaceDown();", "onSpaceUp();");
@endtsexample

@section ActionMap_switching Switching ActionMaps
Let's say you want to have different ActionMaps activated based on game play situations. A classic example would be first person shooter controls and racing controls in the same game. On foot, spacebar may cause your player to jump. In a vehicle, it may cause some kind of "turbo charge". You simply need to push/pop the ActionMaps appropriately:

First, create two separate ActionMaps:

@tsexample
// Create the two ActionMaps
if ( isObject( moveMap ) )
^moveMap.delete();
new ActionMap(moveMap);

if ( isObject( carMap ) )
^carMap.delete();
new ActionMap(carMap);

@endtsexample

Next, create the two separate functions. Both will be bound to spacebar, but not the same ActionMap:

@tsexample
// Print to the console the player is jumping
function playerJump(%val)
{
   if(%val)
^  echo("Player jumping!");
}

// Print to the console the vehicle is charging
function turboCharge()
{
   if(%val)
^  echo("Vehicle turbo charging!");
}
@endtsexample

You are now ready to bind functions to your ActionMaps' devices:

@tsexample
// Bind the spacebar to the playerJump function
// when moveMap is the active ActionMap
moveMap.bind(keyboard, "space", playerJump);

// Bind the spacebar to the turboCharge function
// when carMap is the active ActionMap
carMap.bind(keyboard, "space", turboCharge);
@endtsexample
Finally, you can use the push() and pop() commands on each ActionMap to toggle activation. To activate an ActionMap, use push():

@tsexample
// Make moveMap the active action map
// You should now be able to activate playerJump with spacebar
moveMap.push();
@endtsexample

To switch ActionMaps, first pop() the old one. Then you can push() the new one:

@tsexample
// Deactivate moveMap
moveMap.pop();

// Activate carMap
carMap.push();

@endtsexample


 */
class  ActionMap : public SimObject {
  public:
   /*! actionMap.bind( device, action, [modifier spec, mod...], command )@hide */
   virtual bool bind() {}
   /*! @hide */
   virtual bool bindObj((device, action, [modifier spec, mod...], command, object)) {}
   /*! @brief Associates a make command and optional break command to a specified input device action.

Must include parenthesis and semicolon in the make and break command strings.

@param device The device to bind to. Can be a keyboard, mouse, joystick or gamepad.
@param action The device action to bind to. The action is dependant upon the device. Specify a key for keyboards.
@param makeCmd The command to execute when the device/action is made.
@param breakCmd [optional] The command to execute when the device or action is unmade.
@return True the bind was successful, false if the device was unknown or description failed.
@tsexample
// Print to the console when the spacebar is pressed
function onSpaceDown()
{
   echo("Space bar down!");
}

// Print to the console when the spacebar is released
function onSpaceUp()
{
   echo("Space bar up!");
}

// Bind the commands onSpaceDown() and onSpaceUp() to spacebar events

moveMap.bindCmd(keyboard, "space", "onSpaceDown();", "onSpaceUp();");
@endtsexample

 */
   virtual bool bindCmd(( string device, string action, string makeCmd, string breakCmd="" )) {}
   /*! @brief Removes the binding on an input device and action.
@param device The device to unbind from. Can be a keyboard, mouse, joystick or a gamepad.
@param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
@return True if the unbind was successful, false if the device was unknown or description failed.

@tsexample
moveMap.unbind("keyboard", "space");
@endtsexample

 */
   virtual bool unbind(( string device, string action )) {}
   /*! @brief Remove any object-binding on an input device and action.
@param device The device to bind to.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action to unbind from. The action is dependant upon the device. Specify a key for keyboards.
@param obj The object to perform unbind against.
@return True if the unbind was successful, false if the device was unknown or description failed.
@tsexample
moveMap.unbindObj("keyboard", "numpad1", "rangeChange", %player);@endtsexample


 */
   virtual bool unbindObj(( string device, string action, string obj )) {}
   /*! @brief Saves the ActionMap to a file or dumps it to the console.

@param fileName The file path to save the ActionMap to. If a filename is not specified  the ActionMap will be dumped to the console.
@param append Whether to write the ActionMap at the end of the file or overwrite it.
@tsexample
// Write out the actionmap into the config.cs file
moveMap.save( "scripts/client/config.cs" );@endtsexample

 */
   virtual void save(( string fileName=NULL, bool append=false )) {}
   /*! @brief Push the ActionMap onto the %ActionMap stack.

Activates an ActionMap and placees it at the top of the ActionMap stack.

@tsexample
// Make moveMap the active action map
moveMap.push();
@endtsexample

@see ActionMap */
   virtual void push(()) {}
   /*! @brief Pop the ActionMap off the %ActionMap stack.

Deactivates an %ActionMap and removes it from the @ActionMap stack.
@tsexample
// Deactivate moveMap
moveMap.pop();
@endtsexample

@see ActionMap */
   virtual void pop(()) {}
   /*! @brief Gets the ActionMap binding for the specified command.

Use getField() on the return value to get the device and action of the binding.
@param command The function to search bindings for.
@return The binding against the specified command. Returns an empty string("") if a binding wasn't found.
@tsexample
// Find what the function "jump()" is bound to in moveMap
%bind = moveMap.getBinding( "jump" );

if ( %bind !$= "" )
{
// Find out what device is used in the binding
^%device = getField( %bind, 0 );

// Find out what action (such as a key) is used in the binding
^%action = getField( %bind, 1 );
}
@endtsexample

@see getField */
   virtual string getBinding(( string command )) {}
   /*! @brief Gets ActionMap command for the device and action.

@param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
@param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
@return The command against the specified device and action.
@tsexample
// Find what function is bound to a device's action
// In this example, "jump()" was assigned to the space key in another script
%command = moveMap.getCommand("keyboard", "space");

// Should print "jump" in the console
echo(%command)
@endtsexample

 */
   virtual string getCommand(( string device, string action )) {}
   /*! @brief Determines if the specified device and action is inverted.

Should only be used for scrolling devices or gamepad/joystick axes.@param device The device that was bound. Can be a keyboard, mouse, joystick or a gamepad.
@param action The device action that was bound.  The action is dependant upon the device. Specify a key for keyboards.
@return True if the specified device and action is inverted.
@tsexample
%if ( moveMap.isInverted( "mouse", "xaxis"))
   echo("Mouse's xAxis is inverted");@endtsexample

 */
   virtual bool isInverted(( string device, string action )) {}
   /*! @brief Get any scaling on the specified device and action.

@param device The device that was bound. Can be keyboard, mouse, joystick or gamepad.
@param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
@return Any scaling applied to the specified device and action.
@tsexample
%scale = %moveMap.getScale( "gamepad", "thumbrx");
@endtsexample

 */
   virtual float getScale(( string device, string action )) {}
   /*! @brief Gets the Dead zone for the specified device and action.

@param device The device that was bound.  Can be a keyboard, mouse, joystick or a gamepad.
@param action The device action that was bound. The action is dependant upon the device. Specify a key for keyboards.
@return The dead zone for the specified device and action. Returns "0 0" if there is no dead zone or an empty string("") if the mapping was not found.
@tsexample
%deadZone = moveMap.getDeadZone( "gamepad", "thumbrx");
@endtsexample

 */
   virtual string getDeadZone(( string device, string action )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  GlobalActionMap : public ActionMap {
  public:
};

/*!
@brief A debug helper for rendering debug primitives to the scene.

The DebugDrawer is used to render debug primitives to the scene for testing.  It is often useful when debugging collision code or complex 3d algorithms to have them draw debug information, like culling hulls or bounding volumes, normals, simple lines, and so forth.

A key feature of the DebugDrawer is that each primitive gets a "time to live" (TTL) which allows them to continue to render to the scene for a fixed period of time.  You can freeze or resume the system at any time to allow you to examine the output.
@tsexample
DebugDraw.drawLine( %player.getMuzzlePoint( 0 ), %hitPoint );
DebugDraw.setLastTTL( 5000 ); // 5 seconds.
@endtsexample
The DebugDrawer renders solely in world space and all primitives are rendered with the cull mode disabled.
@note This feature can easily be used to cheat in online games, so you should be sure it is disabled in your shipping game.  By default the DebugDrawer is disabled in all TORQUE_SHIPPING builds.
@ingroup GFX
 */
class  DebugDrawer : public SimObject {
  public:
   /*! Draws a line primitive between two 3d points. */
   virtual void drawLine(( Point3F a, Point3F b, ColorF color=ColorF::WHITE )) {}
   /*! Draws an axis aligned box primitive within the two 3d points. */
   virtual void drawBox(( Point3F a, Point3F b, ColorF color=ColorF::WHITE )) {}
   /*! Sets the "time to live" (TTL) for the last rendered primitive. */
   virtual void setLastTTL(( int ms )) {}
   /*! Sets the z buffer reading state for the last rendered primitive. */
   virtual void setLastZTest(( bool enabled )) {}
   /*! Toggles freeze mode which keeps the currently rendered primitives from expiring. */
   virtual void toggleFreeze(()) {}
   /*! Toggles the rendering of DebugDrawer primitives. */
   virtual void toggleDrawing(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  DebugDraw : public DebugDrawer {
  public:
};

/*!
@brief A collection of SimObjects.

It is often necessary to keep track of an arbitrary set of SimObjects. For instance, Torque's networking code needs to not only keep track of the set of objects which need to be ghosted, but also the set of objects which must <i>always</i> be ghosted. It does this by working with two sets. The first of these is the RootGroup (which is actually a SimGroup) and the second is the GhostAlwaysSet, which contains objects which must always be ghosted to the client.

Some general notes on SimSets:

- Membership is not exclusive. A SimObject may be a member of multiple SimSets.

- A SimSet does not destroy subobjects when it is destroyed.

- A SimSet may hold an arbitrary number of objects.

@ingroup Console
 */
class  SimSet : public SimObject {
  public:
      /*! Called when an object is added to the set.
@param object The object that was added. */
      void onObjectAdded( SimObject object );

      /*! Called when an object is removed from the set.
@param object The object that was removed. */
      void onObjectRemoved( SimObject object );

   /*! Dump a list of all objects contained in the set to the console. */
   virtual void listObjects(()) {}
   /*! Add the given objects to the set.
@param objects The objects to add to the set. */
   virtual void add(( SimObject objects... )) {}
   /*! Remove the given objects from the set.
@param objects The objects to remove from the set. */
   virtual void remove(( SimObject objects... )) {}
   /*! Remove all objects from the set. */
   virtual void clear(()) {}
   /*! Delete all objects in the set. */
   virtual void deleteAllObjects(()) {}
   /*! Return a random object from the set.
@return A randomly selected object from the set or -1 if the set is empty. */
   virtual string getRandom(()) {}
   /*! Call a method on all objects contained in the set.

@param method The name of the method to call.
@param args The arguments to the method.

@note This method recurses into all SimSets that are children to the set.

@see callOnChildrenNoRecurse */
   virtual void callOnChildren(( string method, string args... )) {}
   /*! Call a method on all objects contained in the set.

@param method The name of the method to call.
@param args The arguments to the method.

@note This method does not recurse into child SimSets.

@see callOnChildren */
   virtual void callOnChildrenNoRecurse(( string method, string args... )) {}
   /*! Make sure child1 is ordered right before child2 in the set.
@param child1 The first child.  The object must already be contained in the set.
@param child2 The second child.  The object must already be contained in the set. */
   virtual void reorderChild(( SimObject child1, SimObject child2 )) {}
   /*! Get the number of objects contained in the set.
@return The number of objects contained in the set. */
   virtual int getCount(()) {}
   /*! Get the number of direct and indirect child objects contained in the set.
@return The number of objects contained in the set as well as in other sets contained directly or indirectly in the set. */
   virtual int getFullCount(()) {}
   /*! Get the object at the given index.
@param index The object index.
@return The object at the given index or -1 if index is out of range. */
   virtual string getObject(( int index )) {}
   /*! Return the index of the given object in this set.
@param obj The object for which to return the index.  Must be contained in the set.
@return The index of the object or -1 if the object is not contained in the set. */
   virtual int getObjectIndex(( SimObject obj )) {}
   /*! Test whether the given object belongs to the set.
@param obj The object.
@return True if the object is contained in the set; false otherwise. */
   virtual bool isMember(( SimObject obj )) {}
   /*! Find an object in the set by its internal name.
@param internalName The internal name of the object to look for.
@param searchChildren If true, SimSets contained in the set will be recursively searched for the object.
@return The object with the given internal name or 0 if no match was found.
 */
   virtual string findObjectByInternalName(( string internalName, bool searchChildren=false )) {}
   /*! Make the given object the first object in the set.
@param obj The object to bring to the frontmost position.  Must be contained in the set. */
   virtual void bringToFront(( SimObject obj )) {}
   /*! Make the given object the last object in the set.
@param obj The object to bring to the last position.  Must be contained in the set. */
   virtual void pushToBack(( SimObject obj )) {}
   /*! Sort the objects in the set using the given comparison function.
@param callbackFunction Name of a function that takes two object arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal. */
   virtual void sort(( string callbackFunction )) {}
   /*! Test whether the given object may be added to the set.
@param obj The object to test for potential membership.
@return True if the object may be added to the set, false otherwise. */
   virtual bool acceptsAsChild(( SimObject obj )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A collection of SimObjects that are owned by the group.

A SimGroup is a stricter form of SimSet. SimObjects may only be a member of a single SimGroup at a time. The SimGroup will automatically enforce the single-group-membership rule (ie. adding an object to a SimGroup will cause it to be removed from its current SimGroup, if any).

Deleting a SimGroup will also delete all SimObjects in the SimGroup.

@tsexample
// Create a SimGroup for particle emitters
new SimGroup(Emitters)
{
   canSaveDynamicFields = "1";

   new ParticleEmitterNode(CrystalEmmiter) {
      active = "1";
      emitter = "dustEmitter";
      velocity = "1";
      dataBlock = "GenericSmokeEmitterNode";
      position = "-61.6276 2.1142 4.45027";
      rotation = "1 0 0 0";
      scale = "1 1 1";
      canSaveDynamicFields = "1";
   };

   new ParticleEmitterNode(Steam1) {
      active = "1";
      emitter = "SlowSteamEmitter";
      velocity = "1";
      dataBlock = "GenericSmokeEmitterNode";
      position = "-25.0458 1.55289 2.51308";
      rotation = "1 0 0 0";
      scale = "1 1 1";
      canSaveDynamicFields = "1";
   };
};

@endtsexample

@ingroup Console
 */
class  SimGroup : public SimSet {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  DataBlockGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  sgMissionLightingFilterSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  BehaviorSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXParameterGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  ClientConnectionGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  TCPGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  GuiDataGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  GuiGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  ClientGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  ActionMapGroup : public SimGroup {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  DataBlockSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  TerrainMaterialSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXAmbienceSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXStateSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXEnvironmentSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXTrackSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXDescriptionSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  SFXSourceSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  MaterialSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  fxFoliageSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  fxReplicatorSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  WayPointSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  GhostAlwaysSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  ActiveActionMapSet : public SimSet {
  public:
};

/// Stub class
/// 
/// @note This is a stub class to ensure a proper class hierarchy. No 
///       information was available for this class.
class  RootGroup : public SimGroup {
  public:
};

/*!
@brief Base class for all Gui control objects.

GuiControl is the basis for the Gui system.  It represents an individual control that can be placed on the canvas and with which the mouse and keyboard can potentially interact with.

@section GuiControl_Hierarchy Control Hierarchies
GuiControls are arranged in a hierarchy.  All children of a control are placed in their parent's coordinate space, i.e. their coordinates are relative to the upper left corner of their immediate parent.  When a control is moved, all its child controls are moved along with it.

Since GuiControl's are SimGroups, hierarchy also implies ownership.  This means that if a control is destroyed, all its children are destroyed along with it.  It also means that a given control can only be part of a single GuiControl hierarchy.  When adding a control to another control, it will automatically be reparented from another control it may have previously been parented to.

@section GuiControl_Layout Layout System
GuiControls have a two-dimensional position and are rectangular in shape.

@section GuiControl_Events Event System
@section GuiControl_Profiles Control Profiles
Common data accessed by GuiControls is stored in so-called "Control Profiles."  This includes font, color, and texture information. By pooling this data in shared objects, the appearance of any number of controls can be changed quickly and easily by modifying only the shared profile object.

If not explicitly assigned a profile, a control will by default look for a profile object that matches its class name.  This means that the class GuiMyCtrl, for example, will look for a profile called 'GuiMyProfile'.  If this profile cannot be found, the control will fall back to GuiDefaultProfile which must be defined in any case for the Gui system to work.

In addition to its primary profile, a control may be assigned a second profile called 'tooltipProfile' that will be used to render tooltip popups for the control.

@section GuiControl_Actions Triggered Actions
@section GuiControl_FirstResponders First Responders
At any time, a single control can be what is called the "first responder" on the GuiCanvas is placed on.  This control will be the first control to receive keyboard events not bound in the global ActionMap.  If the first responder choses to handle a particular keyboard event, 

@section GuiControl_Waking Waking and Sleeping
@section GuiControl_VisibleActive Visibility and Activeness
By default, a GuiControl is active which means that it

@see GuiCanvas
@see GuiControlProfile
@ingroup GuiCore
 */
class  GuiControl : public SimGroup {
  public:
      /*! Called when the control object is registered with the system after the control has been created. */
      void onAdd();

      /*! Called when the control object is removed from the system before it is deleted. */
      void onRemove();

      /*! Called when the control is woken up.
@ref GuiControl_Waking */
      void onWake();

      /*! Called when the control is put to sleep.
@ref GuiControl_Waking */
      void onSleep();

      /*! Called when the control gains first responder status on the GuiCanvas.
@see setFirstResponder
@see makeFirstResponder
@see isFirstResponder
@ref GuiControl_FirstResponders */
      void onGainFirstResponder();

      /*! Called when the control loses first responder status on the GuiCanvas.
@see setFirstResponder
@see makeFirstResponder
@see isFirstResponder
@ref GuiControl_FirstResponders */
      void onLoseFirstResponder();

      /*! Called when the control's associated action is triggered and no 'command' is defined for the control.
@ref GuiControl_Actions */
      void onAction();

      /*! Called when the control changes its visibility state, i.e. when going from visible to invisible or vice versa.
@param state The new visibility state.
@see isVisible
@see setVisible
@ref GuiControl_VisibleActive */
      void onVisible( bool state );

      /*! Called when the control changes its activeness state, i.e. when going from active to inactive or vice versa.
@param stat The new activeness state.
@see isActive
@see setActive
@ref GuiControl_VisibleActive */
      void onActive( bool state );

      /*! Called when the control is pushed as a dialog onto the canvas.
@see GuiCanvas::pushDialog */
      void onDialogPush();

      /*! Called when the control is removed as a dialog from the canvas.
@see GuiCanvas::popDialog */
      void onDialogPop();

      /*! Called when a drag&drop operation through GuiDragAndDropControl has entered the control.  This is only called for topmost visible controls as the GuiDragAndDropControl moves over them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas. */
      void onControlDragEnter( GuiControl control, Point2I dropPoint );

      /*! Called when a drag&drop operation through GuiDragAndDropControl has exited the control and moved over a different control.  This is only called for topmost visible controls as the GuiDragAndDropControl moves off of them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas. */
      void onControlDragExit( GuiControl control, Point2I dropPoint );

      /*! Called when a drag&drop operation through GuiDragAndDropControl is moving across the control after it has entered it.  This is only called for topmost visible controls as the GuiDragAndDropControl moves across them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas. */
      void onControlDragged( GuiControl control, Point2I dropPoint );

      /*! Called when a drag&drop operation through GuiDragAndDropControl has completed and is dropping its payload onto the control.  This is only called for topmost visible controls as the GuiDragAndDropControl drops its payload on them.

@param control The control that is being dropped onto this control.
@param dropPoint The point at which the control is being dropped.  Relative to the canvas. */
      void onControlDropped( GuiControl control, Point2I dropPoint );

   /*! Find the topmost child control located at the given coordinates.
@note Only children that are both visible and have the 'modal' flag set in their profile will be considered in the search.@param x The X coordinate in the control's own coordinate space.
@param y The Y coordinate in the control's own coordinate space.
@return The topmost child control at the given coordintes or the control on which the method was called if no matching child could be found.
@see GuiControlProfile::modal
@see findHitControls */
   virtual string findHitControl(( int x, int y )) {}
   /*! Find all visible child controls that intersect with the given rectangle.
@note Invisible child controls will not be included in the search.
@param x The X coordinate of the rectangle's upper left corner in the control's own coordinate space.
@param y The Y coordinate of the rectangle's upper left corner in the control's own coordinate space.
@param width The width of the search rectangle in pixels.
@param height The height of the search rectangle in pixels.
@return A space-separated list of the IDs of all visible control objects intersecting the given rectangle.

@tsexample
// Lock all controls in the rectangle at x=10 and y=10 and the extent width=100 and height=100.
foreach$( %ctrl in %this.findHitControls( 10, 10, 100, 100 ) )
   %ctrl.setLocked( true );
@endtsexample
@see findHitControl */
   virtual string findHitControls(( int x, int y, int width, int height )) {}
   /*! Test whether the given control is a direct or indirect child to this control.
@param control The potential child control.
@return True if the given control is a direct or indirect child to this control. */
   virtual bool controlIsChild(( GuiControl control )) {}
   /*! Test whether the control is the current first responder.
@return True if the control is the current first responder.
@see makeFirstResponder
@see setFirstResponder
@ref GuiControl_FirstResponders */
   virtual bool isFirstResponder(()) {}
   /*! Make this control the current first responder.
@note Only controls with a profile that has canKeyFocus enabled are able to become first responders.
@see GuiControlProfile::canKeyFocus
@see isFirstResponder
@ref GuiControl_FirstResponders */
   virtual void setFirstResponder(()) {}
   /*! Get the first responder set on this GuiControl tree.
@return The first responder set on the control's subtree.
@see isFirstResponder
@see makeFirstResponder
@see setFirstResponder
@ref GuiControl_FirstResponders */
   virtual string getFirstResponder(()) {}
   /*! Clear this control from being the first responder in its hierarchy chain.
@param ignored Ignored.  Supported for backwards-compatibility.
 */
   virtual void clearFirstResponder(( bool ignored=false )) {}
   /*! Test whether the given point lies within the rectangle of the control.
@param x X coordinate of the point in parent-relative coordinates.
@param y Y coordinate of the point in parent-relative coordinates.
@return True if the point is within the control, false if not.
@see getExtent
@see getPosition
 */
   virtual bool pointInControl(( int x, int y )) {}
   /*! Add the given control as a child to this control.
This is synonymous to calling SimGroup::addObject.
@param control The control to add as a child.
@note The control will retain its current position and size.
@see SimGroup::addObject
@ref GuiControl_Hierarchy
 */
   virtual void addGuiControl(( GuiControl control )) {}
   /*! Get the canvas on which the control is placed.
@return The canvas on which the control's hierarchy is currently placed or 0 if the control is not currently placed on a GuiCanvas.
@see GuiControl_Hierarchy
 */
   virtual string getRoot(()) {}
   /*! Get the immediate parent control of the control.
@return The immediate parent GuiControl or 0 if the control is not parented to a GuiControl.
 */
   virtual string getParent(()) {}
   /*! Indicates if the mouse is locked in this control.
@return True if the mouse is currently locked.
 */
   virtual bool isMouseLocked(()) {}
   /*! Set the value associated with the control.
@param value The new value for the control.
 */
   virtual void setValue(( string value )) {}
   virtual string getValue() {}
   virtual void makeFirstResponder((bool isFirst)) {}
   virtual bool isActive() {}
   virtual void setActive(( bool state=true )) {}
   /*! Test whether the control is currently set to be visible.
@return True if the control is currently set to be visible.@note This method does not tell anything about whether the control is actually visible to the user at the moment.

@ref GuiControl_VisibleActive */
   virtual bool isVisible(()) {}
   /*! Set whether the control is visible or not.
@param state The new visiblity flag state for the control.
@ref GuiControl_VisibleActive */
   virtual void setVisible(( bool state=true )) {}
   /*! Test whether the control is currently awake.
If a control is awake it means that it is part of the GuiControl hierarchy of a GuiCanvas.
@return True if the control is awake.@ref GuiControl_Waking */
   virtual bool isAwake(()) {}
   /*! Set the control profile for the control to use.
The profile used by a control determines a great part of its behavior and appearance.
@param profile The new profile the control should use.
@ref GuiControl_Profiles */
   virtual void setProfile(( GuiControlProfile profile )) {}
   /*! Resize and reposition the control using the give coordinates and dimensions.  Child controls will resize according to their layout behaviors.
@param x The new X coordinate of the control in its parent's coordinate space.
@param y The new Y coordinate of the control in its parent's coordinate space.
@param width The new width to which the control should be resized.
@param height The new height to which the control should be resized. */
   virtual void resize(( int x, int y, int width, int height )) {}
   /*! Get the control's current position relative to its parent.
@return The coordinate of the control in its parent's coordinate space. */
   virtual string getPosition(()) {}
   /*! Get the coordinate of the control's center point relative to its parent.
@return The coordinate of the control's center point in parent-relative coordinates. */
   virtual string getCenter(()) {}
   /*! Set the control's position by its center point.
@param x The X coordinate of the new center point of the control relative to the control's parent.
@param y The Y coordinate of the new center point of the control relative to the control's parent. */
   virtual void setCenter(( int x, int y )) {}
   /*! Get the coordinate of the control's center point in coordinates relative to the root control in its control hierarchy.
@Return the center coordinate of the control in root-relative coordinates.
 */
   virtual string getGlobalCenter(()) {}
   /*! Get the position of the control relative to the root of the GuiControl hierarchy it is contained in.
@return The control's current position in root-relative coordinates. */
   virtual string getGlobalPosition(()) {}
   /*! Set position of the control relative to the root of the GuiControl hierarchy it is contained in.
@param x The new X coordinate of the control relative to the root's upper left corner.
@param y The new Y coordinate of the control relative to the root's upper left corner. */
   virtual void setPositionGlobal(( int x, int y )) {}
   /*! Position the control in the local space of the parent control.
@param x The new X coordinate of the control relative to its parent's upper left corner.
@param y The new Y coordinate of the control relative to its parent's upper left corner. */
   virtual void setPosition(( int x, int y )) {}
   /*! Get the width and height of the control.
@return A point structure containing the width of the control in x and the height in y. */
   virtual string getExtent(()) {}
   /*! Set the width and height of the control.

@hide */
   virtual void setExtent(( Point2I p | int x, int y )) {}
   /*! Get the minimum allowed size of the control.
@return The minimum size to which the control can be shrunk.
@see minExtent */
   virtual string getMinExtent(()) {}
   /*! Get the aspect ratio of the control's extents.
@return The width of the control divided by its height.
@see getExtent */
   virtual float getAspect(()) {}

   /*! @name Layout
   @{ */
   /*! */
   /*!
   The position relative to the parent control.
   
    */
   Point2I position;
   /*!
   The width and height of the control.
   
    */
   Point2I extent;
   /*!
   The minimum width and height of the control. The control will not be resized smaller than this.
   
    */
   Point2I minExtent;
   /*!
   The horizontal resizing behavior.
   
    */
   GuiHorizontalSizing horizSizing;
   /*!
   The vertical resizing behavior.
   
    */
   GuiVerticalSizing vertSizing;
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /*!
   The control profile that determines fill styles, font settings, etc.
   
    */
   GuiControlProfile profile;
   /*!
   Whether the control is visible or hidden.
   
    */
   bool visible;
   /*!
   Whether the control is enabled for user interaction.
   
    */
   bool active;
   /*!
   @deprecated This member is deprecated, which means that its value is always undefined.
    */
   deprecated modal;
   /*!
   @deprecated This member is deprecated, which means that its value is always undefined.
    */
   deprecated setFirstResponder;
   /*!
   Name of the variable to which the value of this control will be synchronized.
   
    */
   string variable;
   /*!
   Command to execute on the primary action of the control.

@note Within this script snippet, the control on which the #command is being executed is bound to the global variable $ThisControl.
   
    */
   string command;
   /*!
   Command to execute on the secondary action of the control.

@note Within this script snippet, the control on which the #altCommand is being executed is bound to the global variable $ThisControl.
   
    */
   string altCommand;
   /*!
   Key combination that triggers the control's primary action when the control is on the canvas.
   
    */
   string accelerator;
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /*!
   Control profile to use when rendering tooltips for this control.
   
    */
   GuiControlProfile tooltipProfile;
   /*!
   String to show in tooltip for this control.
   
    */
   string tooltip;
   /*!
   Time for mouse to hover over control until tooltip is shown (in milliseconds).
   
    */
   int hovertime;
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /*!
   If true, the control may contain child controls.
   
    */
   bool isContainer;
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /*!
   Name of string table to use for lookup of internationalized text.
   
    */
   string langTableMod;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AwStatsGui : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  NetDecalRoadNetEvent {
  public:
};

class  NetDecalManagerNetEvent {
  public:
};

class  NetDecalManagerMsg {
  public:
};

class  NetForestBrush {
  public:
};

class  NetForestBrushElement {
  public:
};

class  NetFetchDataBlocks_Event {
  public:
};

class  NetFetchInspectorDataBlocks_Event {
  public:
};

class  NetInspectorEvent {
  public:
};

class  NetLock_Event {
  public:
};

class  NetRemoteRun {
  public:
};

class  NetSceneObjectNamer_Event {
  public:
};

class  NetSimGroupMove_Event {
  public:
};

class  NetSimObjEvent {
  public:
};

class  NetMeshRoadNetEvent {
  public:
};

class  NetFTPClient : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!

 */
class  NetFTPServer : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  RiverCreation_Event {
  public:
};

class  NetRiverNetEvent {
  public:
};

class  NetTerrainMatEvent {
  public:
};

class  NetTerrainModEvent {
  public:
};

class  NetTerrain_DataMsg {
  public:
};

/*!
@brief 
@ingroup 
@section Datablock_Networking Datablocks and Networking
@section Datablock_ClientSide Client-Side Datablocks
 */
class  SimDataBlock : public SimObject {
  public:
   /*! Reload the datablock.  This can only be used with a local client configuration. */
   virtual void reloadOnLocalClient(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Scriptable, demo-able datablock.  Used by GameBase objects.

@see GameBase
@ingroup gameObjects
 */
class  GameBaseData : public SimDataBlock {
  public:
      /*! @brief Called when the object is added to the scene.

@param obj the GameBase object

@tsexample
datablock GameBaseData(MyObjectData)
{
   category = "Misc";
};

function MyObjectData::onAdd( %this, %obj )
{
   echo( "Added " @ %obj.getName() @ " to the scene." );
}

function MyObjectData::onNewDataBlock( %this, %obj )
{
   echo( "Assign " @ %this.getName() @ " datablock to " %obj.getName() );
}

function MyObjectData::onRemove( %this, %obj )
{
   echo( "Removed " @ %obj.getName() @ " to the scene." );
}

function MyObjectData::onMount( %this, %obj, %mountObj, %node )
{
   echo( %obj.getName() @ " mounted to " @ %mountObj.getName() );
}

function MyObjectData::onUnmount( %this, %obj, %mountObj, %node )
{
   echo( %obj.getName() @ " unmounted from " @ %mountObj.getName() );
}

@endtsexample
 */
      void onAdd( GameBase obj );

      /*! @brief Called when the object has a new datablock assigned.

@param obj the GameBase object

@see onAdd for an example
 */
      void onNewDataBlock( GameBase obj );

      /*! @brief Called when the object is removed from the scene.

@param obj the GameBase object

@see onAdd for an example
 */
      void onRemove( GameBase obj );

      /*! @brief Called when the object is mounted to another object in the scene.

@param obj the GameBase object being mounted
@param mountObj the object we are mounted to
@param node the mountObj node we are mounted to

@see onAdd for an example
 */
      void onMount( GameBase obj, SceneObject mountObj, int node );

      /*! @brief Called when the object is unmounted from another object in the scene.

@param obj the GameBase object being unmounted
@param mountObj the object we are unmounted from
@param node the mountObj node we are unmounted from

@see onAdd for an example
 */
      void onUnmount( GameBase obj, SceneObject mountObj, int node );


   /*! @name Scripting
   @{ */
   /*! */
   /*!
   The group that this datablock will show up in under the "Scripted" tab in the World Editor Library.
   
    */
   caseString category;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  ParticleEmitterData : public GameBaseData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /*!
   Time (in milliseconds) between each particle ejection.
   
    */
   int ejectionPeriodMS;
   /*!
   Variance in ejection period, from 1 - ejectionPeriodMS.
   
    */
   int periodVarianceMS;
   /*!
   Particle ejection velocity.
   
    */
   float ejectionVelocity;
   /*!
   Variance for ejection velocity, from 0 - ejectionVelocity.
   
    */
   float velocityVariance;
   /*!
   Distance along ejection Z axis from which to eject particles.
   
    */
   float ejectionOffset;
   /*!
   For soft particles, the distance (in meters) where particles will be faded based on the difference in depth between the particle and the scene geometry.
   
    */
   float softnessDistance;
   /*!
   Used to generate the final particle color by controlling interpolation between the particle color and the particle color multiplied by the ambient light color.
   
    */
   float ambientFactor;
   /*!
   If false, particles emitted in the same frame have their positions adjusted. If true, adjustment is skipped and particles will clump together.
   
    */
   bool overrideAdvance;
   /*!
   If true, Particles will always face the camera.
   
    */
   bool orientParticles;
   /*!
   If true, particles will be oriented to face in the direction they are moving.
   
    */
   bool orientOnVelocity;
   /*!
   @brief List of space or TAB delimited ParticleData datablock names.

A random one of these datablocks is selected each time a particle is emitted.
   
    */
   string particles;
   /*!
   Lifetime of emitted particles (in milliseconds).
   
    */
   int lifetimeMS;
   /*!
   Variance in particle lifetime from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief If true, use emitter specified sizes instead of datablock sizes.
Useful for Debris particle emitters that control the particle size.
   
    */
   bool useEmitterSizes;
   /*!
   @brief If true, use emitter specified colors instead of datablock colors.

Useful for ShapeBase dust and WheeledVehicle wheel particle emitters that use the current material to control particle color.
   
    */
   bool useEmitterColors;
   /*!
   String value that controls how emitted particles blend with the scene.
   
    */
   ParticleBlendStyle blendStyle;
   /*!
   If true, particles are sorted furthest to nearest.
   
    */
   bool sortParticles;
   /*!
   @brief If true, reverses the normal draw order of particles.

Particles are normally drawn from newest to oldest, or in Z order (furthest first) if sortParticles is true. Setting this field to true will reverse that order: oldest first, or nearest first if sortParticles is true.
   
    */
   bool reverseOrder;
   /*!
   Optional texture to override ParticleData::textureName.
   
    */
   string textureName;
   /*!
   If true, particles always face along the axis defined by alignDirection.
   
    */
   bool alignParticles;
   /*!
   The direction aligned particles should face, only valid if alignParticles is true.
   
    */
   Point3F alignDirection;
   /*!
   This particle system should not use the mixed-resolution renderer. If your particle system has large amounts of overdraw, consider disabling this option.
   
    */
   bool highResOnly;
   /*!
   Controls whether particles are rendered onto reflective surfaces like water.
   
    */
   bool renderReflection;
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /*!
   Null
   
    */
   IParticleBehaviour ParticleBehaviour;
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /*!
   @brief How far the node must be from the camera before the emitter switches to the medium resolution texture.
   
    */
   float MediumResolutionDistance;
   /*!
   @brief How far the node must be from the camera before the emitter switches to the low resolution texture.
   
    */
   float LowResolutionDistance;
   /*!
   @brief How far the node must be from the camera before the emitter interpolates the ejectionPeriod towards LODEjectionPeriod.
   
    */
   float EjectionLODStartDistance;
   /*!
   @brief How far the node must be from the camera before the emitter stops interpolating the ejection period and stops emitting particles.
   
    */
   float EjectionLODEndDistance;
   /*!
   @brief What level the ejection period interpolates to based on distance.
   
    */
   int LODEjectionPeriod;
   /*!
   @brief How far the node must be from the camera before the emitter begins reducing the amount of update ticks per second it runs. 
   
    */
   int SimulationLODBegin;
   /*!
   @brief How far the node must be from the camera before the emitter stops updating the particles. 
   
    */
   int SimulationLODEnd;
   /// @}

   /*!
   @brief 
   
    */
   bool Standalone;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  CompositeEmitterData : public ParticleEmitterData {
  public:

   /*! @name CompositeEmitter
   @{ */
   /*! */
   /*!
   
   
    */
   ParticleEmitterData Emitter1;
   /*!
   
   
    */
   ParticleEmitterData Emitter2;
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Superclass for all ghostable networked objects.

@ingroup Networking
 */
class  NetObject : public SimObject {
  public:
   /*! @brief Cause the NetObject to be forced as scoped on the specified NetConnection.

@param client The connection this object will always be scoped to

@tsexample
// Called to create new cameras in TorqueScript
// %this - The active GameConnection
// %spawnPoint - The spawn point location where we creat the camera
function GameConnection::spawnCamera(%this, %spawnPoint)
{
^// If this connection's camera exists
^if(isObject(%this.camera))
^{
^^// Add it to the mission group to be cleaned up later
^^MissionCleanup.add( %this.camera );

^^// Force it to scope to the client side
^^%this.camera.scopeToClient(%this);
^}
}
@endtsexample

@see clearScopeToClient()
 */
   virtual void scopeToClient(( NetConnection client )) {}
   /*! @brief Undo the effects of a scopeToClient() call.

@param client The connection to remove this object's scoping from 

@see scopeToClient()
 */
   virtual void clearScopeToClient(( NetConnection client )) {}
   /*! @brief Always scope this object on all connections.

The object is marked as ScopeAlways and is immediately ghosted to all active connections.  This function has no effect if the object is not marked as Ghostable.

 */
   virtual void setScopeAlways(()) {}
   /*! @brief Get the ghost index of this object from the server.

@returns The ghost ID of this NetObject on the server
@tsexample
%ghostID = LocalClientConnection.getGhostId( %serverObject );
@endtsexample

 */
   virtual int getGhostID(()) {}
   /*! @brief Returns a pointer to the client object when on a local connection.

Short-Circuit-Networking: this is only valid for a local-client / singleplayer situation.

@returns the SimObject ID of the client object.
@tsexample
// Psuedo-code, some values left out for this example
%node = new ParticleEmitterNode(){};
%clientObject = %node.getClientObject();
if(isObject(%clientObject)
^%clientObject.setTransform("0 0 0");

@endtsexample

@see @ref local_connections */
   virtual int getClientObject(()) {}
   /*! @brief Returns a pointer to the client object when on a local connection.

Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.

@returns The SimObject ID of the server object.
@tsexample
// Psuedo-code, some values left out for this example
%node = new ParticleEmitterNode(){};
%serverObject = %node.getServerObject();
if(isObject(%serverObject)
^%serverObject.setTransform("0 0 0");

@endtsexample

@see @ref local_connections */
   virtual int getServerObject(()) {}
   /*! @brief Called to check if an object resides on the clientside.

@return True if the object resides on the client, false otherwise. */
   virtual bool isClientObject(()) {}
   /*! @brief Checks if an object resides on the server.

@return True if the object resides on the server, false otherwise. */
   virtual bool isServerObject(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A networkable object that exists in the 3D world.

The SceneObject class provides the foundation for 3D objects in the Engine.  It exposes the functionality for:

<ul><li>Position, rotation and scale within the world.</li><li>Working with a scene graph (in the Zone and Portal sections), allowing efficient and robust rendering of the game scene.</li><li>Various helper functions, including functions to get bounding information and momentum/velocity.</li><li>Mounting one SceneObject to another.</li><li>An interface for collision detection, as well as ray casting.</li><li>Lighting. SceneObjects can register lights both at lightmap generation time, and dynamic lights at runtime (for special effects, such as from flame or a projectile, or from an explosion).</li></ul>

You do not typically work with SceneObjects themselves.  The SceneObject provides a reference within the game world (the scene), but does not render to the client on its own.  The same is true of collision detection beyond that of the bounding box.  Instead you use one of the many classes that derrive from SceneObject, such as TSStatic.

@section SceneObject_Hiding Difference Between setHidden() and isRenderEnabled

When it comes time to decide if a SceneObject should render or not, there are two methods that can stop the SceneObject from rendering at all.  You need to be aware of the differences between these two methods as they impact how the SceneObject is networked from the server to the client.

The first method of manually controlling if a SceneObject is rendered is through its SceneObject::isRenderEnabled property.  When set to false the SceneObject is considered invisible but still present within the scene.  This means it still takes part in collisions and continues to be networked.

The second method is using the setHidden() method.  This will actually remove a SceneObject from the scene and it will no longer be networked from the server to the cleint.  Any client-side ghost of the object will be deleted as the server no longer considers the object to be in scope.

@ingroup gameObjects
 */
class  SceneObject : public NetObject {
  public:
   /*! Return the type mask for this object.
@return The numeric type mask for the object. */
   virtual int getType(()) {}
   /*! @brief Mount objB to this object at the desired slot with optional transform.

@param objB  Object to mount onto us
@param slot  Mount slot ID
@param txfm (optional) mount offset transform
@return true if successful, false if failed (objB is not valid) */
   virtual bool mountObject(( SceneObject objB, int slot, TransformF txfm=MatrixF::Identity )) {}
   /*! @brief Unmount an object from ourselves.

@param target object to unmount
@return true if successful, false if failed
 */
   virtual bool unmountObject(( SceneObject target )) {}
   /*! Unmount us from the currently mounted object if any.
 */
   virtual void unmount(()) {}
   /*! @brief Check if we are mounted to another object.

@return true if mounted to another object, false if not mounted. */
   virtual bool isMounted(()) {}
   /*! @brief Get the object we are mounted to.

@return the SimObjectID of the object we're mounted to, or 0 if not mounted. */
   virtual int getObjectMount(()) {}
   /*! Get the number of objects mounted to us.
@return the number of mounted objects. */
   virtual int getMountedObjectCount(()) {}
   /*! Get the object mounted at a particular slot.
@param slot mount slot index to query
@return ID of the object mounted in the slot, or 0 if no object. */
   virtual int getMountedObject(( int slot )) {}
   /*! @brief Get the mount node index of the object mounted at our given slot.

@param slot mount slot index to query
@return index of the mount node used by the object mounted in this slot. */
   virtual int getMountedObjectNode(( int slot )) {}
   /*! @brief Get the object mounted at our given node index.

@param node mount node index to query
@return ID of the first object mounted at the node, or 0 if none found. */
   virtual int getMountNodeObject(( int node )) {}
   /*! Get the object's transform.
@return the current transform of the object
 */
   virtual string getTransform(()) {}
   /*! Get the object's inverse transform.
@return the inverse transform of the object
 */
   virtual string getInverseTransform(()) {}
   /*! Get the object's world position.
@return the current world position of the object
 */
   virtual string getPosition(()) {}
   /*! Get Euler rotation of this object.
@return the orientation of the object in the form of rotations around the X, Y and Z axes in degrees.
 */
   virtual string getEulerRotation(()) {}
   /*! Get the direction this object is facing.
@return a vector indicating the direction this object is facing.
@note This is the object's y axis. */
   virtual string getForwardVector(()) {}
   /*! Get the right vector of the object.
@return a vector indicating the right direction of this object.@note This is the object's x axis. */
   virtual string getRightVector(()) {}
   /*! Get the up vector of the object.
@return a vector indicating the up direction of this object.@note This is the object's z axis. */
   virtual string getUpVector(()) {}
   /*! Set the object's transform (orientation and position).@param txfm object transform to set */
   virtual void setTransform(( TransformF txfm )) {}
   /*! Get the object's scale.
@return object scale as a Point3F */
   virtual string getScale(()) {}
   /*! Set the object's scale.
@param scale object scale to set
 */
   virtual void setScale(( Point3F scale )) {}
   /*! Get the object's world bounding box.
@return six fields, two Point3Fs, containing the min and max points of the worldbox. */
   virtual string getWorldBox(()) {}
   /*! Get the center of the object's world bounding box.
@return the center of the world bounding box for this object. */
   virtual string getWorldBoxCenter(()) {}
   /*! Get the object's bounding box (relative to the object's origin).
@return six fields, two Point3Fs, containing the min and max points of the objectbox. */
   virtual string getObjectBox(()) {}
   /*! Check if this object has a global bounds set.
If global bounds are set to be true, then the object is assumed to have an infinitely large bounding box for collision and rendering purposes.
@return true if the object has a global bounds. */
   virtual bool isGlobalBounds(()) {}
   /*! @brief Mount objB to this object at the desired node with fromNode on objB aligned to node and offset by txfm.

@param objB     Object to mount onto us.
@param toNode   (optional) Name of the node to mount to. If ommitted, objB will mount to our origin.
@param fromNode (optional) Name of the node on objB to align with toNode. If ommitted, the origin of objB will be used.
@param txfm     (optional) mount offset transform.
@return true if successful, false if failed (objB is not valid) */
   virtual bool mountObjectEx(( SceneObject objB, string toNode="", string fromNode="", TransformF txfm=MatrixF::Identity )) {}
   /*! @brief Get the first object mounted at the named node.

@param nodeName name of the node to query
@return ID of the first object mounted at the node, or 0 if none found. */
   virtual int getNodeObjectEx(( string nodeName="" )) {}
   /*! @brief Get the mount node index of the object mounted at our given slot.

@param slot mount slot index to query
@return index of the mount node used by the object mounted in this slot. */
   virtual string getMountedObjectNodeEx(( int slot=-1 )) {}

   /*! @name Transform
   @{ */
   /*! */
   /*!
   Object world position.
   
    */
   MatrixPosition position;
   /*!
   Object world orientation.
   
    */
   MatrixRotation rotation;
   /*!
   Object world scale.
   
    */
   Point3F scale;
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /*!
   Controls client-side rendering of the object.
@see isRenderable()

   
    */
   bool isRenderEnabled;
   /*!
   Determines if the object may be selected from wihin the Tools.
@see isSelectable()

   
    */
   bool isSelectionEnabled;
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /*!
   @brief PersistentID of object we are mounted to.

Unlike the SimObjectID that is determined at run time, the PersistentID of an object is saved with the level/mission and may be used to form a link between objects.
   
    */
   pid mountPID;
   /*!
   Node we are mounted to.
   
    */
   int mountNode;
   /*!
   Position we are mounted at ( object space of our mount object ).
   
    */
   MatrixPosition mountPos;
   /*!
   Rotation we are mounted at ( object space of our mount object ).
   
    */
   MatrixRotation mountRot;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for game objects which use datablocks, networking, are editable, and need to process ticks.

@ingroup gameObjects
 */
class  GameBase : public SceneObject {
  public:
   virtual bool ForceAnimation(( bool make=false, string name="", bool hold=false, bool fsp=true )) {}
      /*! @brief Called when the client controlling the object changes.

@param controlled true if a client now controls this object, false if no client controls this object.
 */
      void setControl( bool controlled );

   /*! @brief Get the datablock used by this object.

@return the datablock this GameBase is using.@see setDataBlock()
 */
   virtual int getDataBlock(()) {}
   /*! @brief Assign this GameBase to use the specified datablock.

@param data new datablock to use
@return true if successful, false if failed.@see getDataBlock()
 */
   virtual bool setDataBlock(( GameBaseData data )) {}
   /*! @brief Apply an impulse to this object as defined by a world position and velocity vector.

@param pos impulse world position
@param vel impulse velocity (impulse force F = m * v)
@return Always true
@note Not all objects that derrive from GameBase have this defined.
 */
   virtual bool applyImpulse(( Point3F pos, VectorF vel )) {}
   /*! @brief Applies a radial impulse to the object using the given origin and force.

@param origin World point of origin of the radial impulse.
@param radius The radius of the impulse area.
@param magnitude The strength of the impulse.
@note Not all objects that derrive from GameBase have this defined.
 */
   virtual void applyRadialImpulse(( Point3F origin, float radius, float magnitude )) {}

   /*! @name Game
   @{ */
   /*! */
   /*!
   Script datablock used for game objects.
   
    */
   GameBaseData dataBlock;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  CompositeEmitter : public GameBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  GraphEmitter : public GameBase {
  public:

   /*! @name Expression
   @{ */
   /*! */
   /*!
   The expression specifying the emitted particles X coordinate.
   
    */
   string xFunc;
   /*!
   The expression specifying the emitted particles Y coordinate.
   
    */
   string yFunc;
   /*!
   The expression specifying the emitted particles Z coordinate.
   
    */
   string zFunc;
   /*!
   TThe expressions interval, maximum.
   
    */
   int funcMax;
   /*!
   The expressions interval, minimum.
   
    */
   int funcMin;
   /*!
   The amount to scale the t value with.
   
    */
   float timeScale;
   /*!
   String value that controls how the t value is increased.
   
    */
   gProgressMode ProgressMode;
   /*!
   Reverse the graphEmitter.
   
    */
   bool Reverse;
   /*!
   Loop the graphEmitter.
   
    */
   bool Loop;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  GroundEmitter : public GameBase {
  public:

   /*! @name GroundEmitter
   @{ */
   /*! */
   /*!
   Terrain material name to limit coverage to, or blank to not limit.
   
    */
   string layers;
   /*!
   Radius of the circle from the ejection position to emit particles in.
   
    */
   float sa_Radius;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  MaskEmitter : public GameBase {
  public:
   /*!
   Minimum alpha value of the pixels in the mask to eject particles on.
   
    */
   char Alpha_min;
   /*!
   Maximum alpha value of the pixels in the mask to eject particles on.
   
    */
   char Alpha_max;
   /*!
   Emit particles along the terrain rather than at the nodes position.
   
    */
   char sa_Grounded;
   /*!
   Size of the inbound circle of the emission mask.
   
    */
   char sa_Radius;

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  SphereEmitter : public GameBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a MeshEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like MeshEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see MeshEmitterData
@see MeshEmitterNode
 */
class  MeshEmitter : public GameBase {
  public:

   /*! @name MeshEmitter
   @{ */
   /*! */
   /*!
   The object that the emitter will use to emit particles on.
   
    */
   string emitMesh;
   /*!
   If true, particle emission will be spread evenly along the whole model if false then there will be more particles where the geometry is more dense. Different effects for per vertex and per triangle emission - Read docs!.
   
    */
   bool evenEmission;
   /*!
   If true, particles will be emitted along the faces of the mesh. If false, particles will be emitted along the vertices of mesh. 
   
    */
   bool emitOnFaces;
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /*!
   If true, particle emission will be spread evenly along the whole model if false then there will be more particles where the geometry is more dense. Different effects for per vertex and per triangle emission - Read docs!.
   
    */
   bool enableDebugRender;
   /// @}


   /*! @name Particles
   @{ */
   /*! */
   /*!
   Time (in milliseconds) between each particle ejection.
   
    */
   int ejectionPeriodMS;
   /*!
   Variance in ejection period, from 1 - ejectionPeriodMS.
   
    */
   int periodVarianceMS;
   /*!
   Particle ejection velocity.
   
    */
   float ejectionVelocity;
   /*!
   Variance for ejection velocity, from 0 - ejectionVelocity.
   
    */
   float velocityVariance;
   /*!
   Distance along ejection Z axis from which to eject particles.
   
    */
   float ejectionOffset;
   /*!
   For soft particles, the distance (in meters) where particles will be faded based on the difference in depth between the particle and the scene geometry.
   
    */
   float softnessDistance;
   /*!
   Used to generate the final particle color by controlling interpolation between the particle color and the particle color multiplied by the ambient light color.
   
    */
   float ambientFactor;
   /*!
   If false, particles emitted in the same frame have their positions adjusted. If true, adjustment is skipped and particles will clump together.
   
    */
   bool overrideAdvance;
   /*!
   If true, Particles will always face the camera.
   
    */
   bool orientParticles;
   /*!
   If true, particles will be oriented to face in the direction they are moving.
   
    */
   bool orientOnVelocity;
   /*!
   Lifetime of emitted particles (in milliseconds).
   
    */
   int lifetimeMS;
   /*!
   Variance in particle lifetime from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief If true, use emitter specified sizes instead of datablock sizes.
Useful for Debris particle emitters that control the particle size.
   
    */
   bool useEmitterSizes;
   /*!
   @brief If true, use emitter specified colors instead of datablock colors.

Useful for ShapeBase dust and WheeledVehicle wheel particle emitters that use the current material to control particle color.
   
    */
   bool useEmitterColors;
   /*!
   String value that controls how emitted particles blend with the scene.
   
    */
   ParticleBlendStyle blendStyle;
   /*!
   If true, particles are sorted furthest to nearest.
   
    */
   bool sortParticles;
   /*!
   @brief If true, reverses the normal draw order of particles.

Particles are normally drawn from newest to oldest, or in Z order (furthest first) if sortParticles is true. Setting this field to true will reverse that order: oldest first, or nearest first if sortParticles is true.
   
    */
   bool reverseOrder;
   /*!
   Optional texture to override ParticleData::textureName.
   
    */
   string textureName;
   /*!
   If true, particles always face along the axis defined by alignDirection.
   
    */
   bool alignParticles;
   /*!
   The direction aligned particles should face, only valid if alignParticles is true.
   
    */
   Point3F alignDirection;
   /*!
   This particle system should not use the mixed-resolution renderer. If your particle system has large amounts of overdraw, consider disabling this option.
   
    */
   bool highResOnly;
   /*!
   Controls whether particles are rendered onto reflective surfaces like water.
   
    */
   bool renderReflection;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a MeshEmitter.

@tsexample
datablock MeshEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see MeshEmitter
@see ParticleData
@see MeshEmitterNode
 */
class  MeshEmitterData : public GameBaseData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name MeshEmitterData
   @{ */
   /*! */
   /*!
   Time (in milliseconds) between each particle ejection.
   
    */
   int ejectionPeriodMS;
   /*!
   Variance in ejection period, from 1 - ejectionPeriodMS.
   
    */
   int periodVarianceMS;
   /*!
   Particle ejection velocity.
   
    */
   float ejectionVelocity;
   /*!
   Variance for ejection velocity, from 0 - ejectionVelocity.
   
    */
   float velocityVariance;
   /*!
   Distance along ejection Z axis from which to eject particles.
   
    */
   float ejectionOffset;
   /*!
   For soft particles, the distance (in meters) where particles will be faded based on the difference in depth between the particle and the scene geometry.
   
    */
   float softnessDistance;
   /*!
   Used to generate the final particle color by controlling interpolation between the particle color and the particle color multiplied by the ambient light color.
   
    */
   float ambientFactor;
   /*!
   If false, particles emitted in the same frame have their positions adjusted. If true, adjustment is skipped and particles will clump together.
   
    */
   bool overrideAdvance;
   /*!
   If true, Particles will always face the camera.
   
    */
   bool orientParticles;
   /*!
   If true, particles will be oriented to face in the direction they are moving.
   
    */
   bool orientOnVelocity;
   /*!
   @brief List of space or TAB delimited ParticleData datablock names.

A random one of these datablocks is selected each time a particle is emitted.
   
    */
   string particles;
   /*!
   Lifetime of emitted particles (in milliseconds).
   
    */
   int lifetimeMS;
   /*!
   Variance in particle lifetime from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief If true, use emitter specified sizes instead of datablock sizes.
Useful for Debris particle emitters that control the particle size.
   
    */
   bool useEmitterSizes;
   /*!
   @brief If true, use emitter specified colors instead of datablock colors.

Useful for ShapeBase dust and WheeledVehicle wheel particle emitters that use the current material to control particle color.
   
    */
   bool useEmitterColors;
   /*!
   String value that controls how emitted particles blend with the scene.
   
    */
   ParticleBlendStyle blendStyle;
   /*!
   If true, particles are sorted furthest to nearest.
   
    */
   bool sortParticles;
   /*!
   @brief If true, reverses the normal draw order of particles.

Particles are normally drawn from newest to oldest, or in Z order (furthest first) if sortParticles is true. Setting this field to true will reverse that order: oldest first, or nearest first if sortParticles is true.
   
    */
   bool reverseOrder;
   /*!
   Optional texture to override ParticleData::textureName.
   
    */
   string textureName;
   /*!
   If true, particles always face along the axis defined by alignDirection.
   
    */
   bool alignParticles;
   /*!
   The direction aligned particles should face, only valid if alignParticles is true.
   
    */
   Point3F alignDirection;
   /*!
   This particle system should not use the mixed-resolution renderer. If your particle system has large amounts of overdraw, consider disabling this option.
   
    */
   bool highResOnly;
   /*!
   Controls whether particles are rendered onto reflective surfaces like water.
   
    */
   bool renderReflection;
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /*!
   Null
   
    */
   IParticleBehaviour ParticleBehaviour;
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /*!
   @brief How far the node must be from the camera before the emitter switches to the medium resolution texture.
   
    */
   float MediumResolutionDistance;
   /*!
   @brief How far the node must be from the camera before the emitter switches to the low resolution texture.
   
    */
   float LowResolutionDistance;
   /*!
   @brief How far the node must be from the camera before the emitter interpolates the ejectionPeriod towards LODEjectionPeriod.
   
    */
   float EjectionLODStartDistance;
   /*!
   @brief How far the node must be from the camera before the emitter stops interpolating the ejection period and stops emitting particles.
   
    */
   float EjectionLODEndDistance;
   /*!
   @brief What level the ejection period interpolates to based on distance.
   
    */
   int LODEjectionPeriod;
   /*!
   @brief What 
   
    */
   int SimulationLODBegin;
   /*!
   @brief What 
   
    */
   int SimulationLODEnd;
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  NodeMeshEmitterData : public MeshEmitterData {
  public:

   /*! @name MeshEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  NodeMeshEmitter : public MeshEmitter {
  public:

   /*! @name NodeMeshEmitter
   @{ */
   /*! */
   /*!
   
   
    */
   string NodeName;
   /// @}


   /*! @name MeshEmitter
   @{ */
   /*! */
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /// @}


   /*! @name Particles
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  RadiusMeshEmitterData : public MeshEmitterData {
  public:

   /*! @name MeshEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  RadiusMeshEmitter : public MeshEmitter {
  public:

   /*! @name RadiusMeshEmitter
   @{ */
   /*! */
   /*!
   The center of the spherical boundary that limits emission.
   
    */
   Point3F center;
   /*!
   The radius of the spherical boundary that limits emission.
   
    */
   float radius;
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /*!
   Render arrows from the center of the sphere to where the sphere intersects with an edge on the mesh.
   
    */
   bool renderIntersections;
   /*!
   Render the geometry inside the sphere.
   
    */
   bool renderEmittingFaces;
   /*!
   Render the sphere.
   
    */
   bool renderSphere;
   /*!
   Deprecated.
   
    */
   bool shadeByCoverage;
   /// @}


   /*! @name MeshEmitter
   @{ */
   /*! */
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /// @}


   /*! @name Particles
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  IParticleBehaviour : public SimDataBlock {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AttractionBehaviour : public IParticleBehaviour {
  public:
   /*!
   The ID or name of the object that the particles should interact with.
   
    */
   string attractedObjectID;
   /*!
   Offset from the objects position the particles should be attracted to or repulsed from.
   
    */
   string Attraction_offset;
   /*!
   String value that controls how the particles interact.
   
    */
   ParticleAttractionMode AttractionMode;
   /*!
   Amount of influence, combine with attraction range for the desired result.
   
    */
   float Amount;
   /*!
   Range of influence, any objects further away than this length will not attract or repulse the particles.
   
    */
   float attractionrange;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  CollisionBehaviour : public IParticleBehaviour {
  public:

   /*! @name CollisionBehaviour
   @{ */
   /*! */
   /*!
   The typemask to collide against.
   
    */
   int CollisionMask;
   /*!
   Amount of dampening to apply on each collision.A value of 100 brings the particles to a complete stop, a value of 0 does not apply any dampening.
   
    */
   float Dampening;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  StickyBehaviour : public IParticleBehaviour {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains the path to the .pEffect file and the lifeTime of a ParticleEffect.
 */
class  ParticleEffectData : public GameBaseData {
  public:

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name ParticleEffectData
   @{ */
   /*! */
   /*!
   The path to the .pEffect file that defines this ParticleEffect.
   
    */
   filename pEffect;
   /*!
   Lifetime of the ParticleEffect
   
    */
   int lifetimeMS;
   /// @}

};

class  PixelMask : public GameBaseData {
  public:
   /*!
   Path to the image that will be used as a mask.
   
    */
   filename MaskPath;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  Impact : public SimObject {
  public:
      /*!  */
      void doImpact( SimObjectId SourceID, SimObjectId TargetID );

   /*!
   
   
    */
   int sourceObject;
   /*!
   
   
    */
   string CallBack;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AOEImpact : public Impact {
  public:
   /*!
    */
   Point3F center;
   /*!
    */
   float radius;
   /*!
    */
   int TypeMask;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  BoxImpact : public Impact {
  public:
   /*!
    */
   Point3F Start;
   /*!
    */
   Point3F End;
   /*!
    */
   int TypeMask;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  ConeImpact : public Impact {
  public:
   /*!
    */
   Point3F Start;
   /*!
    */
   Point3F End;
   /*!
    */
   float radius;
   /*!
    */
   int TypeMask;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  CubeImpact : public Impact {
  public:
   /*!
    */
   Point3F center;
   /*!
    */
   float size;
   /*!
    */
   int TypeMask;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  DOTImpact : public Impact {
  public:
   /*!
    */
   int TickMS;
   /*!
    */
   int TickCount;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Stores properties for an individual projectile type.
@tsexample
datablock ProjectileData(GrenadeLauncherProjectile)
{
 projectileShapeName = "art/shapes/weapons/SwarmGun/rocket.dts";
directDamage = 30;
radiusDamage = 30;
damageRadius = 5;
areaImpulse = 2000;
explosion = GrenadeLauncherExplosion;
waterExplosion = GrenadeLauncherWaterExplosion;
decal = ScorchRXDecal;
splash = GrenadeSplash;
particleEmitter = GrenadeProjSmokeTrailEmitter;
particleWaterEmitter = GrenadeTrailWaterEmitter;
muzzleVelocity = 30;
velInheritFactor = 0.3;
armingDelay = 2000;
lifetime = 10000;
fadeDelay = 4500;
bounceElasticity = 0.4;
bounceFriction = 0.3;
isBallistic = true;
gravityMod = 0.9;
lightDesc = GrenadeLauncherLightDesc;
damageType = "GrenadeDamage";
};
@endtsexample
@ingroup gameObjects
 */
class  ProjectileData : public GameBaseData {
  public:
      /*! @brief Called when a projectile explodes.

This function is only called on server objects.
@param proj The exploding projectile.
@param pos The position of the explosion.
@param fade The current fadeValue of the projectile, affects its visibility.

@see Projectile
 */
      void onExplode( Projectile proj, Point3F pos, float fade );

      /*! @brief Called when a projectile collides with another object.

This function is only called on server objects.@param proj The projectile colliding with SceneObject col.
@param col The SceneObject hit by the projectile.
@param fade The current fadeValue of the projectile, affects its visibility.
@param pos The position of the collision.
@param normal The normal of the collision.
@see Projectile
 */
      void onCollision( Projectile proj, SceneObject col, float fade, Point3F pos, Point3F normal );

   /*!
   @brief Particle emitter datablock used to generate particles while the projectile is outside of water.

@note If datablocks are defined for both particleEmitter and particleWaterEmitter, both effects will play as the projectile enters or leaves water.

@see particleWaterEmitter

   
    */
   ParticleEmitterData particleEmitter;
   /*!
   @brief Particle emitter datablock used to generate particles while the projectile is submerged in water.

@note If datablocks are defined for both particleWaterEmitter and particleEmitter , both effects will play as the projectile enters or leaves water.

@see particleEmitter

   
    */
   ParticleEmitterData particleWaterEmitter;
   /*!
   @brief File path to the model of the projectile.


   
    */
   filename projectileShapeName;
   /*!
   @brief Scale to apply to the projectile's size.

@note This is applied after SceneObject::scale

   
    */
   Point3F scale;
   /*!
   @brief SFXTrack datablock used to play sounds while in flight.


   
    */
   SFXTrack sound;
   /*!
   @brief Explosion datablock used when the projectile explodes outside of water.


   
    */
   ExplosionData Explosion;
   /*!
   @brief Explosion datablock used when the projectile explodes underwater.


   
    */
   ExplosionData waterExplosion;
   /*!
   @brief Splash datablock used to create splash effects as the projectile enters or leaves water


   
    */
   SplashData Splash;
   /*!
   @brief Decal datablock used for decals placed at projectile explosion points.


   
    */
   DecalData decal;
   /*!
   @brief LightDescription datablock used for lights attached to the projectile.


   
    */
   LightDescription lightDesc;
   /*!
   @brief Detetmines if the projectile should be affected by gravity and whether or not it bounces before exploding.


   
    */
   bool isBallistic;
   /*!
   @brief Amount of velocity the projectile recieves from the source that created it.

Use an amount between 0 and 1 for the best effect. This value is never modified by the engine.
@note This value by default is not transmitted between the server and the client.
   
    */
   float velInheritFactor;
   /*!
   @brief Amount of velocity the projectile recieves from the "muzzle" of the gun.

Used with velInheritFactor to determine the initial velocity of the projectile. This value is never modified by the engine.

@note This value by default is not transmitted between the server and the client.

@see velInheritFactor
   
    */
   float muzzleVelocity;
   /*!
    */
   float impactForce;
   /*!
   @brief Amount of time, in milliseconds, before the projectile is removed from the simulation.

Used with fadeDelay to determine the transparency of the projectile at a given time. A projectile may exist up to a maximum of 131040ms (or 4095 ticks) as defined by Projectile::MaxLivingTicks in the source code.@see fadeDelay
   
    */
   int lifetime;
   /*!
   @brief Amount of time, in milliseconds, before the projectile will cause damage or explode on impact.

This value must be equal to or less than the projectile's lifetime.

@see lifetime
   
    */
   int armingDelay;
   /*!
   @brief Amount of time, in milliseconds, before the projectile begins to fade out.

This value must be smaller than the projectile's lifetime to have an affect.
   
    */
   int fadeDelay;
   /*!
   @brief Influences post-bounce velocity of a projectile that does not explode on contact.

Scales the velocity from a bounce after friction is taken into account. A value of 1.0 will leave it's velocity unchanged while values greater than 1.0 will increase it.

   
    */
   float bounceElasticity;
   /*!
   @brief Factor to reduce post-bounce velocity of a projectile that does not explode on contact.

Reduces bounce velocity by this factor and a multiple of the tangent to impact. Used to simulate surface friction.

   
    */
   float bounceFriction;
   /*!
   @brief Scales the influence of gravity on the projectile.

The larger this value is, the more that gravity will affect the projectile. A value of 1.0 will assume "normal" influence upon it.
The magnitude of gravity is assumed to be 9.81 m/s/s

@note ProjectileData::isBallistic must be true for this to have any affect.
   
    */
   float gravityMod;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  SpellProjectileData : public ProjectileData {
  public:

   /*! @name SpellProjectileData
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  BezierProjectileData : public SpellProjectileData {
  public:

   /*! @name BezierProjectileData
   @{ */
   /*! */
   /*!
   
   
    */
   Point3F BezierWeights;
   /// @}


   /*! @name SpellProjectileData
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base projectile class. Uses the ProjectileData class for properties of individual projectiles.
@ingroup gameObjects
 */
class  Projectile : public GameBase {
  public:
   /*! Get the object's last known transform.
@return the current transform of the object
 */
   virtual string getLastTransform(()) {}
   /*! @brief Updates the projectile's positional and collision information.

This function will first delete the projectile if it is a server object and is outside it's ProjectileData::lifetime. Also responsible for applying gravity, determining collisions, triggering explosions, emitting trail particles, and calculating bounces if necessary.@param seconds Amount of time, in seconds since the simulation's start, to advance.
@tsexample
// Tell the projectile to process a simulation event, and provide the amount of time
// that has passed since the simulation began.
%seconds = 2.0;
%projectile.presimulate(%seconds);
@endtsexample
@note This function is not called if the SimObject::hidden is true. */
   virtual void presimulate(( float seconds=1.0f )) {}

   /*! @name Physics
   @{ */
   /*! */
   /*!
   @brief Starting position for the projectile.


   
    */
   Point3F initialPosition;
   /*!
   @brief Starting velocity for the projectile.


   
    */
   Point3F initialVelocity;
   /// @}


   /*! @name Source
   @{ */
   /*! */
   /*!
   @brief ID number of the object that fired the projectile.

@note If the projectile was fired by a WeaponImage, sourceObject will be the object that owns the WeaponImage. This is usually the player.
   
    */
   int sourceObject;
   /*!
   @brief The sourceObject's weapon slot that the projectile originates from.


   
    */
   int sourceSlot;
   /*!
    */
   bool ignoreSourceTimeout;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  SpellProjectile : public Projectile {
  public:

   /*! @name SpellProjectile
   @{ */
   /*! */
   /*!
   
   
    */
   SceneObject TargetObject;
   /*!
   
   
    */
   bool OnlyCollideWithTarget;
   /*!
   
   
    */
   bool Homing;
   /*!
   
   
    */
   TransformF InitialTransform;
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Source
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  BezierProjectile : public SpellProjectile {
  public:
   /*!
   
   
    */
   Point3F TargetPosition;
   /*!
   
   
    */
   Point3F BezierWeights;

   /*! @name SpellProjectile
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Source
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  CooldownManager : public NetObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  SpellDecalManager : public NetObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  SpellDecalManagerData : public SimDataBlock {
  public:
   /*!
    */
   DecalData DecalData;
   /*!
   
   
    */
   PositionTypes PositionType;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  SpellDecalManagerFinishEvent {
  public:
};

class  SSNetEvent {
  public:
};

class  DecalIndicatorData : public SimDataBlock {
  public:
   /*!
    */
   DecalData DecalData;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  GuiCompassCtrl : public GuiControl {
  public:

   /*! @name Bitmaps
   @{ */
   /*! */
   /*!
   The bitmap file to use for the controls frame.
   
    */
   filename frameBitmap;
   /*!
   The bitmap file to use for the heading indicator.
   
    */
   filename headingBitmap;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This object is responsible for spawning particles.

@note This class is not normally instantiated directly - to place a simple particle emitting object in the scene, use a ParticleEmitterNode instead.

This class is the main interface for creating particles - though it is usually only accessed from within another object like ParticleEmitterNode or WheeledVehicle. If using this object class (via C++) directly, be aware that it does <b>not</b> track changes in source axis or velocity over the course of a single update, so emitParticles should be called at a fairly fine grain.  The emitter will potentially track the last particle to be created into the next call to this function in order to create a uniformly random time distribution of the particles.

If the object to which the emitter is attached is in motion, it should try to ensure that for call (n+1) to this function, start is equal to the end from call (n). This will ensure a uniform spatial distribution.

@ingroup FX
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  SpriteEmitter : public SphereEmitter {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The object that manages the hud and gui viewport curtains.

@see GuiCurtain
@ingroup GuiCurtain
@ingroup FX
 */
class  CurtainManager : public SceneObject {
  public:

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines properties for a ShapeBase object.

@see ShapeBase
@ingroup gameObjects
 */
class  ShapeBaseData : public GameBaseData {
  public:
      /*! @brief Called when the object damage state changes to Enabled.

@param obj The ShapeBase object
@param lastState The previous damage state
 */
      void onEnabled( ShapeBase obj, string lastState );

      /*! @brief Called when the object damage state changes to Disabled.

@param obj The ShapeBase object
@param lastState The previous damage state
 */
      void onDisabled( ShapeBase obj, string lastState );

      /*! @brief Called when the object damage state changes to Destroyed.

@param obj The ShapeBase object
@param lastState The previous damage state
 */
      void onDestroyed( ShapeBase obj, string lastState );

      /*! @brief Called when we collide with another object beyond some impact speed.

The Player class makes use of this callback when a collision speed is more than PlayerData::minImpactSpeed.
@param obj The ShapeBase object
@param collObj The object we collided with
@param vec Collision impact vector
@param len Length of the impact vector
 */
      void onImpact( ShapeBase obj, SceneObject  collObj, VectorF vec, float len );

      /*! @brief Called when we collide with another object.

@param obj The ShapeBase object
@param collObj The object we collided with
@param vec Collision impact vector
@param len Length of the impact vector
 */
      void onCollision( ShapeBase obj, SceneObject  collObj, VectorF vec, float len );

      /*! @brief Called when the object is damaged.

@param obj The ShapeBase object
@param obj The ShapeBase object
@param delta The amount of damage received.
@param silent Apply the damage silently. */
      void onDamage( ShapeBase obj, float delta, bool silent );

      /*! @brief Called when a move trigger input changes state.

@param obj The ShapeBase object
@param index Index of the trigger that changed
@param state New state of the trigger
 */
      void onTrigger( ShapeBase obj, int index, bool state );

      /*! @brief Called when a thread playing a non-cyclic sequence reaches the end of the sequence.

@param obj The ShapeBase object
@param slot Thread slot that finished playing
 */
      void onEndSequence( ShapeBase obj, int slot );

      /*! @brief Called when the object is forced to uncloak.

@param obj The ShapeBase object
@param reason String describing why the object was uncloaked
 */
      void onForceUncloak( ShapeBase obj, string reason );

   /*! @brief Check if there is the space at the given transform is free to spawn into.

The shape's bounding box volume is used to check for collisions at the given world transform.  Only interior and static objects are checked for collision.
@param txfm Deploy transform to check
@return True if the space is free, false if there is already something in the way.
@note This is a server side only check, and is not actually limited to spawning.
 */
   virtual bool checkDeployPos(( TransformF txfm )) {}
   /*! @brief Helper method to get a transform from a position and vector (suitable for use with setTransform).

@param pos Desired transform position
@param normal Vector of desired direction
@return The deploy transform
 */
   virtual string getDeployTransform(( Point3F pos, Point3F normal )) {}

   /*! @name Shadows
   @{ */
   /*! */
   /*!
   Enable shadows for this shape (currently unused, shadows are always enabled).
   
    */
   bool shadowEnable;
   /*!
   Size of the projected shadow texture (must be power of 2).
   
    */
   int shadowSize;
   /*!
   Maximum distance at which shadow is visible (currently unused).
   
    */
   float shadowMaxVisibleDistance;
   /*!
   Maximum height above ground to project shadow. If the object is higher than this no shadow will be rendered.
   
    */
   float shadowProjectionDistance;
   /*!
   Scalar applied to the radius of spot shadows (initial radius is based on the shape bounds but can be adjusted with this field).
   
    */
   float shadowSphereAdjust;
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /*!
   The DTS or DAE model to use for this object.
   
    */
   filename shapeFile;
   /*!
   The root directory where options and tint art is stored for this shape.
   
    */
   string optionPath;
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /*!
   %Explosion to generate when this shape is blown up.
   
    */
   ExplosionData Explosion;
   /*!
   %Explosion to generate when this shape is blown up underwater.
   
    */
   ExplosionData underwaterExplosion;
   /*!
   %Debris to generate when this shape is blown up.
   
    */
   DebrisData Debris;
   /*!
   Whether to render the shape when it is in the "Destroyed" damage state.
   
    */
   bool renderWhenDestroyed;
   /*!
   The DTS or DAE model to use for auto-generated breakups. @note may not be functional.
   
    */
   filename debrisShapeName;
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /*!
   Shape mass.
Used in simulation of moving objects.

   
    */
   float mass;
   /*!
   Drag factor.
Reduces velocity of moving objects.
   
    */
   float drag;
   /*!
   Shape density.
Used when computing buoyancy when in water.

   
    */
   float density;
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /*!
   Maximum energy level for this object.
   
    */
   float maxEnergy;
   /*!
   Maximum damage level for this object.
   
    */
   float maxDamage;
   /*!
   Damage level above which the object is disabled.
Currently unused.
   
    */
   float disabledLevel;
   /*!
   Damage level above which the object is destroyed.
When the damage level increases above this value, the object damage state is set to "Destroyed".
   
    */
   float destroyedLevel;
   /*!
   Rate at which damage is repaired in damage units/tick.
This value is subtracted from the damage level until it reaches 0.
   
    */
   float repairRate;
   /*!
   Flag controlling whether to manage our own energy level, or to use the energy level of the object we are mounted to.
   
    */
   bool inheritEnergyFromMount;
   /*!
   Invincible flag; when invincible, the object cannot be damaged or repaired.
   
    */
   bool isInvincible;
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /*!
   The maximum distance from the camera to the object.
Used when computing a custom camera transform for this object.

@see observeThroughObject
   
    */
   float cameraMaxDist;
   /*!
   The minimum distance from the camera to the object.
Used when computing a custom camera transform for this object.

@see observeThroughObject
   
    */
   float cameraMinDist;
   /*!
   The default camera vertical FOV in degrees.
   
    */
   float cameraDefaultFov;
   /*!
   The minimum camera vertical FOV allowed in degrees.
   
    */
   float cameraMinFov;
   /*!
   The maximum camera vertical FOV allowed in degrees.
   
    */
   float cameraMaxFov;
   /*!
   If the derrived class supports it, allow the camera to bank.
   
    */
   bool cameraCanBank;
   /*!
   Do mounted images bank along with the camera?
   
    */
   bool mountedImagesBank;
   /*!
   Flag controlling whether the view from this object is first person only.
   
    */
   bool firstPersonOnly;
   /*!
   Flag controlling whether the client uses this object's eye point to view from.
   
    */
   bool useEyePoint;
   /*!
   Observe this object through its camera transform and default fov.
If true, when this object is the camera it can provide a custom camera transform and FOV (instead of the default eye transform).
   
    */
   bool observeThroughObject;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   If true, verify that the CRC of the client's shape model matches the server's CRC for the shape model when loaded by the client.
   
    */
   bool computeCRC;
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /*!
   References a ReflectorDesc datablock that defines performance and quality properties for dynamic reflections.

   
    */
   string cubeReflectorDesc;
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A datablock that describes a camera.

@tsexample
datablock CameraData(Observer)
{
   mode = "Observer";
};
@endtsexample
@see Camera

@ref Datablock_Networking
@ingroup BaseCamera
@ingroup Datablocks
 */
class  CameraData : public ShapeBaseData {
  public:

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A renderable, collidable convex shape defined by a collection of surface planes.

%ConvexShape is intended to be used as a temporary asset for quickly blocking out a scene or filling in approximate shapes to be later replaced with final assets. This is most easily done by using the WorldEditor's Sketch Tool.

 */
class  ConvexShape : public SceneObject {
  public:

   /*! @name Rendering
   @{ */
   /*! */
   /*!
   Material used to render the ConvexShape surface.
   
    */
   string Material;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   Do not modify, for internal use.
   
    */
   string surface;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Stores properties for an individual debris type.

DebrisData defines the base properties for a Debris object.  Typically you'll want a Debris object to consist of a shape and possibly up to two particle emitters.  The DebrisData datablock provides the definition for these items, along with physical properties and how a Debris object will react to other game objects, such as water and terrain.
@tsexample
datablock DebrisData(GrenadeDebris)
{
   shapeFile = "art/shapes/weapons/ramrifle/debris.dts";
   emitters[0] = GrenadeDebrisFireEmitter;
   elasticity = 0.4;
   friction = 0.25;
   numBounces = 3;
   bounceVariance = 1;
   explodeOnMaxBounce = false;
   staticOnMaxBounce = false;
   snapOnMaxBounce = false;
   minSpinSpeed = 200;
   maxSpinSpeed = 600;
   lifetime = 4;
   lifetimeVariance = 1.5;
   velocity = 15;
   velocityVariance = 5;
   fade = true;
   useRadiusMass = true;
   baseRadius = 0.3;
   gravModifier = 1.0;
   terminalVelocity = 20;
   ignoreWater = false;
};
@endtsexample

@see Debris

@ingroup FX
 */
class  DebrisData : public GameBaseData {
  public:

   /*! @name Display
   @{ */
   /*! */
   /*!
   @brief Texture imagemap to use for this debris object.

Not used any more.

   
    */
   string texture;
   /*!
   @brief Object model to use for this debris object.

This shape is optional.  You could have Debris made up of only particles.

   
    */
   filename shapeFile;
   /// @}


   /*! @name Datablocks
   @{ */
   /*! */
   /*!
   @brief List of particle emitters to spawn along with this debris object.

These are optional.  You could have Debris made up of only a shape.

   
    */
   ParticleEmitterData emitters;
   /*!
   @brief ExplosionData to spawn along with this debris object.

This is optional as not all Debris explode.

   
    */
   ExplosionData Explosion;
   /// @}


   /*! @name Physical Properties
   @{ */
   /*! */
   /*!
   @brief A floating-point value specifying how 'bouncy' this object is.

Must be in the range of -10 to 10.

   
    */
   float elasticity;
   /*!
   @brief A floating-point value specifying how much velocity is lost to impact and sliding friction.

Must be in the range of -10 to 10.

   
    */
   float friction;
   /*!
   @brief How many times to allow this debris object to bounce until it either explodes, becomes static or snaps (defined in explodeOnMaxBounce, staticOnMaxBounce, snapOnMaxBounce).

Must be within the range of 0 to 10000.
@see bounceVariance

   
    */
   int numBounces;
   /*!
   @brief Allowed variance in the value of numBounces.

Must be less than numBounces.
@see numBounces

   
    */
   int bounceVariance;
   /*!
   @brief Minimum speed that this debris object will rotate.

Must be in the range of -10000 to 1000, and must be less than maxSpinSpeed.
@see maxSpinSpeed

   
    */
   float minSpinSpeed;
   /*!
   @brief Maximum speed that this debris object will rotate.

Must be in the range of -10000 to 10000.
@see minSpinSpeed

   
    */
   float maxSpinSpeed;
   /*!
   How much gravity affects debris.
   
    */
   float gravModifier;
   /*!
   Max velocity magnitude.
   
    */
   float terminalVelocity;
   /*!
   @brief Speed at which this debris object will move.

@see velocityVariance

   
    */
   float velocity;
   /*!
   @brief Allowed variance in the value of velocity

Must be less than velocity.
@see velocity

   
    */
   float velocityVariance;
   /*!
   @brief Amount of time until this debris object is destroyed.

Must be in the range of 0 to 1000.
@see lifetimeVariance
   
    */
   float lifetime;
   /*!
   @brief Allowed variance in the value of lifetime.

Must be less than lifetime.
@see lifetime

   
    */
   float lifetimeVariance;
   /*!
   @brief Use mass calculations based on radius.

Allows for the adjustment of elasticity and friction based on the Debris size.
@see baseRadius

   
    */
   bool useRadiusMass;
   /*!
   @brief Radius at which the standard elasticity and friction apply.

Only used when useRaduisMass is true.
@see useRadiusMass.

   
    */
   float baseRadius;
   /// @}


   /*! @name Behavior
   @{ */
   /*! */
   /*!
   @brief If true, this debris object will explode after it has bounced max times.

Be sure to provide an ExplosionData datablock for this to take effect.
@see explosion

   
    */
   bool explodeOnMaxBounce;
   /*!
   If true, this debris object becomes static after it has bounced max times.
   
    */
   bool staticOnMaxBounce;
   /*!
   If true, this debris object will snap into a resting position on the last bounce.
   
    */
   bool snapOnMaxBounce;
   /*!
   @brief If true, this debris object will fade out when destroyed.

This fade occurs over the last second of the Debris' lifetime.

   
    */
   bool fade;
   /*!
   If true, this debris object will not collide with water, acting as if the water is not there.
   
    */
   bool ignoreWater;
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief No known usage, possibly Legacy.

Not used at all, internal until deprecated

 */
class  GuiNoMouseCtrl : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Stores properties for an individual Item type.

Items represent an object in the world, usually one that the player will interact with.  One example is a health kit on the group that is automatically picked up when the player comes into contact with it.

ItemData provides the common properties for a set of Items.  These properties include a DTS or DAE model used to render the Item in the world, its physical properties for when the Item interacts with the world (such as being tossed by the player), and any lights that emit from the Item.

@tsexample
datablock ItemData(HealthKitSmall)
{
   category ="Health";
   className = "HealthPatch";
   shapeFile = "art/shapes/items/kit/healthkit.dts";
   gravityMod = "1.0";
   mass = 2;
   friction = 1;
   elasticity = 0.3;
   density = 2;
   drag = 0.5;
   maxVelocity = "10.0";
   emap = true;
   sticky = false;
   dynamicType = "0"
;   lightOnlyStatic = false;
   lightType = "NoLight";
   lightColor = "1.0 1.0 1.0 1.0";
   lightTime = 1000;
   lightRadius = 10.0;
   simpleServerCollision = true;   // Dynamic properties used by the scripts

   pickupName = "a small health kit";
   repairAmount = 50;
};
@endtsexample
@ingroup gameObjects
 */
class  ItemData : public ShapeBaseData {
  public:
   /*!
   A floating-point value specifying how much velocity is lost to impact and sliding friction.
   
    */
   float friction;
   /*!
   A floating-point value specifying how 'bouncy' this ItemData is.
   
    */
   float elasticity;
   /*!
   @brief If true, ItemData will 'stick' to any surface it collides with.

When an item does stick to a surface, the Item::onStickyCollision() callback is called.  The Item has methods to retrieve the world position and normal the Item is stuck to.
@note Valid objects to stick to must be of StaticShapeObjectType.

   
    */
   bool sticky;
   /*!
   Floating point value to multiply the existing gravity with, just for this ItemData.
   
    */
   float gravityMod;
   /*!
   Maximum velocity that this ItemData is able to move.
   
    */
   float maxVelocity;
   /*!
   Type of light to apply to this ItemData. Options are NoLight, ConstantLight, PulsingLight. Default is NoLight.
   
    */
   ItemLightType lightType;
   /*!
   @brief Color value to make this light. Example: "1.0,1.0,1.0"

@see lightType

   
    */
   ColorF lightColor;
   /*!
   @brief Time value for the light of this ItemData, used to control the pulse speed of the PulsingLight LightType.

@see lightType

   
    */
   int lightTime;
   /*!
   @brief Distance from the center point of this ItemData for the light to affect

@see lightType

   
    */
   float lightRadius;
   /*!
   @brief If true, this ItemData will only cast a light if the Item for this ItemData has a static value of true.

@see lightType

   
    */
   bool lightOnlyStatic;
   /*!
   @brief Determines if only simple server-side collision will be used (for pick ups).

If set to true then only simple, server-side collision detection will be used.  This is often the case if the item is used for a pick up object, such as ammo.  If set to false then a full collision volume will be used as defined by the shape.  The default is true.
@note Only applies when using a physics library.
@see TurretShape and ProximityMine for examples that should set this to false to allow them to be shot by projectiles.

   
    */
   bool simpleServerCollision;
   /*!
   @brief The database inventory ID assigned for this item.

   
    */
   int ItemID;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A datablock which defines and performs light animation, such as rotation, brightness fade, and colorization.

@tsexample
datablock LightAnimData( SubtlePulseLightAnim )
{
   brightnessA = 0.5;
   brightnessZ = 1;
   brightnessPeriod = 1;
   brightnessKeys = "aza";
   brightnessSmooth = true;
};
@endtsexample

@see LightBase

@see LightDescription

@ingroup FX
@ingroup Lighting
 */
class  LightAnimData : public SimDataBlock {
  public:

   /*! @name Offset
   
   The XYZ translation animation state relative to the light position.
   @{ */
   /*! */
   /*!
   The value of the A key in the keyframe sequence.
   
    */
   float offsetA;
   /*!
   The value of the Z key in the keyframe sequence.
   
    */
   float OffsetZ;
   /*!
   The animation time for keyframe sequence.
   
    */
   float offsetPeriod;
   /*!
   The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.
   
    */
   string offsetKeys;
   /*!
   If true the transition between keyframes will be smooth.
   
    */
   bool offsetSmooth;
   /// @}


   /*! @name Rotation
   
   The XYZ rotation animation state relative to the light orientation.
   @{ */
   /*! */
   /*!
   The value of the A key in the keyframe sequence.
   
    */
   float rotA;
   /*!
   The value of the Z key in the keyframe sequence.
   
    */
   float rotZ;
   /*!
   The animation time for keyframe sequence.
   
    */
   float rotPeriod;
   /*!
   The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.
   
    */
   string rotKeys;
   /*!
   If true the transition between keyframes will be smooth.
   
    */
   bool rotSmooth;
   /// @}


   /*! @name Color
   
   The RGB color animation state.
   @{ */
   /*! */
   /*!
   The value of the A key in the keyframe sequence.
   
    */
   float colorA;
   /*!
   The value of the Z key in the keyframe sequence.
   
    */
   float colorZ;
   /*!
   The animation time for keyframe sequence.
   
    */
   float colorPeriod;
   /*!
   The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.
   
    */
   string colorKeys;
   /*!
   If true the transition between keyframes will be smooth.
   
    */
   bool colorSmooth;
   /// @}


   /*! @name Brightness
   
   The brightness animation state.
   @{ */
   /*! */
   /*!
   The value of the A key in the keyframe sequence.
   
    */
   float brightnessA;
   /*!
   The value of the Z key in the keyframe sequence.
   
    */
   float brightnessZ;
   /*!
   The animation time for keyframe sequence.
   
    */
   float brightnessPeriod;
   /*!
   The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.
   
    */
   string brightnessKeys;
   /*!
   If true the transition between keyframes will be smooth.
   
    */
   bool brightnessSmooth;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A very basic class containing information used by MissionMarker objects for rendering

MissionMarkerData, is an extremely barebones class derived from ShapeBaseData. It is solely used by MissionMarker classes (such as SpawnSphere), so that you can see the object while editing a level.

@tsexample
datablock MissionMarkerData(SpawnSphereMarker)
{
   category = "Misc";
   shapeFile = "core/art/shapes/octahedron.dts";
};
@endtsexample

@see MissionMarker

@see SpawnSphere

@see WayPoint

@ingroup enviroMisc
 */
class  MissionMarkerData : public ShapeBaseData {
  public:

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@ingroup gameObjects
 */
class  ShapeBase : public GameBase {
  public:
   virtual void applyHeal(( float amount )) {}
      /*! @brief Called on the server when the client has requested a FOV change.

When the client requests that its field of view should be changed (because they want to use a sniper scope, for example) this new FOV needs to be validated by the server.  This method is called if it exists (it is optional) to validate the requested FOV, and modify it if necessary.  This could be as simple as checking that the FOV falls within a correct range, to making sure that the FOV matches the capabilities of the current weapon.

Following this method, ShapeBase ensures that the given FOV still falls within the datablock's cameraMinFov and cameraMaxFov.  If that is good enough for your purposes, then you do not need to define the validateCameraFov() callback for your ShapeBase.

@param fov The FOV that has been requested by the client.
@return The FOV as validated by the server.

@see ShapeBaseData

 */
      float validateCameraFov( float fov );

   /*! @brief Add or remove this object from the scene.

When removed from the scene, the object will not be processed or rendered.
@param show False to hide the object, true to re-show it

 */
   virtual void setHidden(( bool show )) {}
   /*! Check if the object is hidden.
@return true if the object is hidden, false if visible.

 */
   virtual bool isHidden(()) {}
   /*! @brief Attach a sound to this shape and start playing it.

@param slot Audio slot index for the sound (valid range is 0 - 3)
@param track SFXTrack to play
@return true if the sound was attached successfully, false if failed

@see stopAudio()
 */
   virtual bool playAudio(( int slot, SFXTrack track )) {}
   /*! @brief Stop a sound started with playAudio.

@param slot audio slot index (started with playAudio)
@return true if the sound was stopped successfully, false if failed

@see playAudio()
 */
   virtual bool stopAudio(( int slot )) {}
   /*! @brief Start a new animation thread, or restart one that has been paused or stopped.

@param slot thread slot to play. Valid range is 0 - 3)
@param name name of the animation sequence to play in this slot. If not specified, the paused or stopped thread in this slot will be resumed.
@return true if successful, false if failed

@tsexample
%obj.playThread( 0, "ambient" );      // Play the ambient sequence in slot 0
%obj.setThreadTimeScale( 0, 0.5 );    // Play at half-speed
%obj.pauseThread( 0 );                // Pause the sequence
%obj.playThread( 0 );                 // Resume playback
%obj.playThread( 0, "spin" );         // Replace the sequence in slot 0
@endtsexample
@see pauseThread()
@see stopThread()
@see setThreadDir()
@see setThreadTimeScale()
@see destroyThread()
 */
   virtual bool playThread(( int slot, string name="" )) {}
   /*! @brief Set the playback direction of an animation thread.

@param slot thread slot to modify
@param fwd true to play the animation forwards, false to play backwards
@return true if successful, false if failed

@see playThread()
 */
   virtual bool setThreadDir(( int slot, bool fwd )) {}
   /*! @brief Set the playback time scale of an animation thread.

@param slot thread slot to modify
@param scale new thread time scale (1=normal speed, 0.5=half speed etc)
@return true if successful, false if failed

@see playThread
 */
   virtual bool setThreadTimeScale(( int slot, float scale )) {}
   /*! @brief Set the position within an animation thread.

@param slot thread slot to modify
@param pos position within thread
@return true if successful, false if failed

@see playThread
 */
   virtual bool setThreadPosition(( int slot, float pos )) {}
   /*! @brief Stop an animation thread.

If restarted using playThread, the animation will start from the beginning again.
@param slot thread slot to stop
@return true if successful, false if failed

@see playThread
 */
   virtual bool stopThread(( int slot )) {}
   /*! @brief Destroy an animation thread, which prevents it from playing.

@param slot thread slot to destroy
@return true if successful, false if failed

@see playThread
 */
   virtual bool destroyThread(( int slot )) {}
   /*! @brief Pause an animation thread.

If restarted using playThread, the animation will resume from the paused position.
@param slot thread slot to stop
@return true if successful, false if failed

@see playThread
 */
   virtual bool pauseThread(( int slot )) {}
   /*! @brief Mount a new Image.

@param image the Image to mount
@param slot Image slot to mount into (valid range is 0 - 3)
@param loaded initial loaded state for the Image
@param skinTag tagged string to reskin the mounted Image
@return true if successful, false if failed

@tsexample
%player.mountImage( PistolImage, 1 );
%player.mountImage( CrossbowImage, 0, false );
%player.mountImage( RocketLauncherImage, 0, true, 'blue' );
@endtsexample
@see unmountImage()
@see getMountedImage()
@see getPendingImage()
@see isImageMounted()
 */
   virtual bool mountImage(( ShapeBaseImageData image, int slot, bool loaded=true, string skinTag="" )) {}
   /*! @brief Unmount the mounted Image in the specified slot.

@param slot Image slot to unmount
@return true if successful, false if failed

@see mountImage()
 */
   virtual bool unmountImage(( int slot )) {}
   /*! @brief Get the Image mounted in the specified slot.

@param slot Image slot to query
@return ID of the ShapeBaseImageData datablock mounted in the slot, or 0 if no Image is mounted there.

 */
   virtual int getMountedImage(( int slot )) {}
   /*! @brief Get the Image that will be mounted next in the specified slot.

Calling mountImage when an Image is already mounted does one of two things: <ol><li>Mount the new Image immediately, the old Image is discarded and whatever state it was in is ignored.</li><li>If the current Image state does not allow Image changes, the new Image is marked as pending, and will not be mounted until the current state completes. eg. if the user changes weapons, you may wish to ensure that the current weapon firing state plays to completion first.</li></ol>
This command retrieves the ID of the pending Image (2nd case above).
@param slot Image slot to query
@return ID of the pending ShapeBaseImageData datablock, or 0 if none.

 */
   virtual int getPendingImage(( int slot )) {}
   /*! @brief Check if the current Image state is firing.

@param slot Image slot to query
@return true if the current Image state in this slot has the 'stateFire' flag set.
 */
   virtual bool isImageFiring(( int slot )) {}
   /*! @brief Check if the given datablock is mounted to any slot on this object.

@param image ShapeBaseImageData datablock to query
@return true if the Image is mounted to any slot, false otherwise.

 */
   virtual bool isImageMounted(( ShapeBaseImageData image )) {}
   /*! @brief Get the first slot the given datablock is mounted to on this object.

@param image ShapeBaseImageData datablock to query
@return index of the first slot the Image is mounted in, or -1 if the Image is not mounted in any slot on this object.

 */
   virtual int getMountSlot(( ShapeBaseImageData image )) {}
   /*! @brief Get the skin tag ID for the Image mounted in the specified slot.

@param slot Image slot to query
@return the skinTag value passed to mountImage when the image was mounted

 */
   virtual int getImageSkinTag(( int slot )) {}
   /*! @brief Get the name of the current state of the Image in the specified slot.

@param slot Image slot to query
@return name of the current Image state, or "Error" if slot is invalid

 */
   virtual string getImageState(( int slot )) {}
   /*! @brief Check if the given state exists on the mounted Image.

@param slot Image slot to query
@param state Image state to check for
@return true if the Image has the requested state defined.

 */
   virtual bool hasImageState(( int slot, string state )) {}
   /*! @brief Get the trigger state of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current trigger state

 */
   virtual bool getImageTrigger(( int slot )) {}
   /*! @brief Set the trigger state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param state new trigger state for the Image
@return the Image's new trigger state

 */
   virtual bool setImageTrigger(( int slot, bool state )) {}
   /*! @brief Get the generic trigger state of the Image mounted in the specified slot.

@param slot Image slot to query
@param trigger Generic trigger number
@return the Image's current generic trigger state

 */
   virtual bool getImageGenericTrigger(( int slot, int trigger )) {}
   /*! @brief Set the generic trigger state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param trigger Generic trigger number
@param state new generic trigger state for the Image
@return the Image's new generic trigger state or -1 if there was a problem.

 */
   virtual int setImageGenericTrigger(( int slot, int trigger, bool state )) {}
   /*! @brief Get the alt trigger state of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current alt trigger state

 */
   virtual bool getImageAltTrigger(( int slot )) {}
   /*! @brief Set the alt trigger state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param state new alt trigger state for the Image
@return the Image's new alt trigger state

 */
   virtual bool setImageAltTrigger(( int slot, bool state )) {}
   /*! @brief Get the ammo state of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current ammo state

 */
   virtual bool getImageAmmo(( int slot )) {}
   /*! @brief Set the ammo state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param state new ammo state for the Image
@return the Image's new ammo state

 */
   virtual bool setImageAmmo(( int slot, bool state )) {}
   /*! @brief Get the loaded state of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current loaded state

 */
   virtual bool getImageLoaded(( int slot )) {}
   /*! @brief Set the loaded state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param state new loaded state for the Image
@return the Image's new loaded state

 */
   virtual bool setImageLoaded(( int slot, bool state )) {}
   /*! @brief Get the target state of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current target state

 */
   virtual bool getImageTarget(( int slot )) {}
   /*! @brief Set the target state of the Image mounted in the specified slot.

@param slot Image slot to modify
@param state new target state for the Image
@return the Image's new target state

 */
   virtual bool setImageTarget(( int slot, bool state )) {}
   /*! @brief Get the script animation prefix of the Image mounted in the specified slot.

@param slot Image slot to query
@return the Image's current script animation prefix

 */
   virtual string getImageScriptAnimPrefix(( int slot )) {}
   /*! @brief Set the script animation prefix for the Image mounted in the specified slot.

This is used to further modify the prefix used when deciding which animation sequence to play while this image is mounted.
@param slot Image slot to modify
@param prefix The prefix applied to the image
 */
   virtual void setImageScriptAnimPrefix(( int slot, string prefix )) {}
   /*! @brief Get the muzzle vector of the Image mounted in the specified slot.

If the Image shape contains a node called 'muzzlePoint', then the muzzle vector is the forward direction vector of that node's transform in world space. If no such node is specified, the slot's mount node is used instead.

If the correctMuzzleVector flag (correctMuzzleVectorTP in 3rd person) is set in the Image, the muzzle vector is computed to point at whatever object is right in front of the object's 'eye' node.
@param slot Image slot to query
@return the muzzle vector, or "0 1 0" if the slot is invalid

 */
   virtual string getMuzzleVector(( int slot )) {}
   /*! @brief Get the muzzle position of the Image mounted in the specified slot.

If the Image shape contains a node called 'muzzlePoint', then the muzzle position is the position of that node in world space. If no such node is specified, the slot's mount node is used instead.
@param slot Image slot to query
@return the muzzle position, or "0 0 0" if the slot is invalid

 */
   virtual string getMuzzlePoint(( int slot )) {}
   /*! @brief Get the world transform of the specified mount slot.

@param slot Image slot to query
@return the mount transform

 */
   virtual string getSlotTransform(( int slot )) {}
   /*! @brief Get the position at which the AI should stand to repair things.

If the shape defines a node called "AIRepairNode", this method will return the current world position of that node, otherwise "0 0 0".
@return the AI repair position

 */
   virtual string getAIRepairPoint(()) {}
   /*! @brief Get the object's current velocity.

@return the current velocity

 */
   virtual string getVelocity(()) {}
   /*! @brief Set the object's velocity.

@param vel new velocity for the object
@return true

 */
   virtual bool setVelocity(( Point3F vel )) {}
   /*! @brief Apply an impulse to the object.

@param pos world position of the impulse
@param vec impulse momentum (velocity * mass)
@return true

 */
   virtual bool applyImpulse(( Point3F pos, Point3F vec )) {}
   /*! @brief Get the forward direction of the 'eye' for this object.

If the object model has a node called 'eye', this method will return that node's current forward direction vector, otherwise it will return the object's current forward direction vector.
@return the eye vector for this object
@see getEyePoint
@see getEyeTransform
 */
   virtual string getEyeVector(()) {}
   /*! @brief Get the forward direction for this object.

@return the forward vector for this object
@see getEyePoint
@see getEyeTransform
 */
   virtual string getForwardVector(()) {}
   /*! @brief Get the position of the 'eye' for this object.

If the object model has a node called 'eye', this method will return that node's current world position, otherwise it will return the object's current world position.
@return the eye position for this object
@see getEyeVector
@see getEyeTransform
 */
   virtual string getEyePoint(()) {}
   /*! @brief Get the 'eye' transform for this object.

If the object model has a node called 'eye', this method will return that node's current transform, otherwise it will return the object's current transform.
@return the eye transform for this object
@see getEyeVector
@see getEyePoint
 */
   virtual string getEyeTransform(()) {}
   /*! @brief Get the world position this object is looking at.

Casts a ray from the eye and returns information about what the ray hits.
@param distance maximum distance of the raycast
@param typeMask typeMask of objects to include for raycast collision testing
@return look-at information as "Object HitX HitY HitZ [Material]" or empty string for no hit

@tsexample
%lookat = %obj.getLookAtPoint();
echo( "Looking at: " @ getWords( %lookat, 1, 3 ) );
@endtsexample
 */
   virtual string getLookAtPoint(( float distance=2000, int typeMask=0xFFFFFFFF )) {}
   /*! @brief Set this object's current energy level.

@param level new energy level
@see getEnergyLevel()
@see getEnergyPercent()
 */
   virtual void setEnergyLevel(( float level )) {}
   /*! @brief Get the object's current energy level.

@return energy level
@see setEnergyLevel()
 */
   virtual float getEnergyLevel(()) {}
   /*! @brief Get the object's current energy level as a percentage of maxEnergy.

@return energyLevel / datablock.maxEnergy
@see setEnergyLevel()
 */
   virtual float getEnergyPercent(()) {}
   /*! @brief Set the object's current damage level.

@param level new damage level
@see getDamageLevel()
@see getDamagePercent()
 */
   virtual void setDamageLevel(( float level, bool doSilent=false )) {}
   /*! @brief Get the object's current damage level.

@return damage level
@see setDamageLevel()
 */
   virtual float getDamageLevel(()) {}
   /*! @brief Get the object's current damage level as a percentage of maxDamage.

@return damageLevel / datablock.maxDamage
@see setDamageLevel()
 */
   virtual float getDamagePercent(()) {}
   /*! Get the object's maxDamage level.
@return datablock.maxDamage
 */
   virtual float getMaxDamage(()) {}
   /*! @brief Set the object's damage state.

@param state should be one of "Enabled", "Disabled", "Destroyed"
@return true if successful, false if failed
@see getDamageState()
 */
   virtual bool setDamageState(( string state )) {}
   /*! @brief Get the object's damage state.

@return the damage state; one of "Enabled", "Disabled", "Destroyed"
@see setDamageState()
 */
   virtual string getDamageState(()) {}
   /*! @brief Check if the object is in the Destroyed damage state.

@return true if damage state is "Destroyed", false if not
@see isDisabled()
@see isEnabled()
 */
   virtual bool isDestroyed(()) {}
   /*! @brief Check if the object is in the Disabled or Destroyed damage state.

@return true if damage state is not "Enabled", false if it is
@see isDestroyed()
@see isEnabled()
 */
   virtual bool isDisabled(()) {}
   /*! @brief Check if the object is in the Enabled damage state.

@return true if damage state is "Enabled", false if not
@see isDestroyed()
@see isDisabled()
 */
   virtual bool isEnabled(()) {}
   /*! @brief Explodes an object into pieces. */
   virtual void blowUp(()) {}
   /*! @brief Increment the current damage level by the specified amount.

@param amount value to add to current damage level
 */
   virtual void applyDamage(( float amount )) {}
   /*! @brief Repair damage by the specified amount.

Note that the damage level is only reduced by repairRate per tick, so it may take several ticks for the total repair to complete.
@param amount total repair value (subtracted from damage level over time)
 */
   virtual void applyRepair(( float amount )) {}
   /*! @brief Set amount to repair damage by each tick.

Note that this value is separate to the repairRate field in ShapeBaseData. This value will be subtracted from the damage level each tick, whereas the ShapeBaseData field limits how much of the applyRepair value is subtracted each tick. Both repair types can be active at the same time.
@param rate value to subtract from damage level each tick (must be > 0)
@see getRepairRate()
 */
   virtual void setRepairRate(( float rate )) {}
   /*! @brief Get the per-tick repair amount.

@return the current value to be subtracted from damage level each tick
@see setRepairRate
 */
   virtual float getRepairRate(()) {}
   /*! @brief Set the recharge rate.

The recharge rate is added to the object's current energy level each tick, up to the maxEnergy level set in the ShapeBaseData datablock.
@param rate the recharge rate (per tick)
@see getRechargeRate()
 */
   virtual void setRechargeRate(( float rate )) {}
   /*! @brief Get the current recharge rate.

@return the recharge rate (per tick)
@see setRechargeRate()
 */
   virtual float getRechargeRate(()) {}
   /*! @brief Get the client (if any) that controls this object.

The controlling client is the one that will send moves to us to act on.
@return the ID of the controlling GameConnection, or 0 if this object is not controlled by any client.
@see GameConnection
 */
   virtual int getControllingClient(()) {}
   /*! @brief Get the object (if any) that controls this object.

@return the ID of the controlling ShapeBase object, or 0 if this object is not controlled by another object.
 */
   virtual int getControllingObject(()) {}
   /*! @brief Check if this object can cloak.

@return true
@note Not implemented as it always returns true. */
   virtual bool canCloak(()) {}
   /*! @brief Set the cloaked state of this object.

When an object is cloaked it is not rendered.
@param cloak true to cloak the object, false to uncloak
@see isCloaked()
 */
   virtual void setCloaked(( bool cloak )) {}
   /*! @brief Check if this object is cloaked.

@return true if cloaked, false if not
@see setCloaked()
 */
   virtual bool isCloaked(()) {}
   /*! @brief Set the damage flash level.

Damage flash may be used as a postfx effect to flash the screen when the client is damaged.
@note Relies on the flash postFx.
@param level flash level (0-1)
@see getDamageFlash()
 */
   virtual void setDamageFlash(( float level )) {}
   /*! @brief Get the damage flash level.

@return flash level
@see setDamageFlash
 */
   virtual float getDamageFlash(()) {}
   /*! @brief Set the white-out level.

White-out may be used as a postfx effect to brighten the screen in response to a game event.
@note Relies on the flash postFx.
@param level flash level (0-1)
@see getWhiteOut()
 */
   virtual void setWhiteOut(( float level )) {}
   /*! @brief Get the white-out level.

@return white-out level
@see setWhiteOut
 */
   virtual float getWhiteOut(()) {}
   /*! @brief Returns the default vertical field of view in degrees for this object if used as a camera.

@return Default FOV
 */
   virtual float getDefaultCameraFov(()) {}
   /*! @brief Returns the vertical field of view in degrees for this object if used as a camera.

@return current FOV as defined in ShapeBaseData::cameraDefaultFov
 */
   virtual float getCameraFov(()) {}
   /*! @brief Set the vertical field of view in degrees for this object if used as a camera.

@param fov new FOV value
 */
   virtual void setCameraFov(( float fov )) {}
   /*! @brief Setup the invincible effect.

This effect is used for HUD feedback to the user that they are invincible.
@note Currently not implemented
@param time duration in seconds for the invincible effect
@param speed speed at which the invincible effect progresses
 */
   virtual void setInvincibleMode(( float time, float speed )) {}
   /*! @brief Fade the object in or out without removing it from the scene.

A faded out object is still in the scene and can still be collided with, so if you want to disable collisions for this shape after it fades out use setHidden to temporarily remove this shape from the scene.
@note Items have the ability to light their surroundings. When an Item with an active light is fading out, the light it emits is correspondingly reduced until it goes out. Likewise, when the item fades in, the light is turned-up till it reaches it's normal brightntess.
@param time duration of the fade effect in ms
@param delay delay in ms before the fade effect begins
@param fadeOut true to fade-out to invisible, false to fade-in to full visibility
 */
   virtual void startFade(( int time, int delay, bool fadeOut )) {}
   /*! @brief Set the damage direction vector.

Currently this is only used to initialise the explosion if this object is blown up.
@param vec damage direction vector

@tsexample
%obj.setDamageVector( "0 0 1" );
@endtsexample
 */
   virtual void setDamageVector(( Point3F vec )) {}
   /*! @brief Set the name of this shape.

@note This is the name of the shape object that is sent to the client, not the DTS or DAE model filename.
@param name new name for the shape

@see getShapeName()
 */
   virtual void setShapeName(( string name )) {}
   /*! @brief Get the name of the shape.

@note This is the name of the shape object that is sent to the client, not the DTS or DAE model filename.
@return the name of the shape

@see setShapeName()
 */
   virtual string getShapeName(()) {}
   /*! @brief Apply a new skin to this shape.

'Skinning' the shape effectively renames the material targets, allowing different materials to be used on different instances of the same model.

@param name name of the skin to apply

@see skin
@see getSkinName()
 */
   virtual void setSkinName(( string name )) {}
   /*! @brief Get the name of the skin applied to this shape.

@return the name of the skin

@see skin
@see setSkinName()
 */
   virtual string getSkinName(()) {}
   /*! @brief Set the hidden state on all the shape meshes.

This allows you to hide all meshes in the shape, for example, and then only enable a few.
@param hide new hidden state for all meshes

 */
   virtual void setAllMeshesHidden(( bool hide )) {}
   /*! @brief Set the hidden state on the named shape mesh.

@param name name of the mesh to hide/show
@param hide new hidden state for the mesh

 */
   virtual void setMeshHidden(( string name, bool hide )) {}
   /*! @brief Print a list of visible and hidden meshes in the shape to the console for debugging purposes.

@note Only in a SHIPPING build.
 */
   virtual void dumpMeshVisibility(()) {}
   /*! @brief Get the name of the indexed shape material.

@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.

@see getTargetCount()
 */
   virtual string getTargetName(( int index )) {}
   /*! @brief Get the number of materials in the shape.

@return the number of materials in the shape.

@see getTargetName()
 */
   virtual int getTargetCount(()) {}
   /*! @brief Change one of the materials on the shape.

This method changes materials per mapTo with others. The material that is being replaced is mapped to unmapped_mat as a part of this transition.
@note Warning, right now this only sort of works. It doesn't do a live update like it should.
@param mapTo the name of the material target to remap (from getTargetName)
@param oldMat the old Material that was mapped 
@param newMat the new Material to map

@tsexample
// remap the first material in the shape
%mapTo = %obj.getTargetName( 0 );
%obj.changeMaterial( %mapTo, 0, MyMaterial );
@endtsexample
 */
   virtual void changeMaterial(( string mapTo, Material oldMat, Material newMat )) {}
   /*! @brief Get the model filename used by this shape.

@return the shape filename

 */
   virtual string getModelFile(()) {}
   /*! @brief Show the base_n_ meshes and hide all others. */
   virtual void showBaseNMeshes(()) {}
   /*! @brief Assigns a material to a skin on the base model.

@param skinTag The texture name in the model to assign the material to.
@param mat The name of the material to assign. */
   virtual void SetModelSkin(( string skinTag, string mat )) {}
   /*! @brief Sends all skin updates to clients */
   virtual void updateModelSkins(()) {}
   /*! @brief Assign a material to a skin on a piece of mounted equipment

@param skinTag The texture name in the mounted shape to apply the material to.
@param mat The name of the material to apply.
@param mountNode The node ID returned from mountEquipment when the shape was mounted. */
   virtual void SetEquipmentSkin(( string skinTag, string mat, int mountNode )) {}
   /*! @brief Mounts a shape to this model.

@param partName The name of the shape to mount.
@param nodeName The name of the node to mount to.
@return The index of the node mounted to or -1 on failure. */
   virtual int mountEquipment(( string partName, string nodeName )) {}
   /*! @brief Unmounts any shape mounted to the passed node.

@param nodeName The name of the node to remove all mounts from.
@return The index of the node that was cleared to or -1 if the node was not found. */
   virtual int unmountEquipment(( string nodeName )) {}
   /*! @brief Sends equipment updates to clients. All calls to mountEquipment() get pooled  until this is called so they can all be sent in one network update packet. */
   virtual void updateMountedEquipment(()) {}
   /*! @brief Set the clan name to display with this shape.

@param name new clan name for the shape

@see getClanName()
 */
   virtual void setClanName(( string name )) {}
   /*! @brief Get the clan name displayed on the shape.

@return the clan name of the shape

@see setClanName()
 */
   virtual string getClanName(()) {}
   /*! @brief Set the options string used to customize the shape.

@param optionStr customization options to apply when creating the shape

 */
   virtual void setAvOptions(( string optionStr )) {}
   virtual void setShapeServerId((id)) {}
   /*! @brief Set the options string used to customize the shape.

@param optionStr customization options to apply when creating the shape

 */
   virtual void setImageHidden(( int slot, bool hideVal )) {}
   /*! @brief Get the muzzle position of the Image mounted in the specified slot.

If the Image shape contains a node called 'muzzlePoint', then the muzzle position is the position of that node in world space. If no such node is specified, the slot's mount node is used instead. This verion of the function animates the shape on the server so the point is more accurate.
@param slot Image slot to query
@return the muzzle position, or "0 0 0" if the slot is invalid

 */
   virtual string getAnimMuzzlePoint(( int slot )) {}
   /*! @brief sets the distance behind eye point for the 3rd person camera.

@return No return value.

 */
   virtual void setAVCamDistance(( float camDist )) {}
   /*! @brief gets the distance behind eye point for the 3rd person camera.

@return distance in world units.

 */
   virtual float getAVCamDistance(()) {}
   /*!
   @brief The skin applied to the shape.

'Skinning' the shape effectively renames the material targets, allowing different materials to be used on different instances of the same model. Using getSkinName() and setSkinName() is equivalent to reading and writing the skin field directly.

Any material targets that start with the old skin name have that part of the name replaced with the new skin name. The initial old skin name is "base". For example, if a new skin of "blue" was applied to a model that had material targets <i>base_body</i> and <i>face</i>, the new targets would be <i>blue_body</i> and <i>face</i>. Note that <i>face</i> was not renamed since it did not start with the old skin name of "base".

To support models that do not use the default "base" naming convention, you can also specify the part of the name to replace in the skin field itself. For example, if a model had a material target called <i>shapemat</i>, we could apply a new skin "shape=blue", and the material target would be renamed to <i>bluemat</i> (note "shape" has been replaced with "blue").

Multiple skin updates can also be applied at the same time by separating them with a semicolon. For example: "base=blue;face=happy_face".

Material targets are only renamed if an existing Material maps to that name, or if there is a diffuse texture in the model folder with the same name as the new target.


   
    */
   string skin;
   /*!
   @brief Is this object AI controlled.

If True then this object is considered AI controlled and not player controlled.

   
    */
   bool isAIControlled;

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This is a base class for all "marker" related objets. It is a 3D representation of a point in the level.

The main use of a MissionMarker is to represent a point in 3D space with a mesh and basic ShapeBase information. If you simply need to mark a spot in your level, with no overhead from additional fields, this is a useful object.

@tsexample
new MissionMarker()
{
   dataBlock = "WayPointMarker";
   position = "295.699 -171.817 280.124";
   rotation = "0 0 -1 13.8204";
   scale = "1 1 1";
   isRenderEnabled = "true";
   canSaveDynamicFields = "1";
   enabled = "1";
};
@endtsexample

@note MissionMarkers will not add themselves to the scene except when in the editor.

@see MissionMarkerData

@see SpawnSphere

@see WayPoint

@ingroup enviroMisc
 */
class  MissionMarker : public ShapeBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Special type of marker, distinguished by a name and team ID number

The original Torque engines were built from a multi-player game called Tribes. The Tribes series featured various team based game modes, such as capture the flag. The WayPoint class survived the conversion from game (Tribes) to game engine (Torque).

Essentially, this is a MissionMarker with the addition of two variables: markerName and team. Whenever a WayPoint is created, it is added to a unique global list called WayPointSet. You can iterate through this set, seeking out specific markers determined by their markerName and team ID. This avoids the overhead of constantly calling commandToClient and commandToServer to determine a WayPoint object's name, unique ID, etc.

@note The <i>markerName<i> field was previously called <i>name</i>, but was changed because this conflicted with the SimObject name field. Existing scripts that relied on the WayPoint <i>name</i> field will need to be updated.

@tsexample
new WayPoint()
{
   team = "1";
   dataBlock = "WayPointMarker";
   position = "-0.0224786 1.53471 2.93219";
   rotation = "1 0 0 0";
   scale = "1 1 1";
   canSave = "1";
   canSaveDynamicFields = "1";
};
@endtsexample

@see MissionMarker

@see MissionMarkerData

@ingroup enviroMisc
 */
class  WayPoint : public MissionMarker {
  public:

   /*! @name Misc
   @{ */
   /*! */
   /*!
   Unique name representing this waypoint
   
    */
   caseString markerName;
   /*!
   Unique numerical ID assigned to this waypoint, or set of waypoints
   
    */
   WayPointTeam team;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Special type of mission marker which allows a level editor's camera to jump to specific points.

For Torque 3D editors only, not for actual game development

 */
class  CameraBookmark : public MissionMarker {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An invisible shape that causes objects hidden from view behind it to not be rendered.

OcclusionVolume is a class for scene optimization.  It's main use is for outdoor spaces where zones and portals do not help in optimizing scene culling as they almost only make sense for modeling visibility in indoor scenarios (and for connecting indoor spaces to outdoor spaces).

During rendering, every object that is fully behind an occluder 

Be aware that occluders add overhead to scene culling.  Only if this overhead is outweighed by the time saved by not rendering hidden objects, is the occluder actually effective.  Because of this, chose only those spots for placing occluders where a significant number of objects will be culled from points that the player will actually be at during the game.

Like zones and portals, OcclusionVolumes may have a default box shape or a more complex 

@see Scene::maxOccludersPerZone
@see Scene::occluderMinWidthPercentage
@see Scene::occluderMinHeightPercentage
 */
class  OcclusionVolume : public SceneObject {
  public:

   /*! @name Internal
   @{ */
   /*! */
   /*!
   For internal use only.
   
    */
   string plane;
   /*!
   For internal use only.
   
    */
   string point;
   /*!
   For internal use only.
   
    */
   string edge;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief General interface to control a PathCamera object from the script level.
@see PathCamera
@tsexample
datablock PathCameraData(LoopingCam)
^{
^^mode = "";
^};
@endtsexample
@ingroup PathCameras
@ingroup Datablocks
 */
class  PathCameraData : public ShapeBaseData {
  public:

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This is the base class for light objects.

It is *NOT* intended to be used directly in script, but exists to provide the base member variables and generic functionality. You should be using the derived classes PointLight and SpotLight, which can be declared in TorqueScript or added from the World Editor.

For this class, we only add basic lighting options that all lighting systems would use. The specific lighting system options are injected at runtime by the lighting system itself.

@see PointLight

@see SpotLight

@ingroup Lighting
 */
class  LightBase : public SceneObject {
  public:
   /*! @brief Toggles the light on and off

@param state Turns the light on (true) or off (false)
@tsexample
// Disable the light
CrystalLight.setLightEnabled(false);

// Renable the light
CrystalLight.setLightEnabled(true);
@endtsexample

 */
   virtual void setLightEnabled(( bool state )) {}
   /*! Plays a light animation on the light.  If no LightAnimData is passed the existing one is played.@hide */
   virtual void playAnimation(( [LightAnimData anim] )) {}
   /*! Stops the light animation. */
   virtual void pauseAnimation() {}

   /*! @name Light
   @{ */
   /*! */
   /*!
   Enables/Disables the object rendering and functionality in the scene.
   
    */
   bool isEnabled;
   /*!
   Changes the base color hue of the light.
   
    */
   ColorF color;
   /*!
   Adjusts the lights power, 0 being off completely.
   
    */
   float brightness;
   /*!
   Enables/disabled shadow casts by this light.
   
    */
   bool castShadows;
   /*!
   Used for sorting of lights by the light manager. Priority determines if a light has a stronger effect than, those with a lower value
   
    */
   float priority;
   /// @}


   /*! @name Light Animation
   @{ */
   /*! */
   /*!
   Toggles animation for the light on and off
   
    */
   bool animate;
   /*!
   Datablock containing light animation information (LightAnimData)
   
    */
   LightAnimData animationType;
   /*!
   The length of time in seconds for a single playback of the light animation (must be > 0)
   
    */
   float animationPeriod;
   /*!
   The phase used to offset the animation start time to vary the animation of nearby lights.
   
    */
   float animationPhase;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Datablock containing light flare information (LightFlareData)
   
    */
   LightFlareData flareType;
   /*!
   Globally scales all features of the light flare
   
    */
   float flareScale;
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /*!
   The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.
   
    */
   Point3F attenuationRatio;
   /*!
   The type of shadow to use on this light.
   
    */
   ShadowType shadowType;
   /*!
   A custom pattern texture which is projected from the light.
   
    */
   filename cookie;
   /*!
   The texture size of the shadow map.
   
    */
   int texSize;
   /*!
   The ESM shadow darkening factor
   
    */
   Point4F overDarkFactor;
   /*!
   The distance from the camera to extend the PSSM shadow.
   
    */
   float shadowDistance;
   /*!
   
   
    */
   float shadowSoftness;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   int numSplits;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   float logWeight;
   /*!
   Start fading shadows out at this distance.  0 = auto calculate this distance.
   
    */
   float fadeStartDistance;
   /*!
   This toggles only terrain being rendered to the last split of a PSSM shadow map.
   
    */
   bool lastSplitTerrainOnly;
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /*!
   This light is represented in lightmaps (static light, default: false)
   
    */
   bool representedInLightmap;
   /*!
   The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)
   
    */
   ColorF shadowDarkenColor;
   /*!
   This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)
   
    */
   bool includeLightmappedGeometryInShadow;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Lighting object that radiates light in all directions.

PointLight is one of the two types of lighting objects that can be added to a Torque 3D level, the other being SpotLight. Unlike directional or conical light, the PointLight emits lighting in all directions. The attenuation is controlled by a single variable: LightObject::radius.

@tsexample
// Declaration of a point light in script, or created by World Editor
new PointLight(CrystalLight)
{
   radius = "10";
   isEnabled = "1";
   color = "1 0.905882 0 1";
   brightness = "0.5";
   castShadows = "1";
   priority = "1";
   animate = "1";
   animationType = "SubtlePulseLightAnim";
   animationPeriod = "3";
   animationPhase = "3";
   flareScale = "1";
   attenuationRatio = "0 1 1";
   shadowType = "DualParaboloidSinglePass";
   texSize = "512";
   overDarkFactor = "2000 1000 500 100";
   shadowDistance = "400";
   shadowSoftness = "0.15";
   numSplits = "1";
   logWeight = "0.91";
   fadeStartDistance = "0";
   lastSplitTerrainOnly = "0";
   splitFadeDistances = "10 20 30 40";
   representedInLightmap = "0";
   shadowDarkenColor = "0 0 0 -1";
   includeLightmappedGeometryInShadow = "1";
   position = "-61.3866 1.69186 5.1464";
   rotation = "1 0 0 0";
};
@endtsexample

@see LightBase

@see SpotLight

@ingroup Lighting
 */
class  PointLight : public LightBase {
  public:

   /*! @name Light
   @{ */
   /*! */
   /*!
   Controls the falloff of the light emission
   
    */
   float radius;
   /// @}


   /*! @name Light
   @{ */
   /*! */
   /// @}


   /*! @name Light Animation
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the physics properties for an individual RigidShapeData physics object.

@tsexample
^datablock RigidShapeData( BouncingBoulder )
^{
^   category = "RigidShape";

^   shapeFile = "~/data/shapes/boulder/boulder.dts";
^   emap = true;

^   // Rigid Body
^   mass = 500;
^   massCenter = "0 0 0";    // Center of mass for rigid body
^   massBox = "0 0 0";         // Size of box used for moment of inertia,
^^^^^^^^  // if zero it defaults to object bounding box
^   drag = 0.2;                // Drag coefficient
^   bodyFriction = 0.2;
^   bodyRestitution = 0.1;
^   minImpactSpeed = 5;        // Impacts over this invoke the script callback
^   softImpactSpeed = 5;       // Play SoftImpact Sound
^   hardImpactSpeed = 15;      // Play HardImpact Sound
^   integration = 4;           // Physics integration: TickSec/Rate
^   collisionTol = 0.1;        // Collision distance tolerance
^   contactTol = 0.1;          // Contact velocity tolerance

^   minRollSpeed = 10;

^   maxDrag = 0.5;
^   minDrag = 0.01;

^   dustHeight = 10;

^   dragForce = 0.05;
^   vertFactor = 0.05;
^};
@endtsexample

@see RigidShape
@see ShapeBase

@ingroup Platform
 */
class  RigidShapeData : public ShapeBaseData {
  public:
   /*!
   Center of mass for rigid body.
   
    */
   Point3F massCenter;
   /*!
   Size of inertial box.
   
    */
   Point3F massBox;
   /*!
   The percentage of kinetic energy kept by this object in a collision.
   
    */
   float bodyRestitution;
   /*!
   How much friction this object has. Lower values will cause the object to appear to be more slippery.
   
    */
   float bodyFriction;
   /*!
   Minimum collision speed to classify collision as impact (triggers onImpact on server object).
   
    */
   float minImpactSpeed;
   /*!
   Minimum speed at which this object must be travelling for the soft impact sound to be played.
   
    */
   float softImpactSpeed;
   /*!
   Minimum speed at which the object must be travelling for the hard impact sound to be played.
   
    */
   float hardImpactSpeed;
   /*!
    */
   float minRollSpeed;
   /*!
   Maximum drag available to this object.
   
    */
   float maxDrag;
   /*!
   Minimum drag available to this object.
   
    */
   float minDrag;
   /*!
   Number of physics steps to process per tick.
   
    */
   int integration;
   /*!
   Collision distance tolerance.
   
    */
   float collisionTol;
   /*!
   Contact velocity tolerance.
   
    */
   float contactTol;

   /*! @name Forces
   @{ */
   /*! */
   /*!
   Used to simulate the constant drag acting on the object
   
    */
   float dragForce;
   /*!
   The scalar applied to the vertical portion of the velocity drag acting on a object.
   
    */
   float vertFactor;
   /// @}


   /*! @name Particle Effects
   @{ */
   /*! */
   /*!
   Array of pointers to ParticleEmitterData datablocks which will be used to emit particles at object/terrain contact point.

   
    */
   ParticleEmitterData dustEmitter;
   /*!
   Maximum height from the ground at which the object will generate dust.

   
    */
   float triggerDustHeight;
   /*!
   Height of dust effects.

   
    */
   float dustHeight;
   /*!
   Particle emitter used to create a dust trail for the moving object.

   
    */
   ParticleEmitterData dustTrailEmitter;
   /*!
   Array of pointers to ParticleEmitterData datablocks which will generate splash effects.

   
    */
   ParticleEmitterData splashEmitter;
   /*!
   The simulated frequency modulation of a splash generated by this object. Multiplied along with speed and time elapsed when determining splash emition rate.

   
    */
   float splashFreqMod;
   /*!
   The threshold speed at which we consider the object's movement to have stopped when updating splash effects.

   
    */
   float splashVelEpsilon;
   /// @}


   /*! @name Sounds
   @{ */
   /*! */
   /*!
   Sound to play when body impacts with at least softImageSpeed but less than hardImpactSpeed.
   
    */
   SFXTrack softImpactSound;
   /*!
   Sound to play when body impacts with at least hardImpactSpeed.
   
    */
   SFXTrack hardImpactSound;
   /*!
   The minimum velocity at which the exit splash sound will be played when emerging from water.

   
    */
   float exitSplashSoundVelocity;
   /*!
   The minimum velocity at which the soft splash sound will be played when impacting water.

   
    */
   float softSplashSoundVelocity;
   /*!
   The minimum velocity at which the medium splash sound will be played when impacting water.

   
    */
   float mediumSplashSoundVelocity;
   /*!
   The minimum velocity at which the hard splash sound will be played when impacting water.

   
    */
   float hardSplashSoundVelocity;
   /*!
   The AudioProfile will be used to produce sounds when emerging from water.

   
    */
   SFXTrack exitingWater;
   /*!
   The AudioProfile will be used to produce sounds when a soft impact with water occurs.

   
    */
   SFXTrack impactWaterEasy;
   /*!
   The AudioProfile will be used to produce sounds when a medium impact with water occurs.

   
    */
   SFXTrack impactWaterMedium;
   /*!
   The AudioProfile will be used to produce sounds when a hard impact with water occurs.

   
    */
   SFXTrack impactWaterHard;
   /*!
   The AudioProfile will be used to produce sounds when a water wake is displayed.

   
    */
   SFXTrack waterWakeSound;
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /*!
   Specifies whether the camera's rotation matrix, and the render eye transform are multiplied during camera updates.

   
    */
   bool cameraRoll;
   /*!
   Scalar amount by which the third person camera lags the object, relative to the object's linear velocity.

   
    */
   float cameraLag;
   /*!
   Scalar rate at which the third person camera offset decays, per tick.

   
    */
   float cameraDecay;
   /*!
   The vertical offset of the object's camera.

   
    */
   float cameraOffset;
   /// @}


   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The most basic 3D shape with a datablock available in Torque 3D.

When it comes to placing 3D objects in the scene, you technically have two options:

1. TSStatic objects

2. ShapeBase derived objects

Since ShapeBase and ShapeBaseData are not meant to be instantiated in script, you will use one of its child classes instead. Several game related objects are derived from ShapeBase: Player, Vehicle, Item, and so on.

When you need a 3D object with datablock capabilities, you will use an object derived from ShapeBase. When you need an object with extremely low overhead, and with no other purpose than to be a 3D object in the scene, you will use TSStatic.

The most basic child of ShapeBase is StaticShape. It does not introduce any of the additional functionality you see in Player, Item, Vehicle or the other game play heavy classes. At its core, it is comparable to a TSStatic, but with a datbalock.  Having a datablock provides a location for common variables as well as having access to various ShapeBaseData, GameBaseData and SimDataBlock callbacks.

@tsexample
// Create a StaticShape using a datablock
datablock StaticShapeData(BasicShapeData)
{
^shapeFile = "art/shapes/items/kit/healthkit.dts";
^testVar = "Simple string, not a stock variable";
};

new StaticShape()
{
^dataBlock = "BasicShapeData";
^position = "0.0 0.0 0.0";
^rotation = "1 0 0 0";
^scale = "1 1 1";
};
@endtsexample

@see StaticShapeData
@see ShapeBase
@see TSStatic

@ingroup gameObjects
 */
class  StaticShape : public ShapeBase {
  public:
   /*! @internal */
   virtual void setPoweredState((bool isPowered)) {}
   /*! @internal */
   virtual bool getPoweredState() {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief StaticShape object which is always scoped.

@note Exists for backwards compatibility, no real use anymore. Go with TSStatic or a standard StaticShape instead.

@internal
 */
class  ScopeAlwaysShape : public StaticShape {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Lighting object which emits conical light in a direction.

SpotLight is one of the two types of lighting objects that can be added to a Torque 3D level, the other being PointLight. Unlike directional or point lights, the SpotLights emits lighting in a specific direction within a cone. The distance of the cone is controlled by the SpotLight::range variable.

@tsexample
// Declaration of a point light in script, or created by World Editor
new SpotLight(SampleSpotLight)
{
   range = "10";
   innerAngle = "40";
   outerAngle = "45";
   isEnabled = "1";
   color = "1 1 1 1";
   brightness = "1";
   castShadows = "0";
   priority = "1";
   animate = "1";
   animationPeriod = "1";
   animationPhase = "1";
   flareType = "LightFlareExample0";
   flareScale = "1";
   attenuationRatio = "0 1 1";
   shadowType = "Spot";
   texSize = "512";
   overDarkFactor = "2000 1000 500 100";
   shadowDistance = "400";
   shadowSoftness = "0.15";
   numSplits = "1";
   logWeight = "0.91";
   fadeStartDistance = "0";
   lastSplitTerrainOnly = "0";
   representedInLightmap = "0";
   shadowDarkenColor = "0 0 0 -1";
   includeLightmappedGeometryInShadow = "0";
   position = "-29.4362 -5.86289 5.58602";
   rotation = "1 0 0 0";
};
@endtsexample

@see LightBase

@see PointLight

@ingroup Lighting
 */
class  SpotLight : public LightBase {
  public:

   /*! @name Light
   @{ */
   /*! */
   /*!
    */
   float range;
   /*!
    */
   float innerAngle;
   /*!
    */
   float outerAngle;
   /// @}


   /*! @name Light
   @{ */
   /*! */
   /// @}


   /*! @name Light Animation
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The most basic ShapeBaseData derrived shape datablock available in Torque 3D.

When it comes to placing 3D objects in the scene, you effectively have two options:

1. TSStatic objects

2. ShapeBase derived objects

Since ShapeBase and ShapeBaseData are not meant to be instantiated in script, you will use one of its child classes instead. Several game related objects are derived from ShapeBase: Player, Vehicle, Item, and so on.

When you need a 3D object with datablock capabilities, you will use an object derived from ShapeBase. When you need an object with extremely low overhead, and with no other purpose than to be a 3D object in the scene, you will use TSStatic.

The most basic child of ShapeBase is StaticShape. It does not introduce any of the additional functionality you see in Player, Item, Vehicle or the other game play heavy classes. At its core, it is comparable to a TSStatic, but with a datbalock.  Having a datablock provides a location for common variables as well as having access to various ShapeBaseData, GameBaseData and SimDataBlock callbacks.

@tsexample
// Create a StaticShape using a datablock
datablock StaticShapeData(BasicShapeData)
{
^shapeFile = "art/shapes/items/kit/healthkit.dts";
^testVar = "Simple string, not a stock variable";
};

new StaticShape()
{
^dataBlock = "BasicShapeData";
^position = "0.0 0.0 0.0";
^rotation = "1 0 0 0";
^scale = "1 1 1";
};
@endtsexample

@see StaticShape
@see ShapeBaseData
@see TSStatic

@ingroup gameObjects
 */
class  StaticShapeData : public ShapeBaseData {
  public:
   /*!
   Deprecated

 @internal
   
    */
   bool noIndividualDamage;
   /*!
   @brief An integer value which, if speficied, is added to the value retured by getType().

This allows you to extend the type mask for a StaticShape that uses this datablock.  Type masks are used for container queries, etc.
   
    */
   int dynamicType;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The object that manages all of the decals in the active mission.

@see Decals
@ingroup Decals
@ingroup FX
 */
class  DecalManager : public SceneObject {
  public:

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An example scene object which renders using a callback.

This class implements a basic SceneObject that can exist in the world at a 3D position and render itself. Note that RenderObjectExample handles its own rendering by submitting itself as an ObjectRenderInst (see renderInstanceenderPassmanager.h) along with a delegate for its render() function. However, the preffered rendering method in the engine is to submit a MeshRenderInst along with a Material, vertex buffer, primitive buffer, and transform and allow the RenderMeshMgr handle the actual rendering. You can see this implemented in RenderMeshExample.

See the C++ code for implementation details.

@ingroup Examples
 */
class  RenderObjectExample : public SceneObject {
  public:

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An example scene object which renders a DTS.

This class implements a basic SceneObject that can exist in the world at a 3D position and render itself. There are several valid ways to render an object in Torque. This class makes use of the 'TS' (three space) shape system. TS manages loading the various mesh formats supported by Torque as well was rendering those meshes (including LOD and animation...though this example doesn't include any animation over time).

See the C++ code for implementation details.

@ingroup Examples
 */
class  RenderShapeExample : public SceneObject {
  public:

   /*! @name Rendering
   @{ */
   /*! */
   /*!
   The path to the DTS shape file.
   
    */
   filename shapeFile;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A gui control that is used to display an image.

The image is stretched to the constraints of the control by default. However, the control can also
tile the image as well.

The image itself is stored inside the GuiBitmapCtrl::bitmap field. The boolean value that decides
whether the image is stretched or tiled is stored inside the GuiBitmapCtrl::wrap field.
@tsexample
// Create a tiling GuiBitmapCtrl that displays "myImage.png"
%bitmapCtrl = new GuiBitmapCtrl()
{
   bitmap = "myImage.png";
   wrap = "true";
};
@endtsexample

 */
class  GuiBitmapCtrl : public GuiControl {
  public:
   /*! Set the offset of the bitmap within the control.
@param x The x-axis offset of the image.
@param y The y-axis offset of the image.
 */
   virtual void setValue(( int x, int y )) {}
   /*! Assign an image to the control.

@hide */
   virtual void setBitmap(( String filename | String filename, bool resize )) {}

   /*! @name Bitmap
   @{ */
   /*! */
   /*!
   The bitmap file to display in the control.
   
    */
   filename bitmap;
   /*!
   If true, the bitmap is tiled inside the control rather than stretched to fit.
   
    */
   bool wrap;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Basic cross hair hud. Reacts to state of control object. Also displays health bar for named objects under the cross hair.

Uses the base bitmap control to render a bitmap, and decides whether to draw or not depending on the current control object and it's state. If there is ShapeBase object under the cross hair and it's named, then a small health bar is displayed.

@tsexample

 new GuiCrossHairHud(){
^damageFillColor = "1.0 0.0 0.0 1.0"; // Fills with a solid red color
^damageFrameColor = "1.0 1.0 1.0 1.0"; // Solid white frame color
^damageRect = "15 5";
^damageOffset = "0 -10";
};
@endtsexample
@ingroup GuiGame
 */
class  GuiCrossHairHud : public GuiBitmapCtrl {
  public:

   /*! @name Damage
   @{ */
   /*! */
   /*!
   As the health bar depletes, this color will represent the health loss amount.
   
    */
   ColorF damageFillColor;
   /*!
   Color for the health bar's frame.
   
    */
   ColorF damageFrameColor;
   /*!
   Size for the health bar portion of the control.
   
    */
   Point2I damageRect;
   /*!
   Offset for drawing the damage portion of the health control.
   
    */
   Point2I damageOffset;
   /// @}


   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A basic health bar. Shows the damage value of the current PlayerObjectType control object.

This gui displays the damage value of the current PlayerObjectType control object. The gui can be set to pulse if the health value drops below a set value. This control only works if a server connection exists and it's control object is a PlayerObjectType. If either of these requirements is false, the control is not rendered.

@tsexample

 new GuiHealthBarHud(){
^fillColor = "0.0 1.0 0.0 1.0"; // Fills with a solid green color
^frameColor = "1.0 1.0 1.0 1.0"; // Solid white frame color
^damageFillColor = "1.0 0.0 0.0 1.0"; // Fills with a solid red color
^pulseRate = "500";
^pulseThreshold = "0.25";
^showFill = "true";
^showFrame = "true";
^displayEnergy = "false";
};
@endtsexample

@ingroup GuiGame
 */
class  GuiHealthBarHud : public GuiControl {
  public:

   /*! @name Colors
   @{ */
   /*! */
   /*!
   Standard color for the background of the control.
   
    */
   ColorF fillColor;
   /*!
   Color for the control's frame.
   
    */
   ColorF frameColor;
   /*!
   As the health bar depletes, this color will represent the health loss amount.
   
    */
   ColorF damageFillColor;
   /// @}


   /*! @name Pulse
   @{ */
   /*! */
   /*!
   Speed at which the control will pulse.
   
    */
   int pulseRate;
   /*!
   Health level the control must be under before the control will pulse.
   
    */
   float pulseThreshold;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   If true, we draw the background color of the control.
   
    */
   bool showFill;
   /*!
   If true, we draw the frame of the control.
   
    */
   bool showFrame;
   /*!
   If true, display the energy value rather than the damage value.
   
    */
   bool displayEnergy;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Shows the health or energy value of the current PlayerObjectType control object.

This gui can be configured to display either the health or energy value of the current Player Object. It can use an alternate display color if the health or drops below a set value. It can also be set to pulse if the health or energy drops below a set value. This control only works if a server connection exists and it's control object is a PlayerObjectType. If either of these requirements is false, the control is not rendered.

@tsexample

 new GuiHealthTextHud(){
   fillColor = "0.0 0.0 0.0 0.5"; // Fills with a transparent black color
   frameColor = "1.0 1.0 1.0 1.0"; // Solid white frame color
   textColor = "0.0 1.0 0.0 1.0" // Solid green text color
   warningColor = "1.0 0.0 0.0 1.0"; // Solid red color, used when damaged
   showFill = "true";
   showFrame = "true";
   showTrueValue = "false";
   showEnergy = "false";
   warnThreshold = "50";
   pulseThreshold = "25";
   pulseRate = "500";
   profile = "GuiBigTextProfile";
};
@endtsexample

@ingroup GuiGame
 */
class  GuiHealthTextHud : public GuiControl {
  public:

   /*! @name Colors
   @{ */
   /*! */
   /*!
   Color for the background of the control.
   
    */
   ColorF fillColor;
   /*!
   Color for the control's frame.
   
    */
   ColorF frameColor;
   /*!
   Color for the text on this control.
   
    */
   ColorF textColor;
   /*!
   Color for the text when health is low.
   
    */
   ColorF warningColor;
   /// @}


   /*! @name View
   @{ */
   /*! */
   /*!
   If true, draw the background.
   
    */
   bool showFill;
   /*!
   If true, draw the frame.
   
    */
   bool showFrame;
   /*!
   If true, we don't hardcode maxHealth to 100.
   
    */
   bool showTrueValue;
   /*!
   If true, display the energy value rather than the damage value.
   
    */
   bool showEnergy;
   /// @}


   /*! @name Alert
   @{ */
   /*! */
   /*!
   The health level at which to use the warningColor.
   
    */
   float warnThreshold;
   /*!
   Health level at which to begin pulsing.
   
    */
   float pulseThreshold;
   /*!
   Speed at which the control will pulse.
   
    */
   int pulseRate;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Displays name and damage of ShapeBase objects in its bounds. Must be a child of a GuiTSCtrl and a server connection must be present.

This control displays the name and damage value of all named ShapeBase objects on the client. The name and damage of objects within the control's display area are overlayed above the object.

This GUI control must be a child of a TSControl, and a server connection and control object must be present. This is a stand-alone control and relies only on the standard base GuiControl.

@tsexample

 new GuiShapeNameHud(){
^fillColor = "0.0 1.0 0.0 1.0"; // Fills with a solid green color
^frameColor = "1.0 1.0 1.0 1.0"; // Solid white frame color
^textColor = "1.0 1.0 1.0 1.0"; // Solid white text Color
^showFill = "true";
^showFrame = "true";
^verticalOffset = "0.15";
^distanceFade = "15.0";
};
@endtsexample

@ingroup GuiGame
 */
class  GuiShapeNameHud : public GuiControl {
  public:

   /*! @name Colors
   @{ */
   /*! */
   /*!
   Standard color for the background of the control.
   
    */
   ColorF fillColor;
   /*!
   Color for the control's frame.
   
    */
   ColorF frameColor;
   /*!
   Color for the text on this control.
   
    */
   ColorF textColor;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   If true, we draw the background color of the control.
   
    */
   bool showFill;
   /*!
   If true, we draw the frame of the control.
   
    */
   bool showFrame;
   /*!
   Amount to vertically offset the control in relation to the ShapeBase object in focus.
   
    */
   float verticalOffset;
   /*!
   Visibility distance (how far the player must be from the ShapeBase object in focus) for this control to render.
   
    */
   float distanceFade;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The emitter for an explosion effect, with properties defined by a ExplosionData object.

@ingroup FX
The object will initiate the explosion effects automatically after being added to the simulation.
@tsexample
datablock ExplosionData( GrenadeSubExplosion )
{
   offset = 0.25;
   emitter[0] = GrenadeExpSparkEmitter;

   lightStartRadius = 4.0;
   lightEndRadius = 0.0;
   lightStartColor = "0.9 0.7 0.7";
   lightEndColor = "0.9 0.7 0.7";
   lightStartBrightness = 2.0;
   lightEndBrightness = 0.0;
};

datablock ExplosionData( GrenadeLauncherExplosion )
{
   soundProfile = GrenadeLauncherExplosionSound;
   lifeTimeMS = 400; // Quick flash, short burn, and moderate dispersal

   // Volume particles
   particleEmitter = GrenadeExpFireEmitter;
   particleDensity = 75;
   particleRadius = 2.25;

   // Point emission
   emitter[0] = GrenadeExpDustEmitter;
   emitter[1] = GrenadeExpSparksEmitter;
   emitter[2] = GrenadeExpSmokeEmitter;

   // Sub explosion objects
   subExplosion[0] = GrenadeSubExplosion;

   // Camera Shaking
   shakeCamera = true;
   camShakeFreq = "10.0 11.0 9.0";
   camShakeAmp = "15.0 15.0 15.0";
   camShakeDuration = 1.5;
   camShakeRadius = 20;

   // Exploding debris
   debris = GrenadeDebris;
   debrisThetaMin = 10;
   debrisThetaMax = 60;
   debrisNum = 4;
   debrisNumVariance = 2;
   debrisVelocity = 25;
   debrisVelocityVariance = 5;

   lightStartRadius = 4.0;
   lightEndRadius = 0.0;
   lightStartColor = "1.0 1.0 1.0";
   lightEndColor = "1.0 1.0 1.0";
   lightStartBrightness = 4.0;
   lightEndBrightness = 0.0;
   lightNormalOffset = 2.0;
};

function createExplosion()
{
   // Create a new explosion - it will explode automatically
   %pos = "0 0 100";
   %obj = new Explosion()
   {
      position = %pos;
      dataBlock = GrenadeLauncherExplosion;
   };
}

// schedule an explosion
schedule(1000, 0, createExplosion);
 */
class  Explosion : public GameBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the attributes of an Explosion: particleEmitters, debris, lighting and camera shake effects.
@ingroup FX
 */
class  ExplosionData : public GameBaseData {
  public:
   /*!
   @brief Optional DTS or DAE shape to place at the center of the explosion.

The <i>ambient</i> animation of this model will be played automatically at the start of the explosion.
   
    */
   filename explosionShape;
   /*!
   "X Y Z" scale factor applied to the explosionShape model at the start of the explosion.
   
    */
   Point3F explosionScale;
   /*!
   Time scale at which to play the explosionShape <i>ambient</i> sequence.
   
    */
   float playSpeed;
   /*!
   Non-looping sound effect that will be played at the start of the explosion.
   
    */
   SFXTrack soundProfile;
   /*!
   Controls whether the visual effects of the explosion always face the camera.
   
    */
   bool faceViewer;
   /*!
   @brief Emitter used to generate a cloud of particles at the start of the explosion.

Explosions can generate two different particle effects. The first is a single burst of particles at the start of the explosion emitted in a spherical cloud using particleEmitter.

The second effect spawns the list of ParticleEmitters given by the emitter[] field. These emitters generate particles in the normal way throughout the lifetime of the explosion.
   
    */
   ParticleEmitterData particleEmitter;
   /*!
   @brief Density of the particle cloud created at the start of the explosion.

@see particleEmitter
   
    */
   int particleDensity;
   /*!
   @brief Radial distance from the explosion center at which cloud particles are emitted.

@see particleEmitter
   
    */
   float particleRadius;
   /*!
   @brief List of additional ParticleEmitterData objects to spawn with this explosion.

@see particleEmitter
   
    */
   ParticleEmitterData emitter;
   /*!
   List of DebrisData objects to spawn with this explosion.
   
    */
   DebrisData Debris;
   /*!
   Minimum angle, from the horizontal plane, to eject debris from.
   
    */
   float debrisThetaMin;
   /*!
   Maximum angle, from the horizontal plane, to eject debris from.
   
    */
   float debrisThetaMax;
   /*!
   Minimum reference angle, from the vertical plane, to eject debris from.
   
    */
   float debrisPhiMin;
   /*!
   Maximum reference angle, from the vertical plane, to eject debris from.
   
    */
   float debrisPhiMax;
   /*!
   Number of debris objects to create.
   
    */
   int debrisNum;
   /*!
   Variance in the number of debris objects to create (must be from 0 - debrisNum).
   
    */
   int debrisNumVariance;
   /*!
   Velocity to toss debris at.
   
    */
   float debrisVelocity;
   /*!
   Variance in the debris initial velocity (must be >= 0).
   
    */
   float debrisVelocityVariance;
   /*!
   List of additional ExplosionData objects to create at the start of the explosion.
   
    */
   ExplosionData subExplosion;
   /*!
   Amount of time, in milliseconds, to delay the start of the explosion effect from the creation of the Explosion object.
   
    */
   int delayMS;
   /*!
   Variance, in milliseconds, of delayMS.
   
    */
   int delayVariance;
   /*!
   @brief Lifetime, in milliseconds, of the Explosion object.

@note If explosionShape is defined and contains an <i>ambient</i> animation, this field is ignored, and the playSpeed scaled duration of the animation is used instead.
   
    */
   int lifetimeMS;
   /*!
   Variance, in milliseconds, of the lifetimeMS of the Explosion object.

   
    */
   int lifetimeVariance;
   /*!
   @brief Offset distance (in a random direction) of the center of the explosion from the Explosion object position.

Most often used to create some variance in position for subExplosion effects.
   
    */
   float offset;
   /*!
   @brief Time keyframes used to scale the explosionShape model.

Values should be in increasing order from 0.0 - 1.0, and correspond to the life of the Explosion where 0 is the beginning and 1 is the end of the explosion lifetime.
@see lifetimeMS
   
    */
   float times;
   /*!
   @brief "X Y Z" size keyframes used to scale the explosionShape model.

The explosionShape (if defined) will be scaled using the times/sizes keyframes over the lifetime of the explosion.
@see lifetimeMS
   
    */
   Point3F sizes;
   /*!
   Controls whether the camera shakes during this explosion.
   
    */
   bool shakeCamera;
   /*!
   Frequency of camera shaking, defined in the "X Y Z" axes.
   
    */
   Point3F camShakeFreq;
   /*!
   @brief Amplitude of camera shaking, defined in the "X Y Z" axes.

Set any value to 0 to disable shaking in that axis.
   
    */
   Point3F camShakeAmp;
   /*!
   Duration (in seconds) to shake the camera.
   
    */
   float camShakeDuration;
   /*!
   Radial distance that a camera's position must be within relative to the center of the explosion to be shaken.
   
    */
   float camShakeRadius;
   /*!
   Falloff value for the camera shake.
   
    */
   float camShakeFalloff;
   /*!
   @brief Initial radius of the PointLight created by this explosion.

Radius is linearly interpolated from lightStartRadius to lightEndRadius over the lifetime of the explosion.
@see lifetimeMS
   
    */
   float lightStartRadius;
   /*!
   @brief Final radius of the PointLight created by this explosion.

@see lightStartRadius
   
    */
   float lightEndRadius;
   /*!
   @brief Initial color of the PointLight created by this explosion.

Color is linearly interpolated from lightStartColor to lightEndColor over the lifetime of the explosion.
@see lifetimeMS
   
    */
   ColorF lightStartColor;
   /*!
   @brief Final color of the PointLight created by this explosion.

@see lightStartColor
   
    */
   ColorF lightEndColor;
   /*!
   @brief Initial brightness of the PointLight created by this explosion.

Brightness is linearly interpolated from lightStartBrightness to lightEndBrightness over the lifetime of the explosion.
@see lifetimeMS
   
    */
   float lightStartBrightness;
   /*!
   @brief Final brightness of the PointLight created by this explosion.

@see lightStartBrightness
   
    */
   float lightEndBrightness;
   /*!
   Distance (in the explosion normal direction) of the PointLight position from the explosion center.
   
    */
   float lightNormalOffset;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An emitter to replicate fxFoliageItem objects across an area.
@ingroup Foliage
 */
class  fxFoliageReplicator : public SceneObject {
  public:

   /*! @name Debugging
   @{ */
   /*! */
   /*!
   Culling bins are drawn when set to true.
   
    */
   bool UseDebugInfo;
   /*!
   Height multiplier for drawn culling bins.
   
    */
   float DebugBoxHeight;
   /*!
   Foliage is hidden when set to true.
   
    */
   bool HideFoliage;
   /*!
   Draw placement rings when set to true.
   
    */
   bool ShowPlacementArea;
   /*!
   Height of the placement ring in world units.
   
    */
   int PlacementAreaHeight;
   /*!
   Color of the placement ring.
   
    */
   ColorF PlacementColour;
   /// @}


   /*! @name Media
   @{ */
   /*! */
   /*!
   Random seed for foliage placement.
   
    */
   int seed;
   /*!
   Image file for the foliage texture.
   
    */
   filename FoliageFile;
   /*!
   Maximum foliage instance count.
   
    */
   int FoliageCount;
   /*!
   Number of times to try placing a foliage instance before giving up.
   
    */
   int FoliageRetries;
   /// @}


   /*! @name Area
   @{ */
   /*! */
   /*!
   Placement area inner radius on the X axis
   
    */
   int InnerRadiusX;
   /*!
   Placement area inner radius on the Y axis
   
    */
   int InnerRadiusY;
   /*!
   Placement area outer radius on the X axis
   
    */
   int OuterRadiusX;
   /*!
   Placement area outer radius on the Y axis
   
    */
   int OuterRadiusY;
   /// @}


   /*! @name Dimensions
   @{ */
   /*! */
   /*!
   Minimum width of foliage billboards
   
    */
   float MinWidth;
   /*!
   Maximum width of foliage billboards
   
    */
   float MaxWidth;
   /*!
   Minimum height of foliage billboards
   
    */
   float MinHeight;
   /*!
   Maximum height of foliage billboards
   
    */
   float MaxHeight;
   /*!
   Maintain aspect ratio of image if true. This option ignores MaxWidth.
   
    */
   bool FixAspectRatio;
   /*!
   Use only MaxWidth and MaxHeight for billboard size. Ignores MinWidth and MinHeight.
   
    */
   bool FixSizeToMax;
   /*!
   Offset billboards by this amount vertically.
   
    */
   float OffsetZ;
   /*!
   Randomly flip billboards left-to-right.
   
    */
   bool RandomFlip;
   /*!
   Use camera facing billboards ( including the z axis ).
   
    */
   bool useTrueBillboards;
   /// @}


   /*! @name Culling
   @{ */
   /*! */
   /*!
   Use culling bins when enabled.
   
    */
   bool UseCulling;
   /*!
   Minimum size of culling bins.  Must be >= 8 and <= OuterRadius.
   
    */
   int CullResolution;
   /*!
   Maximum distance from camera where foliage appears.
   
    */
   float ViewDistance;
   /*!
   Minimum distance from camera where foliage appears.
   
    */
   float ViewClosest;
   /*!
   Region beyond ViewDistance where foliage fades in/out.
   
    */
   float FadeInRegion;
   /*!
   Region before ViewClosest where foliage fades in/out.
   
    */
   float FadeOutRegion;
   /*!
   Minimum alpha value allowed on foliage instances.
   
    */
   float AlphaCutoff;
   /*!
   Alpha of the foliage at ground level. 0 = transparent, 1 = opaque.
   
    */
   float GroundAlpha;
   /// @}


   /*! @name Animation
   @{ */
   /*! */
   /*!
   Foliage should sway randomly when true.
   
    */
   bool SwayOn;
   /*!
   Foliage instances should sway together when true and SwayOn is enabled.
   
    */
   bool SwaySync;
   /*!
   Left-to-right sway magnitude.
   
    */
   float SwayMagSide;
   /*!
   Front-to-back sway magnitude.
   
    */
   float SwayMagFront;
   /*!
   Minumum sway cycle time in seconds.
   
    */
   float MinSwayTime;
   /*!
   Maximum sway cycle time in seconds.
   
    */
   float MaxSwayTime;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Foliage should be illuminated with changing lights when true.
   
    */
   bool LightOn;
   /*!
   Foliage instances have the same lighting when set and LightOn is set.
   
    */
   bool LightSync;
   /*!
   Minimum luminance for foliage instances.
   
    */
   float MinLuminance;
   /*!
   Maximum luminance for foliage instances.
   
    */
   float MaxLuminance;
   /*!
   Time before foliage illumination cycle repeats.
   
    */
   float lightTime;
   /// @}


   /*! @name Restrictions
   @{ */
   /*! */
   /*!
   Foliage will be placed on terrain when set.
   
    */
   bool AllowOnTerrain;
   /*!
   Foliage will be placed on Static shapes when set.
   
    */
   bool AllowOnStatics;
   /*!
   Foliage will be placed on/under water when set.
   
    */
   bool AllowOnWater;
   /*!
   Foliage will be placed on water when set. Requires AllowOnWater.
   
    */
   bool AllowWaterSurface;
   /*!
   Maximum surface angle allowed for foliage instances.
   
    */
   int AllowedTerrainSlope;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An emitter for objects to replicate across an area.
@ingroup Foliage
 */
class  fxShapeReplicator : public SceneObject {
  public:

   /*! @name Debugging
   @{ */
   /*! */
   /*!
   Replicated shapes are hidden when set to true.
   
    */
   bool HideReplications;
   /*!
   Draw placement rings when set to true.
   
    */
   bool ShowPlacementArea;
   /*!
   Height of the placement ring in world units.
   
    */
   int PlacementAreaHeight;
   /*!
   Color of the placement ring.
   
    */
   ColorF PlacementColour;
   /// @}


   /*! @name Media
   @{ */
   /*! */
   /*!
   Filename of shape to replicate.
   
    */
   filename shapeFile;
   /// @}


   /*! @name Replications
   @{ */
   /*! */
   /*!
   Random seed for shape placement.
   
    */
   int seed;
   /*!
   Maximum shape instance count.
   
    */
   int ShapeCount;
   /*!
   Number of times to try placing a shape instance before giving up.
   
    */
   int ShapeRetries;
   /// @}


   /*! @name Placement Radius
   @{ */
   /*! */
   /*!
   Placement area inner radius on the X axis
   
    */
   int InnerRadiusX;
   /*!
   Placement area inner radius on the Y axis
   
    */
   int InnerRadiusY;
   /*!
   Placement area outer radius on the X axis
   
    */
   int OuterRadiusX;
   /*!
   Placement area outer radius on the Y axis
   
    */
   int OuterRadiusY;
   /// @}


   /*! @name Restraints
   @{ */
   /*! */
   /*!
   Shapes will be placed on terrain when set.
   
    */
   bool AllowOnTerrain;
   /*!
   Shapes will be placed on Static shapes when set.
   
    */
   bool AllowOnStatics;
   /*!
   Shapes will be placed on/under water when set.
   
    */
   bool AllowOnWater;
   /*!
   Shapes will be placed on water when set. Requires AllowOnWater.
   
    */
   bool AllowWaterSurface;
   /*!
   Align shapes to surface normal when set.
   
    */
   bool AlignToTerrain;
   /*!
   Allow physics interactions with shapes.
   
    */
   bool Interactions;
   /*!
   Maximum surface angle allowed for shape instances.
   
    */
   int AllowedTerrainSlope;
   /*!
   Surface normals will be multiplied by these values when AlignToTerrain is enabled.
   
    */
   Point3F TerrainAlignment;
   /// @}


   /*! @name Object Transforms
   @{ */
   /*! */
   /*!
   Minimum shape scale.
   
    */
   Point3F ShapeScaleMin;
   /*!
   Maximum shape scale.
   
    */
   Point3F ShapeScaleMax;
   /*!
   Minimum shape rotation angles.
   
    */
   Point3F ShapeRotateMin;
   /*!
   Maximum shape rotation angles.
   
    */
   Point3F ShapeRotateMax;
   /*!
   Offset shapes by this amount vertically.
   
    */
   int OffsetZ;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The object definition for shapes that will be replicated across an area using an fxShapeReplicator.
@ingroup Foliage
 */
class  fxShapeReplicatedStatic : public SceneObject {
  public:

   /*! @name Media
   @{ */
   /*! */
   /*!
   %Path and filename of the model file (.DTS, .DAE) to use for this TSStatic.
   
    */
   filename shapeName;
   /*!
   @brief The skin applied to the shape.

'Skinning' the shape effectively renames the material targets, allowing different materials to be used on different instances of the same model.

Any material targets that start with the old skin name have that part of the name replaced with the new skin name. The initial old skin name is "base". For example, if a new skin of "blue" was applied to a model that had material targets <i>base_body</i> and <i>face</i>, the new targets would be <i>blue_body</i> and <i>face</i>. Note that <i>face</i> was not renamed since it did not start with the old skin name of "base".

To support models that do not use the default "base" naming convention, you can also specify the part of the name to replace in the skin field itself. For example, if a model had a material target called <i>shapemat</i>, we could apply a new skin "shape=blue", and the material target would be renamed to <i>bluemat</i> (note "shape" has been replaced with "blue").

Multiple skin updates can also be applied at the same time by separating them with a semicolon. For example: "base=blue;face=happy_face".

Material targets are only renamed if an existing Material maps to that name, or if there is a diffuse texture in the model folder with the same name as the new target.


   
    */
   string skin;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   Enables automatic playing of the animation sequence named "ambient" (if it exists) when the TSStatic is loaded.
   
    */
   bool playAmbient;
   /*!
   Enables detailed culling of meshes within the TSStatic. Should only be used with large complex shapes like buildings which contain many submeshes.
   
    */
   bool meshCulling;
   /*!
   Enables translucent sorting of the TSStatic by its origin instead of the bounds.
   
    */
   bool originSort;
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /*!
   The type of mesh data to use for collision queries.
   
    */
   TSMeshType collisionType;
   /*!
   The type of mesh data used to clip decal polygons against.
   
    */
   TSMeshType decalType;
   /*!
   @brief Allow a Player to walk up sloping polygons in the TSStatic (based on the collisionType).

When set to false, the slightest bump will stop the player from walking on top of the object.

   
    */
   bool allowPlayerStep;
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /*!
   Debug rendering mode shows the normals for each point in the TSStatic's mesh.
   
    */
   float renderNormals;
   /*!
   Forces rendering to a particular detail level.
   
    */
   int forceDetail;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Covers the ground in a field of objects (IE: Grass, Flowers, etc).@ingroup Foliage
 */
class  GroundCover : public SceneObject {
  public:

   /*! @name GroundCover General
   @{ */
   /*! */
   /*!
   Material used by all GroundCover segments.
   
    */
   string Material;
   /*!
   Outer generation radius from the current camera position.
   
    */
   float radius;
   /*!
   This is less than or equal to radius and defines when fading of cover elements begins.
   
    */
   float dissolveRadius;
   /*!
   Scales the various culling radii when rendering a reflection. Typically for water.
   
    */
   float reflectScale;
   /*!
   The number of cells per axis in the grid.
   
    */
   int gridSize;
   /*!
   Offset along the Z axis to render the ground cover.
   
    */
   float zoffset;
   /*!
   This RNG seed is saved and sent to clients for generating the same cover.
   
    */
   int seed;
   /*!
   The maximum amount of cover elements to include in the grid at any one time.
   
    */
   int maxElements;
   /*!
   The maximum amout of degrees the billboard will tilt down to match the camera.
   
    */
   float maxBillboardTiltAngle;
   /*!
   This is the distance at which DTS elements are  completely culled out.
   
    */
   float shapeCullRadius;
   /*!
   Whether DTS elements should cast shadows or not.
   
    */
   bool shapesCastShadows;
   /*!
   Subset material UV coordinates for this cover billboard.
   
    */
   RectF billboardUVs;
   /*!
   The cover shape filename. [Optional]
   
    */
   filename shapeFilename;
   /*!
   Terrain material name to limit coverage to, or blank to not limit.
   
    */
   string layer;
   /*!
   Indicates that the terrain material index given in 'layer' is an exclusion mask.
   
    */
   bool invertLayer;
   /*!
   The probability of one cover type verses another (relative to all cover types).
   
    */
   float probability;
   /*!
   The minimum random size for each cover type.
   
    */
   float sizeMin;
   /*!
   The maximum random size of this cover type.
   
    */
   float sizeMax;
   /*!
   An exponent used to bias between the minimum and maximum random sizes.
   
    */
   float sizeExponent;
   /*!
   The wind effect scale.
   
    */
   float windScale;
   /*!
   The maximum slope angle in degrees for placement.
   
    */
   float maxSlope;
   /*!
   The minimum world space elevation for placement.
   
    */
   float minElevation;
   /*!
   The maximum world space elevation for placement.
   
    */
   float maxElevation;
   /*!
   The minimum amount of elements in a clump.
   
    */
   int minClumpCount;
   /*!
   The maximum amount of elements in a clump.
   
    */
   int maxClumpCount;
   /*!
   An exponent used to bias between the minimum and maximum clump counts for a particular clump.
   
    */
   float clumpExponent;
   /*!
   The maximum clump radius.
   
    */
   float clumpRadius;
   /// @}


   /*! @name GroundCover Wind
   @{ */
   /*! */
   /*!
   The direction of the wind.
   
    */
   Point2F windDirection;
   /*!
   The length in meters between peaks in the wind gust.
   
    */
   float windGustLength;
   /*!
   Controls how often the wind gust peaks per second.
   
    */
   float windGustFrequency;
   /*!
   The maximum distance in meters that the peak wind  gust will displace an element.
   
    */
   float windGustStrength;
   /*!
   Controls the overall rapidity of the wind turbulence.
   
    */
   float windTurbulenceFrequency;
   /*!
   The maximum distance in meters that the turbulence can displace a ground cover element.
   
    */
   float windTurbulenceStrength;
   /// @}


   /*! @name GroundCover Debug
   @{ */
   /*! */
   /*!
   Debug parameter for locking the culling frustum which will freeze the cover generation.
   
    */
   bool lockFrustum;
   /*!
   Debug parameter for displaying the grid cells.
   
    */
   bool renderCells;
   /*!
   Debug parameter for turning off billboard rendering.
   
    */
   bool noBillboards;
   /*!
   Debug parameter for turning off shape rendering.
   
    */
   bool noShapes;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Common data for a Lightning emitter object.
@see Lightning
@ingroup FX
@ingroup Atmosphere
@ingroup Datablocks
 */
class  LightningData : public GameBaseData {
  public:
   /*!
   Sound profile to play when a lightning strike occurs.
   
    */
   SFXTrack strikeSound;
   /*!
   @brief List of thunder sound effects to play.

A random one of these sounds will be played shortly after each strike occurs.
   
    */
   SFXTrack thunderSounds;
   /*!
   List of textures to use to render lightning strikes.
   
    */
   string strikeTextures;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Network event that triggers a lightning strike on the client when it is received.

This event is sent to all clients when the warningFlashes(), strikeRandomPoint() or strikeObject() methods are invoked on the Lightning object on the server.
@see Lightning, LightningData
@ingroup FX
@ingroup Atmosphere
 */
class  LightningStrikeEvent {
  public:
};

class  ParticleEmitterNodeData : public GameBaseData {
  public:
   /*!
   @brief Time multiplier for particle emitter nodes.

Increasing timeMultiple is like running the emitter at a faster rate - single-shot emitters will complete in a shorter time, and continuous emitters will generate particles more quickly.

Valid range is 0.01 - 100.
   
    */
   float timeMultiple;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  PBEvt {
  public:
};

/*!
@brief Defines the droplets used in a storm (raindrops, snowflakes, etc).

@tsexample
datablock PrecipitationData( HeavyRain )
{
   soundProfile = "HeavyRainSound";
   dropTexture = "art/environment/precipitation/rain";
   splashTexture = "art/environment/precipitation/water_splash";
   dropsPerSide = 4;
   splashesPerSide = 2;
};
@endtsexample
@ingroup FX
@ingroup Atmosphere
@see Precipitation
 */
class  PrecipitationData : public GameBaseData {
  public:
   /*!
   Looping SFXProfile effect to play while Precipitation is active.
   
    */
   SFXTrack soundProfile;
   /*!
   @brief Texture filename for drop particles.

The drop texture can contain several different drop sub-textures arranged in a grid. There must be the same number of rows as columns. A random frame will be chosen for each drop.
   
    */
   filename dropTexture;
   /*!
   The name of the shader used for raindrops.
   
    */
   string dropShader;
   /*!
   @brief Texture filename for splash particles.

The splash texture can contain several different splash sub-textures arranged in a grid. There must be the same number of rows as columns. A random frame will be chosen for each splash.
   
    */
   filename splashTexture;
   /*!
   The name of the shader used for splashes.
   
    */
   string splashShader;
   /*!
   @brief How many rows and columns are in the raindrop texture.

For example, if the texture has 16 raindrops arranged in a grid, this field should be set to 4.
   
    */
   int dropsPerSide;
   /*!
   @brief How many rows and columns are in the splash texture.

For example, if the texture has 9 splashes arranged in a grid, this field should be set to 3.
   
    */
   int splashesPerSide;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Acts as the physical point in space in white a Splash is created from.
@ingroup FX
 */
class  SplashData : public GameBaseData {
  public:
   /*!
   SFXProfile effect to play.

   
    */
   SFXProfile soundProfile;
   /*!
   The scale of this splashing effect, defined as the F32 points X, Y, Z.

   
    */
   Point3F scale;
   /*!
   List of particle emitters to create at the point of this Splash effect.

   
    */
   ParticleEmitterData emitter;
   /*!
   Time to delay, in milliseconds, before actually starting this effect.

   
    */
   int delayMS;
   /*!
   Time variance for delayMS.

   
    */
   int delayVariance;
   /*!
   Lifetime for this effect, in milliseconds.

   
    */
   int lifetimeMS;
   /*!
   Time variance for lifetimeMS.

   
    */
   int lifetimeVariance;
   /*!
   Width for the X and Y coordinates to create this effect within.
   
    */
   float width;
   /*!
   Number of ejection points in the splash ring.

   
    */
   int numSegments;
   /*!
   Velocity for the splash effect to travel.

   
    */
   float velocity;
   /*!
   Height for the splash to reach.

   
    */
   float height;
   /*!
   Constant acceleration value to place upon the splash effect.

   
    */
   float acceleration;
   /*!
   Times to transition through the splash effect. Up to 4 allowed. Values are 0.0 - 1.0, and corrispond to the life of the particle where 0 is first created and 1 is end of lifespace.

   
    */
   float times;
   /*!
   Color values to set the splash effect, rgba. Up to 4 allowed. Will transition through colors based on values set in the times value. Example: colors[0] = "0.6 1.0 1.0 0.5".

   
    */
   ColorF colors;
   /*!
   Imagemap file to use as the texture for the splash effect.

   
    */
   filename texture;
   /*!
   Amount to wrap the texture around the splash ring, 0.0f - 1.0f.

   
    */
   float texWrap;
   /*!
   Factor in which to apply the texture to the splash ring, 0.0f - 1.0f.

   
    */
   float texFactor;
   /*!
   Frequency in which to emit splash rings.

   
    */
   float ejectionFreq;
   /*!
   Rotational angle to create a splash ring.

   
    */
   float ejectionAngle;
   /*!
   Lifetime, in milliseconds, for a splash ring.

   
    */
   float ringLifetime;
   /*!
   Starting radius size of a splash ring.

   
    */
   float startRadius;
   /*!
   ExplosionData object to create at the creation position of this splash effect.

   
    */
   ExplosionData Explosion;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Manages the ring used for a Splash effect.
@ingroup FX
 */
class  Splash : public GameBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Use by GameConnection to process incoming datablocks.

Not intended for game development, internal use only, but does expose onDataBlockObjectReceived.

 */
class  SimDataBlockEvent {
  public:
};

/*!
@brief Use by GameConnection to send a 2D sound event over the network.

Not intended for game development, internal use only, but does expose GameConnection::play2D.

 */
class  Sim2DAudioEvent {
  public:
};

/*!
@brief Use by GameConnection to send a 3D sound event over the network.

Not intended for game development, internal use only, but does expose GameConnection::play3D.

 */
class  Sim3DAudioEvent {
  public:
};

/*!
@brief Use by GameConnection to send a 3D sound event over the network.

Not intended for game development, internal use only, but does expose GameConnection::setMissionCRC.

 */
class  SetMissionCRCEvent {
  public:
};

/*!
@brief Represents one or more rigid bodies defined in a single mesh file with a limited lifetime.

A PhysicsDebris object can be viewed as a single system capable of generating multiple @link PhysicsBody PhysicsBodies@endlink as debris when triggered. Vaguely similar to how a ParticleEmitter is capable of creating Particles, but isn't a particle in itself. After it's lifetime has elapsed, the object will be deleted.

%PhysicsDebris loads a standard .DAE or .DTS file and creates a rigid body for each defined collision node.

For collision nodes to work correctly, they must be setup as follows:
 - Visible mesh nodes are siblings of the collision node under a common parent dummy node.
 -  Collision node is a child of its visible mesh node.

Colmesh type nodes are NOT supported; physx and most standard rigid body simulations do not support arbitrary triangle meshs for dynamics do to the computational expense.

Therefore, collision nodes must be one of the following:
 - Colbox
 - Colsphere
 - Colcapsule
 - Col (convex).

%PhysicsDebris should NOT be created on the server.

 */
class  PhysicsDebris : public GameBase {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a PhysicsShape.

@see PhysicsShape.
 */
class  PhysicsShapeData : public GameBaseData {
  public:

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name Media
   @{ */
   /*! */
   /*!
   @brief Path to the .DAE or .DTS file to use for this shape.

Compatable with Live-Asset Reloading. 
   
    */
   filename shapeName;
   /*!
   @brief Name of a PhysicsDebrisData to spawn when this shape is destroyed (optional).
   
    */
   PhysicsDebrisData Debris;
   /*!
   @brief Name of an ExplosionData to spawn when this shape is destroyed (optional).
   
    */
   ExplosionData Explosion;
   /*!
   @brief Name of a PhysicsShapeData to spawn when this shape is destroyed (optional).
   
    */
   PhysicsShapeData destroyedShape;
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /*!
   @brief Value representing the mass of the shape.

A shape's mass influences the magnitude of any force exerted on it. For example, a PhysicsShape with a large mass requires a much larger force to move than the same shape with a smaller mass.
@note A mass of zero will create a kinematic shape while anything greater will create a dynamic shape.
   
    */
   float mass;
   /*!
   @brief Coefficient of kinetic %friction to be applied to the shape.

Kinetic %friction reduces the velocity of a moving object while it is in contact with a surface. A higher coefficient will result in a larger velocity reduction. A shape's friction should be lower than it's staticFriction, but larger than 0.

@note This value is only applied while an object is in motion. For an object starting at rest, see PhysicsShape::staticFriction
   
    */
   float friction;
   /*!
   @brief Coefficient of static %friction to be applied to the shape.

Static %friction determines the force needed to start moving an at-rest object in contact with a surface. If the force applied onto shape cannot overcome the force of static %friction, the shape will remain at rest. A larger coefficient will require a larger force to start motion. This value should be larger than zero and the physicsShape's friction.

@note This value is only applied while an object is at rest. For an object in motion, see PhysicsShape::friction
   
    */
   float staticFriction;
   /*!
   @brief Coeffecient of a bounce applied to the shape in response to a collision.

Restitution is a ratio of a shape's velocity before and after a collision. A value of 0 will zero out a shape's post-collision velocity, making it stop on contact. Larger values will remove less velocity after a collision, making it 'bounce' with a greater force. Normal %restitution values range between 0 and 1.0.@note Values near or equaling 1.0 are likely to cause undesirable results in the physics simulation. Because of this it is reccomended to avoid values close to 1.0
   
    */
   float restitution;
   /*!
   @brief Value that reduces an object's linear velocity over time.

Larger values will cause velocity to decay quicker.


   
    */
   float linearDamping;
   /*!
   @brief Value that reduces an object's rotational velocity over time.

Larger values will cause velocity to decay quicker.


   
    */
   float angularDamping;
   /*!
   @brief Minimum linear velocity before the shape can be put to sleep.

This should be a positive value. Shapes put to sleep will not be simulated in order to save system resources.

@note The shape must be dynamic.
   
    */
   float linearSleepThreshold;
   /*!
   @brief Minimum rotational velocity before the shape can be put to sleep.

This should be a positive value. Shapes put to sleep will not be simulated in order to save system resources.

@note The shape must be dynamic.
   
    */
   float angularSleepThreshold;
   /*!
   @brief Scale to apply to linear and angular dampening while underwater.

 Used with the waterViscosity of the  @see angularDamping linearDamping
   
    */
   float waterDampingScale;
   /*!
   @brief The density of the shape for calculating buoyant forces.

The result of the calculated buoyancy is relative to the density of the WaterObject the PhysicsShape is within.

@see WaterObject::density
   
    */
   float buoyancyDensity;
   /// @}


   /*! @name Networking
   @{ */
   /*! */
   /*!
   @brief Controls whether this shape is simulated on the server, client, or both physics simulations.


   
    */
   PhysicsSimType simType;
   /// @}

};

/*!
@brief A volume in space that defines an ambient sound zone.

 */
class  SFXSpace : public SceneObject {
  public:

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Ambient sound environment for the space.
   
    */
   SFXAmbience soundAmbience;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   For internal use only.
   
    */
   string plane;
   /*!
   For internal use only.
   
    */
   string point;
   /*!
   For internal use only.
   
    */
   string edge;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines properties for a TurretShape object.

@see TurretShape
@see TurretShapeData
@ingroup gameObjects
 */
class  TurretShapeData : public ItemData {
  public:
      /*! @brief Informs the TurretShapeData object that a player is mounting it.

@param turret The TurretShape object.
@param obj The player that is mounting.
@param node The node the player is mounting to.
@note Server side only.
 */
      void onMountObject( TurretShape turret, SceneObject obj, int node );

      /*! @brief Informs the TurretShapeData object that a player is unmounting it.

@param turret The TurretShape object.
@param obj The player that is unmounting.
@note Server side only.
 */
      void onUnmountObject( TurretShape turret, SceneObject obj );

      /*! @brief Informs the TurretData object that it is now sticking to another object.

This callback is only called if the TurretData::sticky property for this Turret is true.
@param obj The Turret object that is colliding.
@note Server side only.
@see TurretShape, TurretData
 */
      void onStickyCollision( TurretShape obj );

   /*!
   @brief Should the turret allow only z rotations.

True indicates that the turret may only be rotated on its z axis, just like the Item class.  This keeps the turret always upright regardless of the surface it lands on.

   
    */
   bool zRotOnly;
   /*!
   @brief Set how the mounted weapons are linked and triggered.

<ul><li>FireTogether: All weapons fire under trigger 0.</li><li>GroupedFire: Weapon mounts 0,2 fire under trigger 0, mounts 1,3 fire under trigger 1.</li><li>IndividualFire: Each weapon mount fires under its own trigger 0-3.</li></ul>
@see TurretShapeFireLinkType
   
    */
   TurretShapeFireLinkType weaponLinkType;
   /*!
   @brief Does the turret's mounted weapon(s) start in a loaded state.

True indicates that all mounted weapons start in a loaded state.
@see ShapeBase::setImageLoaded()
   
    */
   bool startLoaded;
   /*!
   Vertical (Z axis) height of the camera above the turret.
   
    */
   float cameraOffset;
   /*!
   @brief Maximum number of degrees to rotate from center.

A value of 180 or more degrees indicates the turret may rotate completely around.

   
    */
   float maxHeading;
   /*!
   @brief Minimum number of degrees to rotate down from straight ahead.


   
    */
   float minPitch;
   /*!
   @brief Maximum number of degrees to rotate up from straight ahead.


   
    */
   float maxPitch;
   /*!
   @brief Degrees per second rotation.

A value of 0 means no rotation is allowed.  A value less than 0 means the rotation is instantaneous.

   
    */
   float headingRate;
   /*!
   @brief Degrees per second rotation.

A value of 0 means no rotation is allowed.  A value less than 0 means the rotation is instantaneous.

   
    */
   float pitchRate;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines properties for an AITurretShape object.

@see AITurretShape
@see TurretShapeData
@ingroup gameObjects
 */
class  AITurretShapeData : public TurretShapeData {
  public:
   /*!
   @brief Maximum number of degrees to scan left and right.

@note Maximum scan heading is 90 degrees.

   
    */
   float maxScanHeading;
   /*!
   @brief Maximum number of degrees to scan up and down.

@note Maximum scan pitch is 90 degrees.

   
    */
   float maxScanPitch;
   /*!
   @brief Maximum distance to scan.

When combined with maxScanHeading and maxScanPitch this forms a 3D scanning wedge used to initially locate a target.

   
    */
   float maxScanDistance;
   /*!
   @brief How often should we perform a full scan when looking for a target.

Expressed as the number of ticks between full scans, but no less than 1.

   
    */
   int scanTickFrequency;
   /*!
   @brief Random amount that should be added to the scan tick frequency each scan period.

Expressed as the number of ticks to randomly add, but no less than zero.

   
    */
   int scanTickFrequencyVariance;
   /*!
   @brief How long after the turret has lost the target should it still track it.

Expressed in seconds.

   
    */
   float trackLostTargetTime;
   /*!
   @brief Maximum distance that the weapon will fire upon a target.


   
    */
   float maxWeaponRange;
   /*!
   @brief Velocity used to lead target.

If value <= 0, don't lead target.

   
    */
   float weaponLeadVelocity;
   /*!
   Name of this state.
   
    */
   caseString stateName;
   /*!
   Name of the state to transition to when the turret is at rest (static).
   
    */
   string stateTransitionOnAtRest;
   /*!
   Name of the state to transition to when the turret is not at rest (not static).
   
    */
   string stateTransitionOnNotAtRest;
   /*!
   Name of the state to transition to when the turret gains a target.
   
    */
   string stateTransitionOnTarget;
   /*!
   Name of the state to transition to when the turret loses a target.
   
    */
   string stateTransitionOnNoTarget;
   /*!
   Name of the state to transition to when the turret goes from deactivated to activated.
   
    */
   string stateTransitionOnActivated;
   /*!
   Name of the state to transition to when the turret goes from activated to deactivated
   
    */
   string stateTransitionOnDeactivated;
   /*!
   Name of the state to transition to when we have been in this state for stateTimeoutValue seconds.
   
    */
   string stateTransitionOnTimeout;
   /*!
   Time in seconds to wait before transitioning to stateTransitionOnTimeout.
   
    */
   float stateTimeoutValue;
   /*!
   If false, this state ignores stateTimeoutValue and transitions immediately if other transition conditions are met.
   
    */
   bool stateWaitForTimeout;
   /*!
   The first state with this set to true is the state entered by the client when it receives the 'fire' event.
   
    */
   bool stateFire;
   /*!
   Indicates the turret should perform a continuous scan looking for targets.
   
    */
   bool stateScan;
   /*!
   @brief Direction of the animation to play in this state.

True is forward, false is backward.
   
    */
   bool stateDirection;
   /*!
   Name of the sequence to play on entry to this state.
   
    */
   string stateSequence;
   /*!
   If true, the timeScale of the stateSequence animation will be adjusted such that the sequence plays for stateTimeoutValue seconds. 
   
    */
   bool stateScaleAnimation;
   /*!
   @brief Method to execute on entering this state.

Scoped to AITurretShapeData.
   
    */
   caseString stateScript;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base properties shared by all Vehicles (FlyingVehicle, HoverVehicle, WheeledVehicle).

This datablock defines properties shared by all Vehicle types, but should not be instantiated directly. Instead, set the desired properties in the FlyingVehicleData, HoverVehicleData or WheeledVehicleData datablock.
@section VehicleData_damage Damage

The VehicleData class extends the basic energy/damage functionality provided by ShapeBaseData to include damage from collisions, as well as particle emitters activated automatically when damage levels reach user specified thresholds.

The example below shows how to setup a Vehicle to:
<ul>
  <li>take damage when colliding with another object
  <li>emit gray smoke particles from two locations on the Vehicle when damaged above 50%</li>
  <li>emit black smoke particles from two locations on the Vehicle when damaged above 85%</li>
  <li>emit bubbles when any active damage emitter point is underwater</li>
</ul>

@tsexample
// damage from collisions
collDamageMultiplier = 0.05;
collDamageThresholdVel = 15;

// damage levels
damageLevelTolerance[0] = 0.5;
damageEmitter[0] = GraySmokeEmitter;     // emitter used when damage is >= 50%
damageLevelTolerance[1] = 0.85;
damageEmitter[1] = BlackSmokeEmitter;    // emitter used when damage is >= 85%
damageEmitter[2] = DamageBubbleEmitter;  // emitter used instead of damageEmitter[0:1]
                                         // when offset point is underwater
// emit offsets (used for all active damage level emitters)
damageEmitterOffset[0] = "0.5 3 1";
damageEmitterOffset[1] = "-0.5 3 1";
numDmgEmitterAreas = 2;
@endtsexample
@ingroup Vehicles
 */
class  VehicleData : public ShapeBaseData {
  public:
      /*! Called when the vehicle enters liquid.
@param obj the Vehicle object
@param coverage percentage of the vehicle's bounding box covered by the liquid
@param type type of liquid the vehicle has entered
 */
      void onEnterLiquid( Vehicle obj, float coverage, string type );

      /*! Called when the vehicle leaves liquid.
@param obj the Vehicle object
@param type type of liquid the vehicle has left
 */
      void onLeaveLiquid( Vehicle obj, string type );

   /*!
   @brief Additional force applied to the vehicle when it is jetting.

For WheeledVehicles, the force is applied in the forward direction. For FlyingVehicles, the force is applied in the thrust direction.
   
    */
   float jetForce;
   /*!
   @brief Energy amount to drain for each tick the vehicle is jetting.

Once the vehicle's energy level reaches 0, it will no longer be able to jet.
   
    */
   float jetEnergyDrain;
   /*!
   Minimum vehicle energy level to begin jetting.
   
    */
   float minJetEnergy;
   /*!
   Rate at which the vehicle's steering returns to forwards when it is moving.
   
    */
   float steeringReturn;
   /*!
   Amount of effect the vehicle's speed has on its rate of steering return.
   
    */
   float steeringReturnSpeedScale;
   /*!
   If true, steering does not auto-centre while the vehicle is being steered by its driver.
   
    */
   bool powerSteering;
   /*!
   Defines the vehicle's center of mass (offset from the origin of the model).
   
    */
   Point3F massCenter;
   /*!
   @brief Define the box used to estimate the vehicle's moment of inertia.

Currently only used by WheeledVehicle; other vehicle types use a unit sphere to compute inertia.
   
    */
   Point3F massBox;
   /*!
   Collision 'bounciness'.
Normally in the range 0 (not bouncy at all) to 1 (100% bounciness).
   
    */
   float bodyRestitution;
   /*!
   Collision friction coefficient.
How well this object will slide against objects it collides with.
   
    */
   float bodyFriction;
   /*!
   @brief Sound to play on a 'soft' impact.

This sound is played if the impact speed is < hardImpactSpeed and >= softImpactSpeed.

@see softImpactSpeed
   
    */
   SFXProfile softImpactSound;
   /*!
   @brief Sound to play on a 'hard' impact.

This sound is played if the impact speed >= hardImpactSpeed.

@see hardImpactSpeed
   
    */
   SFXProfile hardImpactSound;
   /*!
   Minimum collision speed for the onImpact callback to be invoked.
   
    */
   float minImpactSpeed;
   /*!
   Minimum collision speed for the softImpactSound to be played.
   
    */
   float softImpactSpeed;
   /*!
   Minimum collision speed for the hardImpactSound to be played.
   
    */
   float hardImpactSpeed;
   /*!
   Unused
   
    */
   float minRollSpeed;
   /*!
   Maximum yaw (horizontal) and pitch (vertical) steering angle in radians.
   
    */
   float maxSteeringAngle;
   /*!
   Maximum drag coefficient.
Currently unused.
   
    */
   float maxDrag;
   /*!
   Minimum drag coefficient.
Currently only used by FlyingVehicle.
   
    */
   float minDrag;
   /*!
   Number of integration steps per tick.
Increase this to improve simulation stability (also increases simulation processing time).
   
    */
   int integration;
   /*!
   Minimum distance between objects for them to be considered as colliding.
   
    */
   float collisionTol;
   /*!
   Maximum relative velocity between objects for collisions to be resolved as contacts.
Velocities greater than this are handled as collisions.
   
    */
   float contactTol;
   /*!
   If true, the camera will roll with the vehicle. If false, the camera will always have the positive Z axis as up.
   
    */
   bool cameraRoll;
   /*!
   @brief How much the camera lags behind the vehicle depending on vehicle speed.

Increasing this value will make the camera fall further behind the vehicle as it accelerates away.

@see cameraDecay.
   
    */
   float cameraLag;
   /*!
   How quickly the camera moves back towards the vehicle when stopped.

@see cameraLag.
   
    */
   float cameraDecay;
   /*!
   Vertical (Z axis) height of the camera above the vehicle.
   
    */
   float cameraOffset;
   /*!
   Dust particle emitter.

@see triggerDustHeight

@see dustHeight
   
    */
   ParticleEmitterData dustEmitter;
   /*!
   @brief Maximum height above surface to emit dust particles.

If the vehicle is less than triggerDustHeight above a static surface with a material that has 'showDust' set to true, the vehicle will emit particles from the dustEmitter.
   
    */
   float triggerDustHeight;
   /*!
   Height above ground at which to emit particles from the dustEmitter.
   
    */
   float dustHeight;
   /*!
   @brief Array of particle emitters used to generate damage (dust, smoke etc) effects.

Currently, the first two emitters (indices 0 and 1) are used when the damage level exceeds the associated damageLevelTolerance. The 3rd emitter is used when the emitter point is underwater.

@see damageEmitterOffset
   
    */
   ParticleEmitterData damageEmitter;
   /*!
   @brief Object space "x y z" offsets used to emit particles for the active damageEmitter.

@tsexample
// damage levels
damageLevelTolerance[0] = 0.5;
damageEmitter[0] = SmokeEmitter;
// emit offsets (used for all active damage level emitters)
damageEmitterOffset[0] = "0.5 3 1";
damageEmitterOffset[1] = "-0.5 3 1";
numDmgEmitterAreas = 2;
@endtsexample

   
    */
   Point3F damageEmitterOffset;
   /*!
   @brief Damage levels (as a percentage of maxDamage) above which to begin emitting particles from the associated damageEmitter.

Levels should be in order of increasing damage.

@see damageEmitterOffset
   
    */
   float damageLevelTolerance;
   /*!
   Number of damageEmitterOffset values to use for each damageEmitter.

@see damageEmitterOffset
   
    */
   float numDmgEmitterAreas;
   /*!
   Array of particle emitters used to generate splash effects.
   
    */
   ParticleEmitterData splashEmitter;
   /*!
   @brief Number of splash particles to generate based on vehicle speed.

This value is multiplied by the current speed to determine how many particles to generate each frame.
   
    */
   float splashFreqMod;
   /*!
   Minimum speed when moving through water to generate splash particles.
   
    */
   float splashVelEpsilon;
   /*!
   Minimum velocity when leaving the water for the exitingWater sound to play.
   
    */
   float exitSplashSoundVelocity;
   /*!
   Minimum velocity when entering the water for the imapactWaterEasy sound to play.

@see impactWaterEasy
   
    */
   float softSplashSoundVelocity;
   /*!
   Minimum velocity when entering the water for the imapactWaterMedium sound to play.

@see impactWaterMedium
   
    */
   float mediumSplashSoundVelocity;
   /*!
   Minimum velocity when entering the water for the imapactWaterHard sound to play.

@see impactWaterHard
   
    */
   float hardSplashSoundVelocity;
   /*!
   Sound to play when exiting the water.
   
    */
   SFXProfile exitingWater;
   /*!
   Sound to play when entering the water with speed >= softSplashSoundVelocity and < mediumSplashSoundVelocity.
   
    */
   SFXProfile impactWaterEasy;
   /*!
   Sound to play when entering the water with speed >= mediumSplashSoundVelocity and < hardSplashSoundVelocity.
   
    */
   SFXProfile impactWaterMedium;
   /*!
   Sound to play when entering the water with speed >= hardSplashSoundVelocity.
   
    */
   SFXProfile impactWaterHard;
   /*!
   Looping sound to play while moving through the water.
   
    */
   SFXProfile waterWakeSound;
   /*!
   Minimum collision velocity to cause damage to this vehicle.
Currently unused.
   
    */
   float collDamageThresholdVel;
   /*!
   @brief Damage to this vehicle after a collision (multiplied by collision velocity).

Currently unused.
   
    */
   float collDamageMultiplier;
   /*!
   Sets how extended move absolute rotations affect the vehicle
when in 1st person camera mode.

If set to 'TurnCamera', the rotations turn the camera view.
If set to 'TurnVehicle', the rotations turn the vehicle.
If set to 'NoTracking', the rotations have no effect.
   
    */
   AbsRotationTrackMode fpAbsRotationMode;
   /*!
   Sets how extended move absolute rotations affect the vehicle
when in 3rd person camera mode.

If set to 'TurnCamera', the rotations turn the camera view.
If set to 'TurnVehicle', the rotations turn the vehicle.
If set to 'NoTracking', the rotations have no effect.
   
    */
   AbsRotationTrackMode tpAbsRotationMode;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a FlyingVehicle.

@ingroup Vehicles
 */
class  FlyingVehicleData : public VehicleData {
  public:
   /*!
   Looping sound to play while the vehicle is jetting.
   
    */
   SFXProfile jetSound;
   /*!
   Looping engine sound.
   
    */
   SFXProfile engineSound;
   /*!
   @brief Maximum X and Y (horizontal plane) maneuvering force.

The actual force applied depends on the current thrust.
   
    */
   float maneuveringForce;
   /*!
   @brief Damping force in the opposite direction to sideways velocity.

Provides "bite" into the wind for climbing/diving and turning).
   
    */
   float horizontalSurfaceForce;
   /*!
   @brief Damping force in the opposite direction to vertical velocity.

Controls side slip; lower numbers give more slide.
   
    */
   float verticalSurfaceForce;
   /*!
   Multiplier applied to the jetForce (defined in VehicleData) when thrusting vertically.
   
    */
   float vertThrustMultiple;
   /*!
   @brief Maximum X and Z (sideways and vertical) steering force.

The actual force applied depends on the current steering input.
   
    */
   float steeringForce;
   /*!
   Roll force induced by sideways steering input value (controls how much the vehicle rolls when turning).
   
    */
   float steeringRollForce;
   /*!
   @brief Damping torque against rolling maneuvers (rotation about the y-axis), proportional to linear velocity.

Acts to adjust roll to a stable position over time as the vehicle moves.
   
    */
   float rollForce;
   /*!
   Rotational drag factor (slows vehicle rotation speed in all axes).
   
    */
   float rotationalDrag;
   /*!
   Maximum speed for automatic vehicle control assistance - vehicles travelling at speeds above this value do not get control assitance.
   
    */
   float maxAutoSpeed;
   /*!
   @brief Scale factor applied to steering input if speed is less than maxAutoSpeed to.improve handling at very low speeds.

Smaller values make steering less sensitive.
   
    */
   float autoInputDamping;
   /*!
   @brief Corrective force applied to slow the vehicle when moving at less than maxAutoSpeed.

The force is inversely proportional to vehicle speed.
   
    */
   float autoLinearForce;
   /*!
   @brief Corrective torque applied to level out the vehicle when moving at less than maxAutoSpeed.

The torque is inversely proportional to vehicle speed.
   
    */
   float autoAngularForce;
   /*!
   The vehicle's height off the ground when at rest.
   
    */
   float hoverHeight;
   /*!
   @brief The vehicle's height off the ground when useCreateHeight is active.

This can help avoid problems with spawning the vehicle.
   
    */
   float createHoverHeight;
   /*!
   @brief Emitter to generate particles for forward jet thrust.

Forward jet thrust particles are emitted from model nodes JetNozzle0 and JetNozzle1.
   
    */
   ParticleEmitterData forwardJetEmitter;
   /*!
   @brief Emitter to generate particles for backward jet thrust.

Backward jet thrust particles are emitted from model nodes JetNozzleX and JetNozzleY.
   
    */
   ParticleEmitterData backwardJetEmitter;
   /*!
   @brief Emitter to generate particles for downward jet thrust.

Downward jet thrust particles are emitted from model nodes JetNozzle2 and JetNozzle3.
   
    */
   ParticleEmitterData downJetEmitter;
   /*!
   Emitter to generate contrail particles from model nodes contrail0 - contrail3.
   
    */
   ParticleEmitterData trailEmitter;
   /*!
   Minimum speed at which to start generating contrail particles.
   
    */
   float minTrailSpeed;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Displays the speed of the current Vehicle based control object.

This control only works if a server connection exists, and its control object is a Vehicle derived class. If either of these requirements is false, the control is not rendered.<br>The control renders the speedometer needle as a colored quad, rotated to indicate the Vehicle speed as determined by the <i>minAngle</i>, <i>maxAngle</i>, and <i>maxSpeed</i> properties. This control is normally placed on top of a GuiBitmapCtrl representing the speedometer dial.

@tsexample
new GuiSpeedometerHud()
{
   maxSpeed = "100";
   minAngle = "215";
   maxAngle = "0";
   color = "1 0.3 0.3 1";
   center = "130 123";
   length = "100";
   width = "2";
   tail = "0";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiSpeedometerHud : public GuiBitmapCtrl {
  public:

   /*! @name Needle
   @{ */
   /*! */
   /*!
   Maximum Vehicle speed (in Torque units per second) to represent on the speedo (Vehicle speeds greater than this are clamped to maxSpeed).
   
    */
   float maxSpeed;
   /*!
   Angle (in radians) of the needle when the Vehicle speed is 0. An angle of 0 points right, 90 points up etc).
   
    */
   float minAngle;
   /*!
   Angle (in radians) of the needle when the Vehicle speed is >= maxSpeed. An angle of 0 points right, 90 points up etc).
   
    */
   float maxAngle;
   /*!
   Color of the needle
   
    */
   ColorF color;
   /*!
   Center of the needle, offset from the GuiSpeedometerHud control top left corner
   
    */
   Point2F center;
   /*!
   Length of the needle from center to end
   
    */
   float length;
   /*!
   Width of the needle
   
    */
   float width;
   /*!
   Length of the needle from center to tail
   
    */
   float tail;
   /// @}


   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a HoverVehicle.

@ingroup Vehicles
 */
class  HoverVehicleData : public VehicleData {
  public:
   /*!
   Drag force factor that acts opposite to the vehicle velocity.
Also used to determnine the vehicle's maxThrustSpeed.
@see mainThrustForce
   
    */
   float dragForce;
   /*!
   Scalar applied to the vertical portion of the velocity drag acting on the vehicle.
For the horizontal (X and Y) components of velocity drag, a factor of 0.25 is applied when the vehicle is floating, and a factor of 1.0 is applied when the vehicle is not floating. This velocity drag is multiplied by the vehicle's dragForce, as defined above, and the result is subtracted from it's movement force.
@note The vertFactor must be between 0.0 and 1.0 (inclusive).
   
    */
   float vertFactor;
   /*!
   Scalar applied to the vehicle's thrust force when the vehicle is floating.
@note The floatingThrustFactor must be between 0.0 and 1.0 (inclusive).
   
    */
   float floatingThrustFactor;
   /*!
   Force generated by thrusting the vehicle forward.
Also used to determine the maxThrustSpeed:

@tsexample
maxThrustSpeed = (mainThrustForce + strafeThrustForce) / dragForce;
@endtsexample

   
    */
   float mainThrustForce;
   /*!
   Force generated by thrusting the vehicle backward.
   
    */
   float reverseThrustForce;
   /*!
   Force generated by thrusting the vehicle to one side.
Also used to determine the vehicle's maxThrustSpeed.
@see mainThrustForce
   
    */
   float strafeThrustForce;
   /*!
   Scale factor applied to the vehicle's thrust force when jetting.
   
    */
   float turboFactor;
   /*!
   Length of the base stabalizer when travelling at minimum speed (0).
Each tick, the vehicle performs 2 raycasts (from the center back and center front of the vehicle) to check for contact with the ground. The base stabalizer length determines the length of that raycast; if neither raycast hit the ground, the vehicle is floating, stabalizer spring and ground normal forces are not applied.

<img src="images/hoverVehicle_forces.png">
@see stabSpringConstant
   
    */
   float stabLenMin;
   /*!
   Length of the base stabalizer when travelling at maximum speed (maxThrustSpeed).

@see stabLenMin

@see mainThrustForce
   
    */
   float stabLenMax;
   /*!
   Value used to generate stabalizer spring force. The force generated depends on stabilizer compression, that is how close the vehicle is to the ground proportional to current stabalizer length.

@see stabLenMin
   
    */
   float stabSpringConstant;
   /*!
   Damping spring force acting against changes in the stabalizer length.

@see stabLenMin
   
    */
   float stabDampingConstant;
   /*!
   Damping torque that acts against the vehicle's current angular momentum.
   
    */
   float gyroDrag;
   /*!
   Force generated in the ground normal direction when the vehicle is not floating (within stabalizer length from the ground).

@see stabLenMin
   
    */
   float normalForce;
   /*!
   Force generated to stabalize the vehicle (return it to neutral pitch/roll) when the vehicle is floating (more than stabalizer length from the ground.

@see stabLenMin
   
    */
   float restorativeForce;
   /*!
   Yaw (rotation about the Z-axis) force applied when steering in the x-axis direction.about the vehicle's Z-axis)
   
    */
   float steeringForce;
   /*!
   Roll (rotation about the Y-axis) force applied when steering in the x-axis direction.
   
    */
   float rollForce;
   /*!
   Pitch (rotation about the X-axis) force applied when steering in the y-axis direction.
   
    */
   float pitchForce;
   /*!
   Looping sound played when the vehicle is jetting.
   
    */
   SFXProfile jetSound;
   /*!
   Looping engine sound.
The volume is dynamically adjusted based on the current thrust level.
   
    */
   SFXProfile engineSound;
   /*!
   Looping sound played while the vehicle is floating.

@see stabMinLen
   
    */
   SFXProfile floatSound;
   /*!
   Emitter to generate particles for the vehicle's dust trail.
The trail of dust particles is generated only while the vehicle is moving.
   
    */
   ParticleEmitterData dustTrailEmitter;
   /*!
   "X Y Z" offset from the vehicle's origin from which to generate dust trail particles.
By default particles are emitted directly beneath the origin of the vehicle model.
   
    */
   Point3F dustTrailOffset;
   /*!
   Maximum height above surface to emit dust trail particles.
If the vehicle is less than triggerTrailHeight above a static surface with a material that has 'showDust' set to true, the vehicle will emit particles from the dustTrailEmitter.
   
    */
   float triggerTrailHeight;
   /*!
   Number of dust trail particles to generate based on vehicle speed.
The vehicle's speed is divided by this value to determine how many particles to generate each frame. Lower values give a more dense trail, higher values a more sparse trail.
   
    */
   float dustTrailFreqMod;
   /*!
   Scale factor applied to the vehicle gravitational force when the vehicle is floating.

@see stabLenMin
   
    */
   float floatingGravMag;
   /*!
   Force generated by braking.
The vehicle is considered to be braking if it is moving, but the throttle is off, and no left or right thrust is being applied. This force is only applied when the vehicle's velocity is less than brakingActivationSpeed.
   
    */
   float brakingForce;
   /*!
   Maximum speed below which a braking force is applied.

@see brakingForce
   
    */
   float brakingActivationSpeed;
   /*!
   Emitter to generate particles for forward jet thrust.
Forward jet thrust particles are emitted from model nodes JetNozzle0 and JetNozzle1.
   
    */
   ParticleEmitterData forwardJetEmitter;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base functionality shared by all Vehicles (FlyingVehicle, HoverVehicle, WheeledVehicle).

This object implements functionality shared by all Vehicle types, but should not be instantiated directly. Create a FlyingVehicle, HoverVehicle, or WheeledVehicle instead.
@note The model used for any Vehicle must include a collision mesh at detail size -1.
@ingroup Vehicles
 */
class  Vehicle : public ShapeBase {
  public:
   /*!
   When this flag is set, the vehicle will ignore throttle changes.
   
    */
   bool disableMove;

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A hovering vehicle.

A hover vehicle is a vehicle that maintains a specific distance between the vehicle and the ground at all times; unlike a flying vehicle which is free to ascend and descend at will.The model used for the HoverVehicle has the following requirements:
<dl><dt>Collision mesh</dt><dd>A convex collision mesh at detail size -1.</dd><dt>JetNozzle0-1 nodes</dt><dd>Particle emitter nodes used when thrusting forward.</dd><dt>JetNozzle2-3 nodes</dt><dd>Particle emitter nodes used when thrusting downward.</dd><dt>JetNozzleX node</dt><dd>Particle emitter node used when thrusting backward.</dd><dt>activateBack animation</dt><dd>Non-cyclic animation sequence played when the vehicle begins thrusting forwards.</dd><dt>maintainBack animation</dt><dd>Cyclic animation sequence played after activateBack when the vehicle continues thrusting forwards.</dd></dl>@ingroup Vehicles
 */
class  HoverVehicle : public Vehicle {
  public:

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Legacy class from Tribes, originally used for blocking Vehicle objects.

@note This is no longer useful and should be deprecated soon.

@internal
 */
class  VehicleBlocker : public SceneObject {
  public:
   /*!
    */
   Point3F dimensions;

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a WheeledVehicle tire.

Tires act as springs and generate lateral and longitudinal forces to move the vehicle. These distortion/spring forces are what convert wheel angular velocity into forces that act on the rigid body.
@ingroup Vehicles
 */
class  WheeledVehicleTire : public SimDataBlock {
  public:
   /*!
   The path to the shape to use for the wheel.
   
    */
   filename shapeFile;
   /*!
   The mass of the wheel.
Currently unused.
   
    */
   float mass;
   /*!
   @brief The radius of the wheel.

The radius is determined from the bounding box of the shape provided in the shapefile field, and does not need to be specified in script. The tire should be built with its hub axis along the object's Y-axis.
   
    */
   float radius;
   /*!
   Tire friction when the wheel is not slipping (has traction).
   
    */
   float staticFriction;
   /*!
   Tire friction when the wheel is slipping (no traction).
   
    */
   float kineticFriction;
   /*!
   Tire restitution.
Currently unused.
   
    */
   float restitution;
   /*!
   @brief Tire force perpendicular to the direction of movement.

Lateral force can in simple terms be considered left/right steering force. WheeledVehicles are acted upon by forces generated by their tires and the lateralForce measures the magnitude of the force exerted on the vehicle when the tires are deformed along the x-axis. With real wheeled vehicles, tires are constantly being deformed and it is the interplay of deformation forces which determines how a vehicle moves. In Torque's simulation of vehicle physics, tire deformation obviously can't be handled with absolute realism, but the interplay of a vehicle's velocity, its engine's torque and braking forces, and its wheels' friction, lateral deformation, lateralDamping, lateralRelaxation, longitudinal deformation, longitudinalDamping, and longitudinalRelaxation forces, along with its wheels' angular velocity are combined to create a robust real-time physical simulation.

For this field, the larger the value supplied for the lateralForce, the larger the effect steering maneuvers can have. In Torque tire forces are applied at a vehicle's wheel hubs.
   
    */
   float lateralForce;
   /*!
   Damping force applied against lateral forces generated by the tire.

@see lateralForce
   
    */
   float lateralDamping;
   /*!
   @brief Relaxing force applied against lateral forces generated by the tire.

The lateralRelaxation force measures how strongly the tire effectively un-deforms.

@see lateralForce
   
    */
   float lateralRelaxation;
   /*!
   @brief Tire force in the direction of movement.

Longitudinal force can in simple terms be considered forward/backward movement force. WheeledVehicles are acted upon by forces generated by their tires and the longitudinalForce measures the magnitude of the force exerted on the vehicle when the tires are deformed along the y-axis.

For this field, the larger the value, the larger the effect acceleration/deceleration inputs have.

@see lateralForce
   
    */
   float longitudinalForce;
   /*!
   Damping force applied against longitudinal forces generated by the tire.

@see longitudinalForce
   
    */
   float longitudinalDamping;
   /*!
   @brief Relaxing force applied against longitudinal forces generated by the tire.

The longitudinalRelaxation force measures how strongly the tire effectively un-deforms.

@see longitudinalForce
   
    */
   float longitudinalRelaxation;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a WheeledVehicle spring.

@ingroup Vehicles
 */
class  WheeledVehicleSpring : public SimDataBlock {
  public:
   /*!
   @brief Maximum spring length. ie. how far the wheel can extend from the root hub position.

This should be set to the vertical (Z) distance the hub travels in the associated spring animation.
   
    */
   float length;
   /*!
   @brief Maximum spring force (when compressed to minimum length, 0).

Increasing this will make the vehicle suspension ride higher (for a given vehicle mass), and also make the vehicle more bouncy when landing jumps.
   
    */
   float force;
   /*!
   @brief Force applied to slow changes to the extension of this spring.

Increasing this makes the suspension stiffer which can help stabilise bouncy vehicles.
   
    */
   float damping;
   /*!
   @brief Force applied to equalize extension of the spring on the opposite wheel.

This force helps to keep the suspension balanced when opposite wheels are at different heights.
   
    */
   float antiSwayForce;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a WheeledVehicle.

@ingroup Vehicles
 */
class  WheeledVehicleData : public VehicleData {
  public:
   /*!
   Looping sound played when the vehicle is jetting.
   
    */
   SFXTrack jetSound;
   /*!
   @brief Looping engine sound.

The pitch is dynamically adjusted based on the current engine RPM
   
    */
   SFXTrack engineSound;
   /*!
   @brief Looping sound played while any of the wheels is slipping.

The volume is dynamically adjusted based on how much the wheels are slipping.
   
    */
   SFXTrack squealSound;
   /*!
   Sound played when the wheels impact the ground.
Currently unused.
   
    */
   SFXTrack WheelImpactSound;
   /*!
   ParticleEmitterData datablock used to generate particles from each wheel when the vehicle is moving and the wheel is in contact with the ground.
   
    */
   ParticleEmitterData tireEmitter;
   /*!
   @brief Maximum linear velocity of each wheel.

This caps the maximum speed of the vehicle.
   
    */
   float maxWheelSpeed;
   /*!
   @brief Torque available from the engine at 100% throttle.

This controls vehicle acceleration. ie. how fast it will reach maximum speed.
   
    */
   float engineTorque;
   /*!
   @brief Braking torque applied by the engine when the throttle and brake are both 0.

This controls how quickly the vehicle will coast to a stop.
   
    */
   float engineBrake;
   /*!
   @brief Torque applied when braking.

This controls how fast the vehicle will stop when the brakes are applied.
   
    */
   float brakeTorque;

   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Object used for remote procedure calls.

Not intended for game development, for exposing ConsoleFunctions (such as commandToClient) only.

 */
class  RemoteCommandEvent {
  public:
};

/*!
@brief Legacy component system, soon to be deprecated.

Not intended for game development, for editors or internal use only.

 */
class  SimComponent : public NetObject {
  public:
   /*! %obj.addComponents( %compObjName, %compObjName2, ... );
Adds additional components to current list.
@param Up to 62 component names
@return Returns true on success, false otherwise. */
   virtual bool addComponents() {}
   /*! %obj.removeComponents( %compObjName, %compObjName2, ... );
Removes components by name from current list.
@param objNamex Up to 62 component names
@return Returns true on success, false otherwise. */
   virtual bool removeComponents() {}
   /*! Get the current component count
@return The number of components in the list as an integer */
   virtual int getComponentCount(()) {}
   /*! Get the component corresponding to the given index.
@param idx An integer index value corresponding to the desired component.
@return The id of the component at the given index as an integer */
   virtual int getComponent((idx)) {}
   /*! Sets or unsets the enabled flag
@param enabled Boolean value
@return No return value */
   virtual void setEnabled((enabled)) {}
   /*! Check whether SimComponent is currently enabled
@return true if enabled and false if not */
   virtual bool isEnabled(()) {}
   /*! Sets or unsets the template flag
@param template Boolean value
@return No return value */
   virtual void setIsTemplate((template)) {}
   /*! Check whether SimComponent is currently a template
@return true if is a template and false if not */
   virtual bool getIsTemplate(()) {}

   /*! @name Component
   @{ */
   /*! */
   /*!
   Places the object in a component set for later use in new levels.
   
    */
   bool Template;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This is a slightly more advanced component which will be used to demonstrate components which are dependent on other components.

Not intended for game development, for editors or internal use only.

 */
class  MoreAdvancedComponent : public SimComponent {
  public:

   /*! @name Component
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The purpose of this component is to provide a minimalistic component that exposes a simple, cached interface

Soon to be deprecated, internal only.

 */
class  SimpleComponent : public SimComponent {
  public:

   /*! @name Component
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Renders up to three layers of scrolling cloud-cover textures overhead.

%BasicClouds always renders overhead, following the camera. It is intended as part of the background of your level, rendering in front of Sky/Sun type objects and behind everything else.

The parameters controlling the rendering of each texture are refered to and grouped as 'layers'. They are rendered in sequential order, so, layer 1 obscures layer 0, and so on.

BasicClouds is not affected by scene lighting and is therefore not appropriate for scenes in which lighting radically changes, such as day/night.

 */
class  BasicClouds : public SceneObject {
  public:

   /*! @name BasicClouds
   @{ */
   /*! */
   /*!
   Enable or disable rendering of this layer.
   
    */
   bool layerEnabled;
   /*!
   Texture for this layer.
   
    */
   filename texture;
   /*!
   Texture repeat for this layer.
   
    */
   float texScale;
   /*!
   Texture scroll direction for this layer, relative to the world axis.
   
    */
   Point2F texDirection;
   /*!
   Texture scroll speed for this layer.
   
    */
   float texSpeed;
   /*!
   UV offset for this layer.
   
    */
   Point2F texOffset;
   /*!
   Abstract number which controls the curvature and height of the dome mesh
   
    */
   float height;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A layer of clouds which change shape over time and are affected by scene lighting.

%CloudLayer always renders overhead, following the camera. It is intended as part of the background of your level, rendering in front of Sky/Sun type objects and behind everything else.

The illusion of clouds forming and changing over time is controlled by the normal/opacity texture and the three sets of texture animation parameters. The texture is sampled three times.  The first sample defines overall cloud density, where clouds are likely to form and their general size and shape. The second two samples control how it changes over time; they are combined and used as modifiers to the first sample.

%CloudLayer is affected by scene lighting and is designed to be used in scenes with dynamic lighting or time of day changes.

 */
class  CloudLayer : public SceneObject {
  public:

   /*! @name CloudLayer
   @{ */
   /*! */
   /*!
   An RGBA texture which should contain normals and opacity (density).
   
    */
   filename texture;
   /*!
   Controls the texture repeat of this slot.
   
    */
   float texScale;
   /*!
   Controls the direction this slot scrolls.
   
    */
   Point2F texDirection;
   /*!
   Controls the speed this slot scrolls.
   
    */
   float texSpeed;
   /*!
   Base cloud color before lighting.
   
    */
   ColorF baseColor;
   /*!
   Brightness scale so CloudLayer can be overblown if desired.
   
    */
   float exposure;
   /*!
   Fraction of sky covered by clouds 0-1.
   
    */
   float coverage;
   /*!
   Overall scalar to texture scroll speed.
   
    */
   float windSpeed;
   /*!
   Abstract number which controls the curvature and height of the dome mesh.
   
    */
   float height;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for events used by node editors, like River

Editor use only.

 */
class  NodeListEvent {
  public:
};

/*!
@brief Sends messages to the Decal Road Editor

Editor use only.

 */
class  DecalRoadNodeEvent : public NodeListEvent {
  public:
};

/*!
@brief Sends messages to the Mesh Road Editor

Editor use only.

 */
class  MeshRoadNodeEvent : public NodeListEvent {
  public:
};

/*!
@brief Sends messages to the River Editor

Editor use only.

 */
class  RiverNodeEvent : public NodeListEvent {
  public:
};

/*!
@brief Abstract base class for representing a body of water.

%WaterObject is abstract and may not be created. It defines functionality shared by its derived classes.

%WaterObject exposes many fields for controlling it visual quality.

%WaterObject surface rendering has the following general features:
^- Waves represented by vertex undulation and user paramaters.
^- Ripples represented by a normal map and user parameters.
^- Refraction of underwater objects.
^- Dynamic planar reflection or static cubemap reflection.
^- Paramable water fog and color shift.

It will, however, look significantly different depending on the LightingManager that is active. With Basic Lighting, we do not have a prepass texture to lookup per-pixel depth and therefore cannot use our rendering techniques that depend on it.

In particular, the following field groups are not used under Basic Lighting:
^- Underwater Fogging 
^- Misc 
^- Distortion 
^- And foam related fields under the %WaterObject group.

%WaterObject also defines several fields for gameplay use and objects that support buoyancy.

 */
class  WaterObject : public SceneObject {
  public:

   /*! @name WaterObject
   @{ */
   /*! */
   /*!
   Affects buoyancy of an object, thus affecting the Z velocity of a player (jumping, falling, etc.
   
    */
   float density;
   /*!
   Affects drag force applied to an object submerged in this container.
   
    */
   float viscosity;
   /*!
   Liquid type of WaterBlock, such as water, ocean, lava Currently only Water is defined and used.
   
    */
   string liquidType;
   /*!
   Changes color of water fog.
   
    */
   ColorI baseColor;
   /*!
   Extent of fresnel affecting reflection fogging.
   
    */
   float fresnelBias;
   /*!
   Measures intensity of affect on reflection based on fogging.
   
    */
   float fresnelPower;
   /*!
   Power used for specularity on the water surface ( sun only ).
   
    */
   float specularPower;
   /*!
   Color used for specularity on the water surface ( sun only ).
   
    */
   ColorF specularColor;
   /*!
   When true the water colors don't react to changes to environment lighting.
   
    */
   bool emissive;
   /*!
   Direction waves flow toward shores.
   
    */
   Point2F waveDir;
   /*!
   Speed of water undulation.
   
    */
   float waveSpeed;
   /*!
   Height of water undulation.
   
    */
   float waveMagnitude;
   /*!
   Master variable affecting entire body of water's undulation
   
    */
   float overallWaveMagnitude;
   /*!
   Normal map used to simulate small surface ripples
   
    */
   filename rippleTex;
   /*!
   Modifies the direction of ripples on the surface.
   
    */
   Point2F rippleDir;
   /*!
   Modifies speed of surface ripples.
   
    */
   float rippleSpeed;
   /*!
   Intensifies the affect of the normal map applied to the surface.
   
    */
   Point2F rippleTexScale;
   /*!
   Intensifies the vertext modification of the surface.
   
    */
   float rippleMagnitude;
   /*!
   Master variable affecting entire surface
   
    */
   float overallRippleMagnitude;
   /*!
   Diffuse texture for foam in shallow water (advanced lighting only)
   
    */
   filename foamTex;
   /*!
   
   
    */
   Point2F foamDir;
   /*!
   
   
    */
   float foamSpeed;
   /*!
   applied to the surface.
   
    */
   Point2F foamTexScale;
   /*!
   
   
    */
   float foamOpacity;
   /*!
   
   
    */
   float overallFoamOpacity;
   /*!
   
   
    */
   float foamMaxDepth;
   /*!
   
   
    */
   float foamAmbientLerp;
   /*!
   
   
    */
   float foamRippleInfluence;
   /// @}


   /*! @name Reflect
   @{ */
   /*! */
   /*!
   Cubemap used instead of reflection texture if fullReflect is off.
   
    */
   string cubemap;
   /*!
   Enables dynamic reflection rendering.
   
    */
   bool fullReflect;
   /*!
   Overall scalar to the reflectivity of the water surface.
   
    */
   float reflectivity;
   /*!
   Affects the sort order of reflected objects.
   
    */
   float reflectPriority;
   /*!
   Affects the sort time of reflected objects.
   
    */
   int reflectMaxRateMs;
   /*!
   scale up or down the detail level for objects rendered in a reflection
   
    */
   float reflectDetailAdjust;
   /*!
   always use z up as the reflection normal
   
    */
   bool reflectNormalUp;
   /*!
   turn off reflection rendering when occluded (delayed).
   
    */
   bool useOcclusionQuery;
   /*!
   The texture size used for reflections (square)
   
    */
   int reflectTexSize;
   /// @}


   /*! @name Underwater Fogging
   @{ */
   /*! */
   /*!
   Intensity of underwater fogging.
   
    */
   float waterFogDensity;
   /*!
   Delta, or limit, applied to waterFogDensity.
   
    */
   float waterFogDensityOffset;
   /*!
   The depth in world units at which full darkening will be received, giving a wet look to objects underwater.
   
    */
   float wetDepth;
   /*!
   The refract color intensity scaled at wetDepth.
   
    */
   float wetDarkening;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   1D texture defining the base water color by depth
   
    */
   filename depthGradientTex;
   /*!
   Depth in world units, the max range of the color gradient texture.
   
    */
   float depthGradientMax;
   /// @}


   /*! @name Distortion
   @{ */
   /*! */
   /*!
   Determines start of distortion effect where water surface intersects the camera near plane.
   
    */
   float distortStartDist;
   /*!
   Max distance that distortion algorithm is performed. The lower, the more distorted the effect.
   
    */
   float distortEndDist;
   /*!
   Determines the scaling down of distortion in shallow water.
   
    */
   float distortFullDepth;
   /// @}


   /*! @name Basic Lighting
   @{ */
   /*! */
   /*!
   Relative opacity or transparency of the water surface.
   
    */
   float clarity;
   /*!
   Changes the color shading of objects beneath the water surface.
   
    */
   ColorI underwaterColor;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /*!
   Ambient sound environment when listener is submerged.
   
    */
   SFXAmbience soundAmbience;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A block shaped water volume defined by a 3D scale and orientation.

@see WaterObject for inherited functionality.

 */
class  WaterBlock : public WaterObject {
  public:

   /*! @name WaterBlock
   @{ */
   /*! */
   /*!
   Spacing between vertices in the WaterBlock mesh
   
    */
   float gridElementSize;
   /*!
   Duplicate of gridElementSize for backwards compatility
   
    */
   float gridSize;
   /// @}


   /*! @name WaterObject
   @{ */
   /*! */
   /// @}


   /*! @name Reflect
   @{ */
   /*! */
   /// @}


   /*! @name Underwater Fogging
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Distortion
   @{ */
   /*! */
   /// @}


   /*! @name Basic Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents a large body of water stretching to the horizon in all directions.

WaterPlane's position is defined only height, the z element of position, it is infinite in xy and depth. %WaterPlane is designed to represent the ocean on an island scene and viewed from ground level; other uses may not be appropriate and a WaterBlock may be used.

@see WaterObject for inherited functionality.

Limitations:

Because %WaterPlane cannot be projected exactly to the far-clip distance, other objects nearing this distance can have noticible artifacts as they clip through first the %WaterPlane and then the far plane.

To avoid this large objects should be positioned such that they will not line up with the far-clip from vantage points the player is expected to be. In particular, your TerrainBlock should be completely contained by the far-clip distance.

Viewing %WaterPlane from a high altitude with a tight far-clip distance will accentuate this limitation. %WaterPlane is primarily designed to be viewed from ground level.

 */
class  WaterPlane : public WaterObject {
  public:

   /*! @name WaterPlane
   @{ */
   /*! */
   /*!
   Spacing between vertices in the WaterBlock mesh
   
    */
   int gridSize;
   /*!
   Duplicate of gridElementSize for backwards compatility
   
    */
   float gridElementSize;
   /// @}


   /*! @name WaterObject
   @{ */
   /*! */
   /// @}


   /*! @name Reflect
   @{ */
   /*! */
   /// @}


   /*! @name Underwater Fogging
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Distortion
   @{ */
   /*! */
   /// @}


   /*! @name Basic Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for defining a type of ForestItem. It does not implement loading or rendering of the shapeFile.

 */
class  ForestItemData : public SimDataBlock {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name Media
   @{ */
   /*! */
   /*!
   Shape file for this item type
   
    */
   filename shapeFile;
   /*!
   Can other objects or spacial queries hit items of this type.
   
    */
   bool collidable;
   /*!
   Radius used during placement to ensure items are not crowded.
   
    */
   float radius;
   /// @}


   /*! @name Wind
   @{ */
   /*! */
   /*!
   Mass used in calculating spring forces on the trunk. Generally how springy a plant is.
   
    */
   float mass;
   /*!
   Rigidity used in calculating spring forces on the trunk. How much the plant resists the wind force
   
    */
   float rigidity;
   /*!
   Coefficient used in calculating spring forces on the trunk. How much the plant resists bending.
   
    */
   float tightnessCoefficient;
   /*!
   Coefficient used in calculating spring forces on the trunk. Causes oscillation and forces to decay faster over time.
   
    */
   float dampingCoefficient;
   /*!
   Overall scale to the effect of wind.
   
    */
   float windScale;
   /*!
   Overall bend amount of the tree trunk by wind and impacts.
   
    */
   float trunkBendScale;
   /*!
   Amplitude of the effect on larger branches.
   
    */
   float branchAmp;
   /*!
   Amplitude of the winds effect on leafs/fronds.
   
    */
   float detailAmp;
   /*!
   Frequency (speed) of the effect on leafs/fronds.
   
    */
   float detailFreq;
   /// @}

};

/*!
@brief Represents a type of ForestItem and parameters for how it is placed when painting with a ForestBrush that contains it.

 */
class  ForestBrushElement : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name ForestBrushElement
   @{ */
   /*! */
   /*!
   The type of ForestItem this element holds placement parameters for.
   
    */
   ForestItemData ForestItemData;
   /*!
   The probability that this element will be created during an editor brush stroke is the sum of all element probabilities in the brush divided by the probability of this element.
   
    */
   float probability;
   /*!
   The max rotation in degrees that items will be placed.
   
    */
   float rotationRange;
   /*!
   The minimum random size for each item.
   
    */
   float scaleMin;
   /*!
   The maximum random size of each item.
   
    */
   float scaleMax;
   /*!
   An exponent used to bias between the minimum and maximum random sizes.
   
    */
   float scaleExponent;
   /*!
   Min variation in the sink radius.
   
    */
   float sinkMin;
   /*!
   Max variation in the sink radius.
   
    */
   float sinkMax;
   /*!
   This is the radius used to calculate how much to sink the trunk at its base and is used to sink the tree into the ground when its on a slope.
   
    */
   float sinkRadius;
   /*!
   The min surface slope in degrees this item will be placed on.
   
    */
   float slopeMin;
   /*!
   The max surface slope in degrees this item will be placed on.
   
    */
   float slopeMax;
   /*!
   The min world space elevation this item will be placed.
   
    */
   float elevationMin;
   /*!
   The max world space elevation this item will be placed.
   
    */
   float elevationMax;
   /// @}

};

/*!
@brief Base class for Forest Editor specific tools

Editor use only.

 */
class  ForestTool : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Concrete implementation of ForestItemData which loads and renders dts format shapeFiles.

 */
class  TSForestItemData : public ForestItemData {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name Media
   @{ */
   /*! */
   /// @}


   /*! @name Wind
   @{ */
   /*! */
   /// @}

};

/*!
@brief A state block description for rendering.

This object is used with ShaderData in CustomMaterial and PostEffect to define the render state.
@tsexample
singleton GFXStateBlockData( PFX_DOFDownSampleStateBlock )
{
   zDefined = true;
   zEnable = false;
   zWriteEnable = false;

   samplersDefined = true;
   samplerStates[0] = SamplerClampLinear;
   samplerStates[1] = SamplerClampPoint;

   // Copy the clamped linear sampler, but change
   // the u coord to wrap for this special case.
   samplerStates[2] = new GFXSamplerStateData( : SamplerClampLinear )
   {
      addressModeU = GFXAddressWrap;
   };
};
@endtsexample
@note The 'xxxxDefined' fields are used to know what groups of fields are modified when combining multiple state blocks in material processing.  You should take care to enable the right ones when setting values.
@ingroup GFX
 */
class  GFXStateBlockData : public SimObject {
  public:

   /*! @name Alpha Blending
   @{ */
   /*! */
   /*!
   Set to true if the alpha blend state is not all defaults.
   
    */
   bool blendDefined;
   /*!
   Enables alpha blending.  The default is false.
   
    */
   bool blendEnable;
   /*!
   The source blend state.  The default is GFXBlendOne.
   
    */
   GFXBlend blendSrc;
   /*!
   The destination blend state.  The default is GFXBlendZero.
   
    */
   GFXBlend blendDest;
   /*!
   The arithmetic operation applied to alpha blending.  The default is GFXBlendOpAdd.
   
    */
   GFXBlendOp blendOp;
   /// @}


   /*! @name Separate Alpha Blending
   @{ */
   /*! */
   /*!
   Set to true if the seperate alpha blend state is not all defaults.
   
    */
   bool separateAlphaBlendDefined;
   /*!
   Enables the separate blend mode for the alpha channel.  The default is false.
   
    */
   bool separateAlphaBlendEnable;
   /*!
   The source blend state.  The default is GFXBlendOne.
   
    */
   GFXBlend separateAlphaBlendSrc;
   /*!
   The destination blend state.  The default is GFXBlendZero.
   
    */
   GFXBlend separateAlphaBlendDest;
   /*!
   The arithmetic operation applied to separate alpha blending.  The default is GFXBlendOpAdd.
   
    */
   GFXBlendOp separateAlphaBlendOp;
   /// @}


   /*! @name Alpha Test
   @{ */
   /*! */
   /*!
   Set to true if the alpha test state is not all defaults.
   
    */
   bool alphaDefined;
   /*!
   Enables per-pixel alpha testing.  The default is false.
   
    */
   bool alphaTestEnable;
   /*!
   The test function used to accept or reject a pixel based on its alpha value.  The default is GFXCmpGreaterEqual.
   
    */
   GFXCmpFunc alphaTestFunc;
   /*!
   The reference alpha value against which pixels are tested.  The default is zero.
   
    */
   int alphaTestRef;
   /// @}


   /*! @name Color Write
   @{ */
   /*! */
   /*!
   Set to true if the color write state is not all defaults.
   
    */
   bool colorWriteDefined;
   /*!
   Enables red channel writes.  The default is true.
   
    */
   bool colorWriteRed;
   /*!
   Enables blue channel writes.  The default is true.
   
    */
   bool colorWriteBlue;
   /*!
   Enables green channel writes.  The default is true.
   
    */
   bool colorWriteGreen;
   /*!
   Enables alpha channel writes.  The default is true.
   
    */
   bool colorWriteAlpha;
   /// @}


   /*! @name Culling
   @{ */
   /*! */
   /*!
   Set to true if the culling state is not all defaults.
   
    */
   bool cullDefined;
   /*!
   Defines how back facing triangles are culled if at all.  The default is GFXCullCCW.
   
    */
   GFXCullMode cullMode;
   /// @}


   /*! @name Depth
   @{ */
   /*! */
   /*!
   Set to true if the depth state is not all defaults.
   
    */
   bool zDefined;
   /*!
   Enables z-buffer reads.  The default is true.
   
    */
   bool zEnable;
   /*!
   Enables z-buffer writes.  The default is true.
   
    */
   bool zWriteEnable;
   /*!
   The depth comparision function which a pixel must pass to be written to the z-buffer.  The default is GFXCmpLessEqual.
   
    */
   GFXCmpFunc zFunc;
   /*!
   A floating-point bias used when comparing depth values.  The default is zero.
   
    */
   float zBias;
   /*!
   An additional floating-point bias based on the maximum depth slop of the triangle being rendered.  The default is zero.
   
    */
   float zSlopeBias;
   /// @}


   /*! @name Stencil
   @{ */
   /*! */
   /*!
   Set to true if the stencil state is not all defaults.
   
    */
   bool stencilDefined;
   /*!
   Enables stenciling.  The default is false.
   
    */
   bool stencilEnable;
   /*!
   The stencil operation to perform if the stencil test fails.  The default is GFXStencilOpKeep.
   
    */
   GFXStencilOp stencilFailOp;
   /*!
   The stencil operation to perform if the stencil test passes and the depth test fails.  The default is GFXStencilOpKeep.
   
    */
   GFXStencilOp stencilZFailOp;
   /*!
   The stencil operation to perform if both the stencil and the depth tests pass.  The default is GFXStencilOpKeep.
   
    */
   GFXStencilOp stencilPassOp;
   /*!
   The comparison function to test the reference value to a stencil buffer entry.  The default is GFXCmpNever.
   
    */
   GFXCmpFunc stencilFunc;
   /*!
   The reference value for the stencil test.  The default is zero.
   
    */
   int stencilRef;
   /*!
   The mask applied to the reference value and each stencil buffer entry to determine the significant bits for the stencil test. The default is 0xFFFFFFFF.
   
    */
   int stencilMask;
   /*!
   The write mask applied to values written into the stencil buffer. The default is 0xFFFFFFFF.
   
    */
   int stencilWriteMask;
   /// @}


   /*! @name Fixed Function
   @{ */
   /*! */
   /*!
   Enables fixed function lighting when rendering without a shader on geometry with vertex normals.  The default is false.
   
    */
   bool ffLighting;
   /*!
   Enables fixed function vertex coloring when rendering without a shader.  The default is false.
   
    */
   bool vertexColorEnable;
   /// @}


   /*! @name Sampler States
   @{ */
   /*! */
   /*!
   Set to true if the sampler states are not all defaults.
   
    */
   bool samplersDefined;
   /*!
   The array of texture sampler states.
@note Not all graphics devices support 16 samplers.  In general all systems support 4 samplers with most modern cards doing 8.
   
    */
   GFXSamplerStateData samplerStates;
   /*!
   The color used for multiple-texture blending with the GFXTATFactor texture-blending argument or the GFXTOPBlendFactorAlpha texture-blending operation.  The default is opaque white (255, 255, 255, 255).
   
    */
   ColorI textureFactor;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A sampler state used by GFXStateBlockData.

The samplers define how a texture will be sampled when used from the shader or fixed function device
@tsexample
singleton GFXSamplerStateData(SamplerClampLinear)
{
   textureColorOp = GFXTOPModulate;
   addressModeU = GFXAddressClamp;
   addressModeV = GFXAddressClamp;
   addressModeW = GFXAddressClamp;
   magFilter = GFXTextureFilterLinear;
   minFilter = GFXTextureFilterLinear;
   mipFilter = GFXTextureFilterLinear;
};
@endtsexample
There are a few predefined samplers in the core scripts which you can use with GFXStateBlockData for the most common rendering cases:
  - SamplerClampLinear
  - SamplerClampPoint
  - SamplerWrapLinear
  - SamplerWrapPoint

@see GFXStateBlockData
@ingroup GFX
 */
class  GFXSamplerStateData : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name Color Op
   @{ */
   /*! */
   /*!
   The texture color blending operation.  The default value is GFXTOPDisable which disables the sampler.
   
    */
   GFXTextureOp textureColorOp;
   /*!
   The first color argument for the texture stage.  The default value is GFXTACurrent.
   
    */
   GFXTextureArgument colorArg1;
   /*!
   The second color argument for the texture stage.  The default value is GFXTATexture.
   
    */
   GFXTextureArgument colorArg2;
   /*!
   The third color argument for triadic operations (multiply, add, and linearly interpolate).  The default value is GFXTACurrent.
   
    */
   GFXTextureArgument colorArg3;
   /// @}


   /*! @name Alpha Op
   @{ */
   /*! */
   /*!
   The texture alpha blending operation.  The default value is GFXTOPModulate.
   
    */
   GFXTextureOp alphaOp;
   /*!
   The first alpha argument for the texture stage.  The default value is GFXTATexture.
   
    */
   GFXTextureArgument alphaArg1;
   /*!
   The second alpha argument for the texture stage.  The default value is GFXTADiffuse.
   
    */
   GFXTextureArgument alphaArg2;
   /*!
   The third alpha channel selector operand for triadic operations (multiply, add, and linearly interpolate).  The default value is GFXTACurrent.
   
    */
   GFXTextureArgument alphaArg3;
   /// @}


   /*! @name Address Mode
   @{ */
   /*! */
   /*!
   The texture address mode for the u coordinate.  The default is GFXAddressWrap.
   
    */
   GFXTextureAddressMode addressModeU;
   /*!
   The texture address mode for the v coordinate.  The default is GFXAddressWrap.
   
    */
   GFXTextureAddressMode addressModeV;
   /*!
   The texture address mode for the w coordinate.  The default is GFXAddressWrap.
   
    */
   GFXTextureAddressMode addressModeW;
   /// @}


   /*! @name Filter State
   @{ */
   /*! */
   /*!
   The texture magnification filter.  The default is GFXTextureFilterLinear.
   
    */
   GFXTextureFilterType magFilter;
   /*!
   The texture minification filter.  The default is GFXTextureFilterLinear.
   
    */
   GFXTextureFilterType minFilter;
   /*!
   The texture mipmap filter used during minification.  The default is GFXTextureFilterLinear.
   
    */
   GFXTextureFilterType mipFilter;
   /*!
   The mipmap level of detail bias.  The default value is zero.
   
    */
   float mipLODBias;
   /*!
   The maximum texture anisotropy.  The default value is 1.
   
    */
   int maxAnisotropy;
   /// @}

   /*!
   Sets the texture transform state.  The default is GFXTTFFDisable.
   
    */
   GFXTextureTransformFlags textureTransform;
   /*!
   The selection of the destination register for the result of this stage.  The default is GFXTACurrent.
   
    */
   GFXTextureArgument resultArg;
};

/*!
@brief The base class for the various button controls.

This is the base class for the various types of button controls.  If no more specific functionality is required than offered by this class, then it can be instantiated and used directly.  Otherwise, its subclasses should be used:
- GuiRadioCtrl (radio buttons)
- GuiCheckBoxCtrl (checkboxes)
- GuiButtonCtrl (push buttons with text labels)
- GuiBitmapButtonCtrl (bitmapped buttons)
- GuiBitmapButtonTextCtrl (bitmapped buttons with a text label)
- GuiToggleButtonCtrl (toggle buttons, i.e. push buttons with "sticky" behavior)
- GuiSwatchButtonCtrl (color swatch buttons)
- GuiBorderButtonCtrl (push buttons for surrounding child controls)

 */
class  GuiButtonBaseCtrl : public GuiControl {
  public:
      /*! If #useMouseEvents is true, this is called when the left mouse button is pressed on an (active) button. */
      void onMouseDown();

      /*! If #useMouseEvents is true, this is called when the left mouse button is release over an (active) button.

@note To trigger actions, better use onClick() since onMouseUp() will also be called when the mouse was not originally pressed on the button. */
      void onMouseUp();

      /*! Called when the primary action of the button is triggered (e.g. by a left mouse click). */
      void onClick();

      /*! Called when the left mouse button is double-clicked on the button. */
      void onDoubleClick();

      /*! Called when the right mouse button is clicked on the button. */
      void onRightClick();

      /*! If #useMouseEvents is true, this is called when the mouse cursor moves over the button (only if the button is the front-most visible control, though). */
      void onMouseEnter();

      /*! If #useMouseEvents is true, this is called when the mouse cursor moves off the button (only if the button had previously received an onMouseEvent() event). */
      void onMouseLeave();

      /*! If #useMouseEvents is true, this is called when a left mouse button drag is detected, i.e. when the user pressed the left mouse button on the control and then moves the mouse over a certain distance threshold with the mouse button still pressed. */
      void onMouseDragged();

   /*! Simulate a click on the button.
This method will trigger the button's action just as if the button had been pressed by the user.

 */
   virtual void performClick(()) {}
   /*! Set the text displayed on the button's label.
@param text The text to display as the button's text label.
@note Not all buttons render text labels.

@see getText
@see setTextID
 */
   virtual void setText(( string text )) {}
   /*! Set the text displayed on the button's label using a string from the string table assigned to the control.

@param id Name of the variable that contains the integer string ID.  Used to look up string in table.

@note Not all buttons render text labels.

@see setText
@see getText
@see GuiControl::langTableMod
@see LangTable

@ref Gui_i18n */
   virtual void setTextID(( string id )) {}
   /*! Get the text display on the button's label (if any).

@return The button's label. */
   virtual string getText(()) {}
   /*! For toggle or radio buttons, set whether the button is currently activated or not.  For radio buttons, toggling a button on will toggle all other radio buttons in its group to off.

@param isOn If true, the button will be toggled on (if not already); if false, it will be toggled off.

@note Toggling the state of a button with this method will <em>not</em> not trigger the action associated with the button.  To do that, use performClick(). */
   virtual void setStateOn(( bool isOn=true )) {}
   /*! Reset the mousing state of the button.

This method should not generally be called. */
   virtual void resetState(()) {}

   /*! @name Button
   @{ */
   /*! */
   /*!
   Text label to display on button (if button class supports text labels).
   
    */
   caseString text;
   /*!
   ID of string in string table to use for text label on button.

@see setTextID
@see GuiControl::langTableMod
@see LangTable


   
    */
   string textID;
   /*!
   Radio button toggle group number.  All radio buttons that are assigned the same #groupNum and that are parented to the same control will synchronize their toggle state, i.e. if one radio button is toggled on all other radio buttons in its group will be toggled off.

The default group is -1.
   
    */
   int groupNum;
   /*!
   Button behavior type.

   
    */
   GuiButtonType buttonType;
   /*!
   If true, mouse events will be passed on to script.  Default is false.

   
    */
   bool useMouseEvents;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The most widely used button class.

GuiButtonCtrl renders seperately of, but utilizes all of the functionality of GuiBaseButtonCtrl.
This grants GuiButtonCtrl the versatility to be either of the 3 button types.

@tsexample
// Create a PushButton GuiButtonCtrl that calls randomFunction when clicked
%button = new GuiButtonCtrl()
{
   profile    = "GuiButtonProfile";
   buttonType = "PushButton";
   command    = "randomFunction();";
};
@endtsexample

 */
class  GuiButtonCtrl : public GuiButtonBaseCtrl {
  public:

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A button that renders its various states (mouse over, pushed, etc.) from separate bitmaps.

A bitmapped button is a push button that uses one or more texture images for rendering its individual states.

To find the individual textures associated with the button, a naming scheme is used.  For each state a suffix is appended to the texture file name given in the GuiBitmapButtonCtrl::bitmap field:
- "_n": Normal state.  This one will be active when no other state applies.
- "_h": Highlighted state.  This applies when the mouse is hovering over the button.
- "_d": Depressed state.  This applies when the left mouse button has been clicked on the button but not yet released.
- "_i": Inactive state.  This applies when the button control has been deactivated (GuiControl::setActive())

If a bitmap for a particular state cannot be found, the default bitmap will be used.  To disable all state-based bitmap functionality, set useStates to false which will make the control solely render from the bitmap specified in the bitmap field.

@section guibitmapbutton_modifiers Per-Modifier Button Actions
If GuiBitmapButtonCtrl::useModifiers is set to true, per-modifier button actions and textures are enabled.  This functionality allows to associate different images and different actions with a button depending on which modifiers are pressed on the keyboard by the user.

When enabled, this functionality alters the texture lookup above by prepending the following strings to the suffixes listed above:
- "": Default.  No modifier is pressed.
- "_ctrl": Image to use when CTRL/CMD is down.
- "_alt": Image to use when ALT is down.
- "_shift": Image to use when SHIFT is down

When this functionality is enabled, a new set of callbacks is used:
- onDefaultClick: Button was clicked without a modifier being presssed.
- onCtrlClick: Button was clicked with the CTRL/CMD key down.
- onAltClick: Button was clicked with the ALT key down.
- onShiftClick: Button was clicked with the SHIFT key down.

GuiControl::command or GuiControl::onAction() still work as before when per-modifier functionality is enabled.

Note that modifiers cannot be mixed.  If two or more modifiers are pressed, a single one will take precedence over the remaining modifiers.  The order of precedence corresponds to the order listed above.

@tsexample
// Create an OK button that will trigger an onOk() call on its parent when clicked:
%okButton = new GuiBitmapButtonCtrl()
{
   bitmap = "art/gui/okButton";
   autoFitExtents = true;
   command = "$ThisControl.getParent().onOk();";
};
@endtsexample

 */
class  GuiBitmapButtonCtrl : public GuiButtonCtrl {
  public:
      /*! Called when per-modifier functionality is enabled and the user clicks on the button without any modifier pressed.
@ref guibitmapbutton_modifiers */
      void onDefaultClick();

      /*! Called when per-modifier functionality is enabled and the user clicks on the button with the CTRL key pressed.
@ref guibitmapbutton_modifiers */
      void onCtrlClick();

      /*! Called when per-modifier functionality is enabled and the user clicks on the button with the ALT key pressed.
@ref guibitmapbutton_modifiers */
      void onAltClick();

      /*! Called when per-modifier functionality is enabled and the user clicks on the button with the SHIFT key pressed.
@ref guibitmapbutton_modifiers */
      void onShiftClick();

   /*! Set the bitmap to show on the button.
@param path Path to the texture file in any of the supported formats.
 */
   virtual void setBitmap(( string path )) {}

   /*! @name Bitmap
   @{ */
   /*! */
   /*!
   Texture file to display on this button.
If useStates is false, this will be the file that renders on the control.  Otherwise, this will specify the default texture name to which the various state and modifier suffixes are appended to find the per-state and per-modifier (if enabled) textures.
   
    */
   filename bitmap;
   /*!
   Behavior for fitting the bitmap to the control extents.
If set to 'Stretched', the bitmap will be stretched both verticall and horizontally to fit inside the control's extents.

If set to 'Centered', the bitmap will stay at its original resolution centered in the control's rectangle (getting clipped if the control is smaller than the texture).
   
    */
   GuiBitmapMode bitmapMode;
   /*!
   If true, the control's extents will be set to match the bitmap's extents when setting the bitmap.
The bitmap extents will always be taken from the default/normal bitmap (in case the extents of the various bitmaps do not match up.)
   
    */
   bool autoFitExtents;
   /*!
   If true, per-modifier button functionality is enabled.
@ref guibitmapbutton_modifiers
   
    */
   bool useModifiers;
   /*!
   If true, per-mouse state button functionality is enabled.
Defaults to true.

If you do not use per-state images on this button set this to false to speed up the loading process by inhibiting searches for the individual images.
   
    */
   bool useStates;
   /// @}


   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An extension of GuiBitmapButtonCtrl that additionally renders a text label on the bitmapped button.

The text for the label is taken from the GuiButtonBaseCtrl::text property.

For rendering, the label is placed, relative to the control's upper left corner, at the text offset specified in the control's profile (GuiControlProfile::textOffset) and justified according to the profile's setting (GuiControlProfile::justify).

@see GuiControlProfile::textOffset
@see GuiControlProfile::justify
 */
class  GuiBitmapButtonTextCtrl : public GuiBitmapButtonCtrl {
  public:

   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An extension of GuiBitmapButtonCtrl that additionally renders a border around the bitmapped button.

 */
class  GuiBitmapButtonBorderCtrl : public GuiBitmapButtonCtrl {
  public:

   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A push button that renders only a border.

A border button consists of a border rendered along its extents according to the border thickness defined in its profile (GuiControlProfile::border).  For the border color, a color is selected from the profile according to current button state:
- Default state: GuiControlProfile::borderColor
- Highlighted (mouse is over the button): GuiControlProfile::fontColorHL
- Depressed (mouse button down but not yet released): GuiControlProfile::fontColorSEL
@ingroup GuiButtons
 */
class  GuiBorderButtonCtrl : public GuiButtonBaseCtrl {
  public:

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A named checkbox that can be toggled on and off.

A GuiCheckBoxCtrl displays a text label next to a checkbox that can be toggled on and off by the user. Checkboxes are usually used to present boolean choices like, for example, a switch to toggle fullscreen video on and off.

@tsexample
// Create a checkbox that allows to toggle fullscreen on and off.
new GuiCheckBoxCtrl( FullscreenToggle )
{
   text = "Fullscreen";
};

// Set the initial state to match the current fullscreen setting.
FullscreenToggle.setStateOn( Canvas.isFullscreen() );

// Define function to be called when checkbox state is toggled.
function FullscreenToggle::onClick( %this )
{
   Canvas.toggleFullscreen();
}
@endtsexample

 */
class  GuiCheckBoxCtrl : public GuiButtonBaseCtrl {
  public:
   /*! Set whether the checkbox is ticked or not.
@param newState If true the box will be checked, if false, it will be unchecked.

@note This method will @b not trigger the command associated with the control.  To toggle the checkbox state as if the user had clicked the control, use performClick(). */
   virtual void setStateOn(( bool newState )) {}
   /*! Test whether the checkbox is currently checked.
@return True if the checkbox is currently ticked, false otherwise.
 */
   virtual bool isStateOn(()) {}

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A button based around the radio concept.

GuiRadioCtrl's functionality is based around GuiButtonBaseCtrl's ButtonTypeRadio type.

A button control with a radio box and a text label.
This control is used in groups where multiple radio buttons
present a range of options out of which one can be chosen.
A radio button automatically signals its siblings when it is
toggled on.

@tsexample
// Create a GuiCheckBoxCtrl that calls randomFunction with its current value when clicked.
%radio = new GuiRadioCtrl()
{
   profile = "GuiRadioProfile";
};
@endtsexample

 */
class  GuiRadioCtrl : public GuiCheckBoxCtrl {
  public:

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Deprecated gui control.

@deprecated GuiToggleButtonCtrl's functionality is solely based on GuiButtonBaseCtrl's ButtonTypeCheck type.

@see GuiButtonCtrl
@see GuiCheckBoxCtrl
 */
class  GuiToggleButtonCtrl : public GuiButtonCtrl {
  public:

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Brief Desc.

@tsexample
// Comment:
%okButton = new ClassObject()
instantiation
@endtsexample

 */
class  GuiContainer : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /*!
   
   
    */
   GuiDockingType docking;
   /*!
    */
   RectSpacingI margin;
   /*!
    */
   RectSpacingI padding;
   /*!
    */
   bool anchorTop;
   /*!
    */
   bool anchorBottom;
   /*!
    */
   bool anchorLeft;
   /*!
    */
   bool anchorRight;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Brief Desc.

@tsexample
// Comment:
%okButton = new ClassObject()
instantiation
@endtsexample

 */
class  GuiControlArrayControl : public GuiControl {
  public:

   /*! @name Array
   @{ */
   /*! */
   /*!
   Number of colums in the array.
   
    */
   int colCount;
   /*!
   Size of each individual column.
   
    */
   intList colSizes;
   /*!
   Heigth of a row in the array.
   
    */
   int rowSize;
   /*!
   Padding to put between rows.
   
    */
   int rowSpacing;
   /*!
   Padding to put between columns.
   
    */
   int colSpacing;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The GuiPanel panel is a container that when opaque will draw a left to right gradient using its profile fill and fill highlight colors.

@tsexample
// Mandatory GuiDefaultProfile
// Contains the fill color information required by a GuiPanel
// Some values left out for sake of this example
new GuiControlProfile (GuiDefaultProfile)
{
^// fill color
^opaque = false;
^fillColor = "242 241 240";
^fillColorHL ="228 228 235";
^fillColorSEL = "98 100 137";
^fillColorNA = "255 255 255 ";
};

new GuiPanel(TestPanel)
{
^position = "45 33";
^extent = "342 379";
^minExtent = "16 16";
^horizSizing = "right";
^vertSizing = "bottom";
^profile = "GuiDefaultProfile"; // Color fill info is in this profile
^isContainer = "1";
};
@endtsexample

@see GuiControlProfile
@ingroup GuiContainers
 */
class  GuiPanel : public GuiContainer {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that splits its area between two child controls.

A GuiSplitContainer can be used to dynamically subdivide an area between two child controls.  A splitter bar is placed between the two controls and allows to dynamically adjust the sizing ratio between the two sides.  Splitting can be either horizontal (subdividing top and bottom) or vertical (subdividing left and right) depending on #orientation.

By using #fixedPanel, one of the panels can be chosen to remain at a fixed size (#fixedSize).@tsexample
// Create a vertical splitter with a fixed-size left panel.
%splitter = new GuiSplitContainer()
{
   orientation = "Vertical";
   fixedPanel = "FirstPanel";
   fixedSize = 100;

   new GuiScrollCtrl()
   {
      new GuiMLTextCtrl()
      {
         text = %longText;
      };
   };

   new GuiScrollCtrl()
   {
      new GuiMLTextCtrl()
      {
         text = %moreLongText;
      };
   };
};
@endtsexample

@note The children placed inside GuiSplitContainers must be GuiContainers.

 */
class  GuiSplitContainer : public GuiContainer {
  public:

   /*! @name Splitter
   
   Options to configure split panels contained by this control
   @{ */
   /*! */
   /*!
   Whether to split between top and bottom (horizontal) or between left and right (vertical).
   
    */
   GuiSplitOrientation orientation;
   /*!
   Width of the splitter bar between the two sides.  Default is 2.
   
    */
   int splitterSize;
   /*!
   Point on control through which the splitter goes.

Changed relatively if size of control changes.
   
    */
   Point2I splitPoint;
   /*!
   Which (if any) side of the splitter to keep at a fixed size.
   
    */
   GuiSplitFixedPanel fixedPanel;
   /*!
   Width of the fixed panel specified by #fixedPanel (if any).
   
    */
   int fixedSize;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A window with a title bar and an optional set of buttons.

The GuiWindowCtrl class implements windows that can be freely placed within the render window.  Additionally, the windows can be resized and maximized/minimized.

@tsexample
new GuiWindowCtrl( MyWindow )
{
   text = "My Window"; // The text that is displayed on the title bar.
   resizeWidth = true; // Allow horizontal resizing by user via mouse.
   resizeHeight = true; // Allow vertical resizing by user via mouse.
   canClose = true; // Display a close button in the title bar.
   canMinimize = true; // Display a minimize button in the title bar.
   canMaximize = true; // Display a maximize button in the title bar.
};
@endtsexample

 */
class  GuiWindowCtrl : public GuiContainer {
  public:
      /*! Called when the close button has been pressed. */
      void onClose();

      /*! Called when the window has been minimized. */
      void onMinimize();

      /*! Called when the window has been maximized. */
      void onMaximize();

      /*! Called when the window is collapsed by clicking its title bar. */
      void onCollapse();

      /*! Called when the window is restored from minimized, maximized, or collapsed state. */
      void onRestore();

   /*! Bring the window to the front. */
   virtual void selectWindow(()) {}
   /*! Set the window's collapsing state. */
   virtual void setCollapseGroup(( bool state )) {}
   /*! Toggle the window collapsing. */
   virtual void toggleCollapseGroup(()) {}
   virtual void attachTo(( GuiWindowCtrl window )) {}
   /*! Attach @a bottomWindow to @topWindow so that @a bottomWindow moves along with @a topWindow when it is dragged.

@param bottomWindow 
@param topWindow  */
   virtual void attach(( GuiWindowCtrl bottomWindow, GuiWindowCtrl topWindow )) {}

   /*! @name Window
   @{ */
   /*! */
   /*!
   Text label to display in titlebar.
   
    */
   string text;
   /*!
   Whether the window can be resized horizontally.
   
    */
   bool resizeWidth;
   /*!
   Whether the window can be resized vertically.
   
    */
   bool resizeHeight;
   /*!
   Whether the window can be moved by dragging its titlebar.
   
    */
   bool canMove;
   /*!
   Whether the window has a close button.
   
    */
   bool canClose;
   /*!
   Whether the window has a minimize button.
   
    */
   bool canMinimize;
   /*!
   Whether the window has a maximize button.
   
    */
   bool canMaximize;
   /*!
   Whether the window can be collapsed by clicking its title bar.
   
    */
   bool canCollapse;
   /*!
   Script code to execute when the window is closed.
   
    */
   string closeCommand;
   /*!
   If true, the window will snap to the edges of other windows when moved close to them.
   
    */
   bool edgeSnap;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@deprecated Use GuiWindowCtrl with GuiWindowCtrl::canCollapse = true.

 */
class  GuiWindowCollapseCtrl : public GuiWindowCtrl {
  public:

   /*! @name Window
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Renders a background, so you can have a backdrop for your GUI.

Deprecated

@ingroup GuiImages
 */
class  GuiBackgroundCtrl : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that renders a skinned border specified in its profile.

This control uses the bitmap specified in it's profile (GuiControlProfile::bitmapName).  It takes this image and breaks up aspects of it to skin the border of this control with.  It is also important to set GuiControlProfile::hasBitmapArray to true on the profile as well.

The bitmap referenced should be broken up into a 3 x 3 grid (using the top left color pixel as a border color between each of the images) in which it will map to the following places:
1 = Top Left Corner
2 = Top Right Corner
3 = Top Center
4 = Left Center
5 = Right Center
6 = Bottom Left Corner
7 = Bottom Center
8 = Bottom Right Corner
0 = Nothing

1 2 3
4 5 0
6 7 8

@tsexample
singleton GuiControlProfile (BorderGUIProfile)
{
   bitmap = "core/art/gui/images/borderArray";
   hasBitmapArray = true;
   opaque = false;
};

new GuiBitmapBorderCtrl(BitmapBorderGUI)
{
   profile = "BorderGUIProfile";
   position = "0 0";
   extent = "400 40";
   visible = "1";
};@endtsexample

@see GuiControlProfile::bitmapName
@see GuiControlProfile::hasBitmapArray

 */
class  GuiBitmapBorderCtrl : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI control object this displays a single line of text, without TorqueML.

@tsexample
^new GuiTextCtrl()
^{
^^text = "Hello World";
^^textID = ""STR_HELLO"";
^^maxlength = "1024";
^    //Properties not specific to this control have been omitted from this example.
^};
@endtsexample

@see GuiControl
@see Localization

@ingroup GuiCore
 */
class  GuiTextCtrl : public GuiContainer {
  public:
   /*! @brief Sets the text in the control.

@param text Text to display in the control.
@tsexample
// Set the text to show in the control
%text = "Gideon - Destroyer of World";

// Inform the GuiTextCtrl control to change its text to the defined value
%thisGuiTextCtrl.setText(%text);
@endtsexample

@see GuiControl */
   virtual void setText(( string text )) {}
   /*! @brief Maps the text ctrl to a variable used in localization, rather than raw text.

@param textID Name of variable text should be mapped to
@tsexample
// Inform the GuiTextCtrl control of the textID to use
%thisGuiTextCtrl.setTextID("STR_QUIT");
@endtsexample

@see GuiControl@see Localization */
   virtual void setTextID(( string textID )) {}
   /*!
   The text to show on the control.
   
    */
   caseString text;
   /*!
   Maps the text of this control to a variable used in localization, rather than raw text.
   
    */
   string textID;
   /*!
   Defines the maximum length of the text.  The default is 1024.
   
    */
   int maxLength;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A component that places a text entry box on the screen.

Fonts and sizes are changed using profiles. The text value can be set or entered by a user.

@tsexample
   new GuiTextEditCtrl(MessageHud_Edit)
^{
^^ text = "Hello World";
^^ validate = "validateCommand();"
^^ escapeCommand = "escapeCommand();";
^^ historySize = "5";
^^ tabComplete = "true";
^^ deniedSound = "DeniedSoundProfile";
^^ sinkAllKeyEvents = "true";
^^ password = "true";
^^ passwordMask = "*";
^     //Properties not specific to this control have been omitted from this example.
   };
@endtsexample

@see GuiTextCtrl
@see GuiControl

@ingroup GuiControls
 */
class  GuiTextEditCtrl : public GuiTextCtrl {
  public:
      /*! @brief Called if tabComplete is true, and the 'tab' key is pressed.

@param val Input to mimick the '1' sent by the actual tab key button press.
@tsexample
// Tab key has been pressed, causing the callback to occur.
GuiTextEditCtrl::onTabComplete(%this,%val)
^{
^^//Code to run when the onTabComplete callback occurs
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl

 */
      void onTabComplete( string val );

      /*! @brief Called when the 'Return' or 'Enter' key is pressed.

@tsexample
// Return or Enter key was pressed, causing the callback to occur.
GuiTextEditCtrl::onReturn(%this)
^{
^^// Code to run when the onReturn callback occurs
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl

 */
      void onReturn();

      /*! @brief Called whenever the control is validated.

@tsexample
// The control gets validated, causing the callback to occur
GuiTextEditCtrl::onValidated(%this)
^{
^^// Code to run when the control is validated
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl

 */
      void onValidate();

   /*! @brief Acquires the current text displayed in this control.

@tsexample
// Acquire the value of the text control.
%text = %thisGuiTextEditCtrl.getText();
@endtsexample

@return The current text within the control.

@see GuiControl */
   virtual string getText(()) {}
   /*! @brief Sets the text in the control.

@param text Text to place in the control.
@tsexample
// Define the text to display
%text = "Text!"

// Inform the GuiTextEditCtrl to display the defined text
%thisGuiTextEditCtrl.setText(%text);
@endtsexample

@see GuiControl */
   virtual void setText(( string text )) {}
   /*! @brief Returns the current position of the text cursor in the control.

@tsexample
// Acquire the cursor position in the control
%position = %thisGuiTextEditCtrl.getCursorPost();
@endtsexample

@return Text cursor position within the control.

@see GuiControl */
   virtual int getCursorPos(()) {}
   /*! @brief Sets the text cursor at the defined position within the control.

@param position Text position to set the text cursor.
@tsexample
// Define the cursor position
%position = "12";

// Inform the GuiTextEditCtrl control to place the text cursor at the defined position
%thisGuiTextEditCtrl.setCursorPos(%position);
@endtsexample

@see GuiControl */
   virtual void setCursorPos(( int position )) {}
   /*! @brief Checks to see if all text in the control has been selected.

@tsexample
// Check to see if all text has been selected or not.
%allSelected = %thisGuiTextEditCtrl.isAllTextSelected();
@endtsexample

@return True if all text in the control is selected, otherwise false.

@see GuiControl */
   virtual bool isAllTextSelected(()) {}
   /*! @brief Selects all text within the control.

@tsexample
// Inform the control to select all of its text.
%thisGuiTextEditCtrl.selectAllText();
@endtsexample

@see GuiControl */
   virtual void selectAllText(()) {}
   /*! @brief Unselects all selected text in the control.

@tsexample
// Inform the control to unselect all of its selected text
%thisGuiTextEditCtrl.clearSelectedText();
@endtsexample

@see GuiControl */
   virtual void clearSelectedText(()) {}
   /*! @brief Force a validation to occur.

@tsexample
// Inform the control to force a validation of its text.
%thisGuiTextEditCtrl.forceValidateText();
@endtsexample

@see GuiControl */
   virtual void forceValidateText(()) {}

   /*! @name Text Input
   @{ */
   /*! */
   /*!
   Script command to be called when the first validater is lost.

   
    */
   string validate;
   /*!
   Script command to be called when the Escape key is pressed.

   
    */
   string escapeCommand;
   /*!
   How large of a history buffer to maintain.

   
    */
   int historySize;
   /*!
   If true, when the 'tab' key is pressed, it will act as if the Enter key was pressed on the control.

   
    */
   bool tabComplete;
   /*!
   If the attempted text cannot be entered, this sound effect will be played.

   
    */
   SFXTrack deniedSound;
   /*!
   If true, every key event will act as if the Enter key was pressed.

   
    */
   bool sinkAllKeyEvents;
   /*!
   If true, all characters entered will be stored in the control, however will display as the character stored in passwordMask.

   
    */
   bool password;
   /*!
   If 'password' is true, this is the character that will be used to mask the characters in the control.

   
    */
   string passwordMask;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Text entry element of a GuiConsole.

@tsexample
new GuiConsoleEditCtrl(ConsoleEntry)
{
   profile = "ConsoleTextEditProfile";
   horizSizing = "width";
   vertSizing = "top";
   position = "0 462";
   extent = "640 18";
   minExtent = "8 8";
   visible = "1";
   altCommand = "ConsoleEntry::eval();";
   helpTag = "0";
   maxLength = "255";
   historySize = "40";
   password = "0";
   tabComplete = "0";
   sinkAllKeyEvents = "1";
   useSiblingScroller = "1";
};
@endtsexample

 */
class  GuiConsoleEditCtrl : public GuiTextEditCtrl {
  public:

   /*! @name GuiConsoleEditCtrl
   @{ */
   /*! */
   /*!
    */
   bool useSiblingScroller;
   /// @}


   /*! @name Text Input
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Used by GUIConsole system internally.

 */
class  GuiConsoleTextCtrl : public GuiControl {
  public:

   /*! @name GuiConsoleTextCtrl
   @{ */
   /*! */
   /*!
    */
   string expression;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Designed soley for buttons, primarily used in editor.

Currently editor use only, no real application without extension.

 */
class  GuiDecoyCtrl : public GuiControl {
  public:
   /*!
   Sets this control to decoy mode
   
    */
   bool isDecoy;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A collection of properties that determine control behavior and rendering.
@ingroup GuiCore
 */
class  GuiControlProfile : public SimObject {
  public:
   virtual int getStringWidth(( pString )) {}

   /*! @name Behavior
   @{ */
   /*! */
   /*!
    */
   bool tab;
   /*!
   Whether the control can have the keyboard focus.
   
    */
   bool canKeyFocus;
   /*!
    */
   bool mouseOverSelected;
   /*!
    */
   bool modal;
   /// @}


   /*! @name Appearance
   @{ */
   /*! */
   /*!
    */
   bool opaque;
   /*!
    */
   ColorI fillColor;
   /*!
    */
   ColorI fillColorHL;
   /*!
    */
   ColorI fillColorNA;
   /*!
    */
   ColorI fillColorSEL;
   /*!
   Border type (0=no border).
   
    */
   int border;
   /*!
   Thickness of border in pixels.
   
    */
   int borderThickness;
   /*!
   Color to draw border with.
   
    */
   ColorI borderColor;
   /*!
    */
   ColorI borderColorHL;
   /*!
    */
   ColorI borderColorNA;
   /*!
    */
   ColorI bevelColorHL;
   /*!
    */
   ColorI bevelColorLL;
   /// @}


   /*! @name Text
   @{ */
   /*! */
   /*!
   Name of font family and typeface (e.g. "Arial Bold").
   
    */
   string fontType;
   /*!
   Font size in points.
   
    */
   int fontSize;
   /*!
    */
   GuiFontCharset fontCharset;
   /*!
   Font colors to use for different text types/states.
   
    */
   ColorI fontColors;
   /*!
   Font color for normal text (same as fontColors[0]).
   
    */
   ColorI fontColor;
   /*!
   Font color for highlighted text (same as fontColors[1]).
   
    */
   ColorI fontColorHL;
   /*!
   Font color when control is not active/disabled (same as fontColors[2]).
   
    */
   ColorI fontColorNA;
   /*!
   Font color for selected text (same as fontColors[3]).
   
    */
   ColorI fontColorSEL;
   /*!
   Font color for links in text (same as fontColors[4]).
   
    */
   ColorI fontColorLink;
   /*!
   Font color for highlighted links in text (same as fontColors[5]).
   
    */
   ColorI fontColorLinkHL;
   /*!
   Horizontal alignment for text.
   
    */
   GuiAlignmentType justify;
   /*!
    */
   Point2I textOffset;
   /*!
   Automatically adjust width of control to fit contents.
   
    */
   bool autoSizeWidth;
   /*!
   Automatically adjust height of control to fit contents.
   
    */
   bool autoSizeHeight;
   /*!
   Whether to add automatic tab event when return is pressed so focus moves on to next control (GuiTextEditCtrl).
   
    */
   bool returnTab;
   /*!
   Whether control should only accept numerical data (GuiTextEditCtrl).
   
    */
   bool numbersOnly;
   /*!
   Color to use for the text cursor.
   
    */
   ColorI cursorColor;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Texture to use for rendering control.
   
    */
   filename bitmap;
   /*!
   If true, 'bitmap' is an array of images.
   
    */
   bool hasBitmapArray;
   /*!
   Sound to play when mouse has been pressed on control.
   
    */
   SFXTrack soundButtonDown;
   /*!
   Sound to play when mouse is hovering over control.
   
    */
   SFXTrack soundButtonOver;
   /*!
    */
   string profileForChildren;
   /// @}

   /*!
   Category under which the profile will appear in the editor.
   
    */
   string category;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A GuiControlProfile with additional fields specific to GuiGameListMenuCtrl.

@tsexample
new GuiGameListMenuProfile()
{
   hitAreaUpperLeft = "10 2";
   hitAreaLowerRight = "190 18";
   iconOffset = "10 2";
   rowSize = "200 20";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiGameListMenuProfile : public GuiControlProfile {
  public:
   /*!
   Position of the upper left corner of the row hit area (relative to row's top left corner)
   
    */
   Point2I hitAreaUpperLeft;
   /*!
   Position of the lower right corner of the row hit area (relative to row's top left corner)
   
    */
   Point2I hitAreaLowerRight;
   /*!
   Offset from the row's top left corner at which to render the row icon
   
    */
   Point2I iconOffset;
   /*!
   The base size ("width height") of a row
   
    */
   Point2I rowSize;

   /*! @name Behavior
   @{ */
   /*! */
   /// @}


   /*! @name Appearance
   @{ */
   /*! */
   /// @}


   /*! @name Text
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A GuiControlProfile with additional fields specific to GuiGameListOptionsCtrl.

@tsexample
new GuiGameListOptionsProfile()
{
   columnSplit = "100";
   rightPad = "4";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiGameListOptionsProfile : public GuiGameListMenuProfile {
  public:
   /*!
   Padding between the leftmost edge of the control, and the row's left arrow.
   
    */
   int columnSplit;
   /*!
   Padding between the rightmost edge of the control and the row's right arrow.
   
    */
   int rightPad;

   /*! @name Behavior
   @{ */
   /*! */
   /// @}


   /*! @name Appearance
   @{ */
   /*! */
   /// @}


   /*! @name Text
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A text control that uses the Gui Markup Language ('ML') tags to dynamically change the text.

Example of dynamic changes include colors, styles, and/or hyperlinks. These changes can occur without having to use separate text controls with separate text profiles.

@tsexample
new GuiMLTextCtrl(CenterPrintText)
{
    lineSpacing = "2";
    allowColorChars = "0";
    maxChars = "-1";
    deniedSound = "DeniedSoundProfile";
    text = "The Text for This Control.";
    useURLMouseCursor = "true";
    //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiControl

@ingroup GuiCore
 */
class  GuiMLTextCtrl : public GuiControl {
  public:
      /*! @brief Called whenever a URL was clicked on within the control.

@param url The URL address that was clicked on.
@tsexample
// A URL address was clicked on in the control, causing the callback to occur.
GuiMLTextCtrl::onUrl(%this,%url)
^{
^^// Code to run whenever a URL was clicked on
^}
@endtsexample

@see GuiControl

 */
      void onURL( string url );

      /*! @brief Called whenever the control size changes.

@param width The new width value for the control
@param maxY The current maximum allowed Y value for the control

@tsexample
// Control size changed, causing the callback to occur.
GuiMLTextCtrl::onResize(%this,%width,%maxY)
^{
^^// Code to call when the control size changes
^}
@endtsexample

@see GuiControl

 */
      void onResize( string width, string maxY );

   /*! @brief Set the text contained in the control.

@param text The text to display in the control.
@tsexample
// Define the text to display
%text = "Nifty Control Text";

// Set the text displayed within the control
%thisGuiMLTextCtrl.setText(%text);
@endtsexample

@see GuiControl */
   virtual void setText(( string text )) {}
   /*! @brief Returns the text from the control, including TorqueML characters.

@tsexample
// Get the text displayed in the control
%controlText = %thisGuiMLTextCtrl.getText();
@endtsexample

@return Text string displayed in the control, including any TorqueML characters.

@see GuiControl */
   virtual string getText(()) {}
   /*! @brief Appends the text in the control with additional text. Also .

@param text New text to append to the existing text.
@param reformat If true, the control will also be visually reset (defaults to true).
@tsexample
// Define new text to add
%text = "New Text to Add";

// Set reformat boolean
%reformat = "true";

// Inform the control to add the new text
%thisGuiMLTextCtrl.addText(%text,%reformat);
@endtsexample

@see GuiControl */
   virtual void addText(( string text, bool reformat=true )) {}
   /*! @brief Change the text cursor's position to a new defined offset within the text in the control.

@param newPos Offset to place cursor.
@tsexample
// Define cursor offset position
%position = "23";

// Inform the GuiMLTextCtrl object to move the cursor to the new position.
%thisGuiMLTextCtrl.setCursorPosition(%position);
@endtsexample

@return Returns true if the cursor position moved, or false if the position was not changed.

@see GuiControl */
   virtual bool setCursorPosition(( int newPos )) {}
   /*! @brief Scroll down to a specified tag.

Detailed description

@param tagID TagID to scroll the control to
@tsexample
// Define the TagID we want to scroll the control to
%tagId = "4";

// Inform the GuiMLTextCtrl to scroll to the defined TagID
%thisGuiMLTextCtrl.scrollToTag(%tagId);
@endtsexample

@see GuiControl */
   virtual void scrollToTag(( int tagID )) {}
   /*! @brief Scroll to the top of the text.

@tsexample
// Inform GuiMLTextCtrl object to scroll to its top
%thisGuiMLTextCtrl.scrollToTop();
@endtsexample

@see GuiControl */
   virtual void scrollToTop(( int param1, int param2 )) {}
   /*! @brief Scroll to the bottom of the text.

@tsexample
// Inform GuiMLTextCtrl object to scroll to its bottom
%thisGuiMLTextCtrl.scrollToBottom();
@endtsexample

@see GuiControl */
   virtual void scrollToBottom(()) {}
   /*! @brief Forces the text control to reflow the text after new text is added, possibly resizing the control.

@tsexample
// Define new text to add
%newText = "BACON!";

// Add the new text to the control
%thisGuiMLTextCtrl.addText(%newText);

// Inform the GuiMLTextCtrl object to force a reflow to ensure the added text fits properly.
%thisGuiMLTextCtrl.forceReflow();
@endtsexample

@see GuiControl */
   virtual void forceReflow(()) {}
   /*! @brief Sets the alpha value of the control.

@param alphaVal n - 1.0 floating value for the alpha
@tsexample
// Define the alphe value
%alphaVal = "0.5";

// Inform the control to update its alpha value.
%thisGuiMLTextCtrl.setAlpha(%alphaVal);
@endtsexample

@see GuiControl */
   virtual void setAlpha(( float alphaVal )) {}

   /*! @name Text
   @{ */
   /*! */
   /*!
   The number of blank pixels to place between each line.

   
    */
   int lineSpacing;
   /*!
   If true, the control will allow characters to have unique colors.
   
    */
   bool allowColorChars;
   /*!
   Maximum number of characters that the control will display.
   
    */
   int maxChars;
   /*!
   If the text will not fit in the control, the deniedSound is played.
   
    */
   SFXTrack deniedSound;
   /*!
   Text to display in this control.
   
    */
   caseString text;
   /*!
   If true, the mouse cursor will turn into a hand cursor while over a link in the text.
This is dependant on the markup language used by the GuiMLTextCtrl

   
    */
   bool useURLMouseCursor;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A text entry control that accepts the Gui Markup Language ('ML') tags and multiple lines.

@tsexample
new GuiMLTextEditCtrl()
^{
^^lineSpacing = "2";
^^allowColorChars = "0";
^^maxChars = "-1";
^^deniedSound = "DeniedSoundProfile";
^^text = "";
^^escapeCommand = "onEscapeScriptFunction();";
^  //Properties not specific to this control have been omitted from this example.
^};
@endtsexample

@see GuiMLTextCtrl
@see GuiControl

@ingroup GuiControls
 */
class  GuiMLTextEditCtrl : public GuiMLTextCtrl {
  public:
   /*!
   Script function to run whenever the 'escape' key is pressed when this control is in focus.

   
    */
   string escapeCommand;

   /*! @name Text
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI Control which displays a numerical value which can be increased or decreased using a pair of bitmap up/down buttons. 

This control uses the bitmap specified in it's profile (GuiControlProfile::bitmapName). It takes this image and breaks up aspects of it to render the up and down arrows. It is also important to set GuiControlProfile::hasBitmapArray to true on the profile as well.

The bitmap referenced should be broken up into a 1 x 4 grid (using the top left color pixel as a border color between each of the images) in which it will map to the following places:
<ol>
<li>Up arrow active</li>
<li>Up arrow inactive</li>
<li>Down arrow active</li>
<li>Down arrow inactive</li>
</ol>

<pre>
1
2
3
4</pre>

@tsexample
singleton GuiControlProfile (SliderBitmapGUIProfile)
{
   bitmap = "core/art/gui/images/sliderArray";
   hasBitmapArray = true;
   opaque = false;
};

new GuiTextEditSliderBitmapCtrl()
{
   profile = "SliderBitmapGUIProfile";
   format = "%3.2f";
   range = "-1e+03 1e+03";
   increment = "0.1";
   focusOnMouseWheel = "0";
   bitmap = "";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiTextEditSliderCtrl

@see GuiTextEditCtrl

@ingroup GuiCore
 */
class  GuiTextEditSliderBitmapCtrl : public GuiTextEditCtrl {
  public:
   /*!
   Character format type to place in the control.

   
    */
   string format;
   /*!
   Maximum vertical and horizontal range to allow in the control.

   
    */
   Point2F range;
   /*!
   How far to increment the slider on each step.

   
    */
   float increment;
   /*!
   If true, the control will accept giving focus to the user when the mouse wheel is used.

   
    */
   bool focusOnMouseWheel;
   /*!
   Unused
   
    */
   filename bitmap;

   /*! @name Text Input
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI Control which displays a numerical value which can be increased or decreased using a pair of arrows.

@tsexample
new GuiTextEditSliderCtrl()
{
   format = "%3.2f";
   range = "-1e+03 1e+03";
   increment = "0.1";
   focusOnMouseWheel = "0";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiTextEditCtrl

@ingroup GuiCore
 */
class  GuiTextEditSliderCtrl : public GuiTextEditCtrl {
  public:
   /*!
   Character format type to place in the control.

   
    */
   string format;
   /*!
   Maximum vertical and horizontal range to allow in the control.

   
    */
   Point2F range;
   /*!
   How far to increment the slider on each step.

   
    */
   float increment;
   /*!
   If true, the control will accept giving focus to the user when the mouse wheel is used.

   
    */
   bool focusOnMouseWheel;

   /*! @name Text Input
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Acts as a skin for the cursor, where each GuiCursor object can have its own look and click-zone.

GuiCursors act as skins for the cursor in the game, where each individual GuiCursor can have its own defined imagemap,
click zone and render offset. This allows a game to easily support a wide range of cursors. The active cursor can de changed
for each Canvas using %canvasObj.setCursor(GuiCursor);.@tsexample
new GuiCursor(DefaultCursor)
{
^hotSpot = "1 1";
^renderOffset = "0 0";
^bitmapName = "~/art/gui/images/defaultCursor";
};
@endtsexample

@see GuiCanvas

@ingroup GuiCore
 */
class  GuiCursor : public SimObject {
  public:
   /*!
   The location of the cursor's hot spot (which pixel carries the click).
   
    */
   Point2I hotSpot;
   /*!
   Offset of the bitmap, where 0 signifies left edge of the bitmap, 1, the right. Similarly for the Y-component.
   
    */
   Point2F renderOffset;
   /*!
   File name of the bitmap for the cursor.
   
    */
   filename bitmapName;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Control to visualize an EaseF.

Editor use only.

@see EaseF

 */
class  GuiEaseViewCtrl : public GuiControl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

   /*!
    */
   EaseF ease;
   /*!
    */
   ColorF easeColor;
   /*!
    */
   float easeWidth;
   /*!
    */
   ColorF axisColor;
};

/*!
@brief Visual representation of markers on top and left sides of GUI Editor

Editor use only.

 */
class  GuiEditorRuler : public GuiControl {
  public:
   /*!
    */
   string refCtrl;
   /*!
    */
   string editCtrl;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The GuiInspectorField control is a representation of a single abstract field for a given ConsoleObject derived object.

Editor use only.

 */
class  GuiInspectorField : public GuiControl {
  public:
   /*! Return the GuiInspector to which this field belongs. */
   virtual int getInspector(()) {}
   /*! Return the name of the field edited by this inspector field. */
   virtual string getInspectedFieldName(()) {}
   /*! Return the type of the field edited by this inspector field. */
   virtual string getInspectedFieldType(()) {}
   /*! Set the field's value. Suppress callbacks for undo if callbacks=false. */
   virtual void apply(( string newValue, bool callbacks=true )) {}
   /*! Set field value without recording undo (same as 'apply( value, false )'). */
   virtual void applyWithoutUndo(()) {}
   /*! Return the value currently displayed on the field. */
   virtual string getData(()) {}
   /*! Reset to default value. */
   virtual void reset(()) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for MenuBase

Editor use only.

 */
class  GuiInspectorTypeMenuBase : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Enum

Editor use only.

 */
class  GuiInspectorTypeEnum : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Cubemap

Editor use only.

 */
class  GuiInspectorTypeCubemapName : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Material

Editor use only.

 */
class  GuiInspectorTypeMaterialName : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TerrainMaterialIndex

Editor use only.

 */
class  GuiInspectorTypeTerrainMaterialIndex : public GuiInspectorTypeMaterialName {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TerrainMaterial

Editor use only.

 */
class  GuiInspectorTypeTerrainMaterialName : public GuiInspectorTypeMaterialName {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for GuiProfile

Editor use only.

 */
class  GuiInspectorTypeGuiProfile : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for CheckBox

Editor use only.

 */
class  GuiInspectorTypeCheckBox : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for FileName

Editor use only.

 */
class  GuiInspectorTypeFileName : public GuiInspectorField {
  public:
   /*! apply(newValue); */
   virtual void apply() {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for FileName

Editor use only.

 */
class  GuiInspectorTypeImageFileName : public GuiInspectorTypeFileName {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for PrefabFilename

Editor use only.

 */
class  GuiInspectorTypePrefabFilename : public GuiInspectorTypeFileName {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Shapes

Editor use only.

 */
class  GuiInspectorTypeShapeFilename : public GuiInspectorTypeFileName {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Command

Editor use only.

 */
class  GuiInspectorTypeCommand : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TypeRectUV.

Editor use only.

 */
class  GuiInspectorTypeRectUV : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TypeEaseF.

Editor use only.

 */
class  GuiInspectorTypeEaseF : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TypeColor

Editor use only.

 */
class  GuiInspectorTypeColor : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for ColorI

Editor use only.

 */
class  GuiInspectorTypeColorI : public GuiInspectorTypeColor {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for ColorF

Editor use only.

 */
class  GuiInspectorTypeColorF : public GuiInspectorTypeColor {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for S32

Editor use only.

 */
class  GuiInspectorTypeS32 : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type support for TypeBitMask32.

Editor use only.

 */
class  GuiInspectorTypeBitMask32Helper : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for Name

Editor use only.

 */
class  GuiInspectorTypeName : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXParameter

Editor use only.

 */
class  GuiInspectorTypeSFXParameterName : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXState

Editor use only.

 */
class  GuiInspectorTypeSFXStateName : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXSource

Editor use only.

 */
class  GuiInspectorTypeSFXSourceName : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Draws a box with handles for the user to manipulate.

Editor use only.

 */
class  GuiRectHandles : public GuiControl {
  public:
   /*!
   RectF of handle's box.
   
    */
   RectF handleRect;
   /*!
   Size of handles in pixels.
   
    */
   int handleSize;
   /*!
   Use given custom color for handles.
   
    */
   bool useCustomColor;
   /*!
   Use given custom color for handles.
   
    */
   ColorI handleColor;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that renders a horizontal or vertical separator with an optional text label (horizontal only)

@tsexample
new GuiSeparatorCtrl()
{
   profile = "GuiDefaultProfile";
   position = "505 0";
   extent = "10 17";
   minExtent = "10 17";
   canSave = "1";
   visible = "1";
   horizSizing = "left";
};
@endtsexample

@ingroup GuiControls
 */
class  GuiSeparatorCtrl : public GuiControl {
  public:
   /*!
   Optional text label to display.
   
    */
   string caption;
   /*!
   Orientation of separator.
   
    */
   GuiSeparatorType type;
   /*!
    */
   int borderMargin;
   /*!
    */
   bool invisible;
   /*!
   Left margin of text label.
   
    */
   int leftMargin;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that allows to edit the custom properties (text) of one or more SimObjects.

Editor use only.

 */
class  GuiInspectorCustomField : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Custom field type for datablock enumeration.

Editor use only.

 */
class  GuiInspectorDatablockField : public GuiInspectorTypeMenuBase {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXDescriptionName

Editor use only.

 */
class  GuiInspectorTypeSFXDescriptionName : public GuiInspectorDatablockField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXTrackName

Editor use only.

 */
class  GuiInspectorTypeSFXTrackName : public GuiInspectorDatablockField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXEnvironment

Editor use only.

 */
class  GuiInspectorTypeSFXEnvironmentName : public GuiInspectorDatablockField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for SFXAmbience

Editor use only.

 */
class  GuiInspectorTypeSFXAmbienceName : public GuiInspectorDatablockField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that shows a single child with an optional header bar that can be used to collapse and expand the rollout.

A rollout is a container that can be collapsed and expanded using smooth animation.  By default, rollouts will display a header with a caption along the top edge of the control which can be clicked by the user to toggle the collapse state of the rollout.

Rollouts will automatically size themselves to exactly fit around their child control.  They will also automatically position their child control in their upper left corner below the header (if present).

@note GuiRolloutCtrls will only work correctly with a single child control.  To put multiple controls in a rollout, put them in their own group using a new GuiControl which then can be put inside the rollout.

 */
class  GuiRolloutCtrl : public GuiControl {
  public:
      /*! Called when the user right-clicks on the rollout's header.  This is useful for implementing context menus for rollouts. */
      void onHeaderRightClick();

      /*! Called when the rollout is expanded. */
      void onExpanded();

      /*! Called when the rollout is collapsed. */
      void onCollapsed();

   /*! Determine whether the rollout is currently expanded, i.e. whether the child control is visible.

@return True if the rollout is expanded, false if not. */
   virtual bool isExpanded(()) {}
   /*! Collapse the rollout if it is currently expanded.  This will make the rollout's child control invisible.

@note The rollout will animate to collapsed state.  To instantly collapse without animation, use instantCollapse(). */
   virtual void collapse(()) {}
   /*! Expand the rollout if it is currently collapsed.  This will make the rollout's child control visible.

@note The rollout will animate to expanded state.  To instantly expand without animation, use instantExpand(). */
   virtual void expand(()) {}
   /*! Toggle the current collapse state of the rollout.  If it is currently expanded, then collapse it.  If it is currently collapsed, then expand it. */
   virtual void toggleCollapse(()) {}
   /*! Toggle the current expansion state of the rollout  If it is currently expanded, then collapse it.  If it is currently collapsed, then expand it.

@param instant If true, the rollout will toggle its state without animation.  Otherwise, the rollout will smoothly slide into the opposite state. */
   virtual void toggleExpanded(( bool instantly=false )) {}
   /*! Instantly collapse the rollout without animation.  To smoothly slide the rollout to collapsed state, use collapse(). */
   virtual void instantCollapse(()) {}
   /*! Instantly expand the rollout without animation.  To smoothly slide the rollout to expanded state, use expand(). */
   virtual void instantExpand(()) {}
   /*! Resize the rollout to exactly fit around its child control.  This can be used to manually trigger a recomputation of the rollout size. */
   virtual void sizeToContents(()) {}

   /*! @name Rollout
   @{ */
   /*! */
   /*!
   Text label to display on the rollout header.
   
    */
   string caption;
   /*!
   Margin to put around child control.
   
    */
   RectI margin;
   /*!
   Default height of the client area.  This is used when no child control has been added to the rollout.
   
    */
   int defaultHeight;
   /*!
   The current rollout expansion state.
   
    */
   bool expanded;
   /*!
   Whether the rollout can be collapsed by clicking its header.
   
    */
   bool clickCollapse;
   /*!
   Whether to render the rollout header.

@note If this is false, the user cannot toggle the rollout state with the mouse.
   
    */
   bool hideHeader;
   /*!
   Whether to automatically collapse sibling rollouts.

If this is true, the rollout will automatically collapse all sibling rollout controls when it is expanded.  If this is false, the auto-collapse behavior can be triggered by CTRL (CMD on MAC) clicking the rollout header.  CTRL/CMD clicking also works if this is false, in which case the auto-collapsing of sibling controls will be temporarily deactivated.
   
    */
   bool autoCollapseSiblings;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The GuiInspectorGroup control is a helper control that the inspector makes use of which houses a collapsible pane type control for separating inspected objects fields into groups.

Editor use only.

 */
class  GuiInspectorGroup : public GuiRolloutCtrl {
  public:

   /*! @name Rollout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector support for variables in a GuiVariableInspector.

Editor use only.

 */
class  GuiInspectorVariableField : public GuiInspectorField {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector support for variable groups in a GuiVariableInspector.

Editor use only.

 */
class  GuiInspectorVariableGroup : public GuiInspectorGroup {
  public:

   /*! @name Rollout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI Control which displays a horizontal bar which increases as the progress value of 0.0 - 1.0 increases.

@tsexample
     new GuiProgressCtrl(JS_statusBar)
^ {
^^    //Properties not specific to this control have been omitted from this example.
     };

// Define the value to set the progress bar%value = "0.5f"

// Set the value of the progress bar, from 0.0 - 1.0
%thisGuiProgressCtrl.setValue(%value);
// Get the value of the progress bar.
%progress = %thisGuiProgressCtrl.getValue();
@endtsexample

@see GuiTextCtrl
@see GuiControl

@ingroup GuiValues
 */
class  GuiProgressCtrl : public GuiTextCtrl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A single-line text control that displays its text in a multi-line popup when clicked.

This control acts like a GuiTextCtrl (and inherits from it), when clicked it creates a GuiMLTextCtrl roughly where you clicked with the same text in it.  This allows you to have a single line text control which upon clicking will display the entire text contained in a multi-line format.

@tsexample
new GuiBubbleTextCtrl(BubbleTextGUI)
{
   text = "This is the first sentence.  This second sentence can be sized outside of the default single line view, upon clicking this will be displayed in a multi-line format.";
};
@endtsexample

@see GuiTextCtrl
@see GuiMLTextCtrl

@ingroup GuiControls
 */
class  GuiBubbleTextCtrl : public GuiTextCtrl {
  public:

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This class contains behavior and rendering properties used by the Gizmo class

Not intended for game development, for editors or internal use only.

 */
class  GizmoProfile : public SimObject {
  public:
   /*!
    */
   GizmoAlignment alignment;
   /*!
    */
   GizmoMode mode;
   /*!
    */
   bool snapToGrid;
   /*!
    */
   bool allowSnapRotations;
   /*!
    */
   float rotationSnap;
   /*!
    */
   bool allowSnapScale;
   /*!
    */
   float scaleSnap;
   /*!
    */
   bool renderWhenUsed;
   /*!
    */
   bool renderInfoText;
   /*!
    */
   bool renderPlane;
   /*!
    */
   bool renderPlaneHashes;
   /*!
    */
   bool renderSolid;
   /*!
    */
   bool renderMoveGrid;
   /*!
    */
   ColorI gridColor;
   /*!
    */
   float planeDim;
   /*!
    */
   Point3F gridSize;
   /*!
    */
   int screenLength;
   /*!
    */
   float rotateScalar;
   /*!
    */
   float scaleScalar;
   /*!
    */
   int flags;
};

/*!
@brief This class contains code for rendering and manipulating a 3D gizmo

It is usually used as a helper within a TSEdit-derived control. Not intended for game development, for editors or internal use only.

 */
class  Gizmo : public SimObject {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An event which signals the editors to undo the last action

Not intended for game development, for editors or internal use only.

 */
class  UndoAction : public SimObject {
  public:
   /*! action.addToManager([undoManager]) */
   virtual void addToManager() {}
   /*! Undo action contained in undo. */
   virtual void undo(()) {}
   /*! Reo action contained in undo. */
   virtual void redo(()) {}
   /*!
   A brief description of the action, for UI representation of this undo/redo action.
   
    */
   string actionName;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Decal Instance Create Undo Actions

Not intended for game development, for editors or internal use only.

 */
class  DICreateUndoAction : public UndoAction {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Decal Instance Delete Undo Actions

Not intended for game development, for editors or internal use only.

 */
class  DIDeleteUndoAction : public UndoAction {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Decal Datablock Delete Undo Actions

Not intended for game development, for editors or internal use only.

 */
class  DBDeleteUndoAction : public UndoAction {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Decal Datablock Retarget Undo Actions

Not intended for game development, for editors or internal use only.

 */
class  DBRetargetUndoAction : public UndoAction {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector Field undo action instance

Not intended for game development, for editors or internal use only.

 */
class  InspectorFieldUndoAction : public UndoAction {
  public:
   /*!
    */
   GuiInspector inspectorGui;
   /*!
    */
   int objectId;
   /*!
    */
   string fieldName;
   /*!
    */
   string fieldValue;
   /*!
    */
   string arrayIndex;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The abstract base for all render bins.

The render bins are used by the engine as a high level method to order and batch rendering operations.
@ingroup RenderBin
 */
class  RenderBinManager : public SimObject {
  public:
   /*! Returns the bin type string. */
   virtual string getBinType(()) {}
   /*!
   Sets the render bin type which limits what render instances are added to this bin.
   
    */
   string binType;
   /*!
   Defines the order for rendering in relation to other bins.
   
    */
   float renderOrder;
   /*!
   Defines the order for adding instances in relation to other bins.
   
    */
   float processAddOrder;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An abstract base class for render bin managers that render to a named textue target.

This bin itself doesn't do any rendering work.  It offers functionality to manage a texture render target which derived render bin classes can render into.

@see RenderPrePassMgr
@ingroup RenderBin
 */
class  RenderTexTargetBinManager : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Rendering Manager responsible for lighting, shadows, and global variables affecing both.

Should not be exposed to TorqueScript as a game object, meant for internal use only

 */
class  AdvancedLightBinManager : public RenderTexTargetBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A material in Torque 3D is a data structure that describes a surface.

It contains many different types of information for rendering properties. Torque 3D generates shaders from Material definitions. The shaders are compiled at runtime and output into the example/shaders directory. Any errors or warnings generated from compiling the procedurally generated shaders are output to the console as well as the output window in the Visual C IDE.

@tsexample
singleton Material(DECAL_scorch)
{
^baseTex[0] = "./scorch_decal.png";
^vertColor[ 0 ] = true;

^translucent = true;
^translucentBlendOp = None;
^translucentZWrite = true;
^alphaTest = true;
^alphaRef = 84;
};
@endtsexample

@see Rendering
@see ShaderData
@ingroup GFX
 */
class  Material : public SimObject {
  public:
   /*! Flushes all material instances that use this material. */
   virtual void flush() {}
   /*! Reloads all material instances that use this material. */
   virtual void reload() {}
   /*! Dumps a formatted list of the currently allocated material instances for this material to the console. */
   virtual void dumpInstances() {}
   virtual string getAnimFlags() {}
   /*! Get filename of material */
   virtual string getFilename() {}
   /*! Returns true if this Material was automatically generated by MaterialList::mapMaterials() */
   virtual bool isAutoGenerated() {}
   /*! setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated. */
   virtual void setAutoGenerated() {}
   /*!
   Used to map this material to the material name used by TSShape.
   
    */
   string mapTo;
   /*!
   This color is multiplied against the diffuse texture color.  If no diffuse texture is present this is the material color.
   
    */
   ColorF diffuseColor;
   /*!
   The diffuse color texture map.
   
    */
   filename diffuseMap;
   /*!
   A secondary diffuse color texture map which will use the second texcoord of a mesh.
   
    */
   filename overlayMap;
   /*!
   The lightmap texture used with pureLight.
   
    */
   filename lightMap;
   /*!
   The tonemap texture used with pureLight.
   
    */
   filename toneMap;
   /*!
   A typically greyscale detail texture additively blended into the material.
   
    */
   filename detailMap;
   /*!
   The scale factor for the detail map.
   
    */
   Point2F detailScale;
   /*!
   The normal map texture.  You can use the DXTnm format only when per-pixel specular highlights are disabled, or a specular map is in use.
   
    */
   filename normalMap;
   /*!
   A second normal map texture applied at the detail scale.  You can use the DXTnm format only when per-pixel specular highlights are disabled.
   
    */
   filename detailNormalMap;
   /*!
   Used to scale the strength of the detail normal map when blended with the base normal map.
   
    */
   float detailNormalMapStrength;
   /*!
   The color of the specular highlight when not using a specularMap.
   
    */
   ColorF specular;
   /*!
   The hardness of the specular highlight when not using a specularMap.
   
    */
   float specularPower;
   /*!
   The strength of the specular highlight when not using a specularMap.
   
    */
   float specularStrength;
   /*!
   This enables per-pixel specular highlights controlled by the alpha channel of the normal map texture.  Note that if pixel specular is enabled the DXTnm format will not work with your normal map, unless you are also using a specular map.
   
    */
   bool pixelSpecular;
   /*!
   The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. This provides a per-pixel replacement for the 'specularPower' on the material
   
    */
   filename specularMap;
   /*!
   Enables parallax mapping and defines the scale factor for the parallax effect.  Typically this value is less than 0.4 else the effect breaks down.
   
    */
   float parallaxScale;
   /*!
   Use anisotropic filtering for the textures of this stage.
   
    */
   bool useAnisotropic;
   /*!
   The name of an environment map cube map to apply to this material.
   
    */
   filename envMap;
   /*!
   If true the vertex color is used for lighting.
   
    */
   bool vertLit;
   /*!
   If enabled, vertex colors are premultiplied with diffuse colors.
   
    */
   bool vertColor;
   /*!
   The Minnaert shading constant value.  Must be greater than 0 to enable the effect.
   
    */
   float minnaertConstant;
   /*!
   Enables the subsurface scattering approximation.
   
    */
   bool subSurface;
   /*!
   The color used for the subsurface scattering approximation.
   
    */
   ColorF subSurfaceColor;
   /*!
   The 0 to 1 rolloff factor used in the subsurface scattering approximation.
   
    */
   float subSurfaceRolloff;
   /*!
   Enables rendering this material to the glow buffer.
   
    */
   bool glow;
   /*!
   Enables emissive lighting for the material.
   
    */
   bool emissive;
   /*!
   Disables backface culling casing surfaces to be double sided. Note that the lighting on the backside will be a mirror of the front side of the surface.
   
    */
   bool doubleSided;
   /*!
   The types of animation to play on this material.
   
    */
   MaterialAnimType animFlags;
   /*!
   The scroll direction in UV space when scroll animation is enabled.
   
    */
   Point2F scrollDir;
   /*!
   The speed to scroll the texture in UVs per second when scroll animation is enabled.
   
    */
   float scrollSpeed;
   /*!
   The speed to rotate the texture in degrees per second when rotation animation is enabled.
   
    */
   float rotSpeed;
   /*!
   The piviot position in UV coordinates to center the rotation animation.
   
    */
   Point2F rotPivotOffset;
   /*!
   The type of wave animation to perform when wave animation is enabled.
   
    */
   MaterialWaveType waveType;
   /*!
   The wave frequency when wave animation is enabled.
   
    */
   float waveFreq;
   /*!
   The wave amplitude when wave animation is enabled.
   
    */
   float waveAmp;
   /*!
   The number of frames per second for frame based sequence animations if greater than zero.
   
    */
   float sequenceFramePerSec;
   /*!
   The size of each frame in UV units for sequence animations.
   
    */
   float sequenceSegmentSize;
   /*!
   @internal
   
    */
   Point2I cellIndex;
   /*!
   @internal
   
    */
   Point2I cellLayout;
   /*!
   @internal
   
    */
   int cellSize;
   /*!
   @internal
   
    */
   bool bumpAtlas;
   /*!
   For backwards compatibility.
@see diffuseMap

   
    */
   filename baseTex;
   /*!
   For backwards compatibility.
@see detailMap

   
    */
   filename detailTex;
   /*!
   For backwards compatibility.
@see overlayMap

   
    */
   filename overlayTex;
   /*!
   For backwards compatibility.
@see normalMap

   
    */
   filename bumpTex;
   /*!
   For backwards compatibility.
@see envMap

   
    */
   filename envTex;
   /*!
   For backwards compatibility.
@see diffuseColor

   
    */
   ColorF colorMultiply;
   /*!
   Forces the materials texture coordinates to clamp instead of wrap.
   
    */
   bool edgeClamp;
   /*!
   If set to false the lighting system will not cast shadows from this material.
   
    */
   bool castShadows;
   /*!
   @internal
   
    */
   bool planarReflection;
   /*!
   If true this material is translucent blended.
   
    */
   bool translucent;
   /*!
   The type of blend operation to use when the material is translucent.
   
    */
   MaterialBlendOp translucentBlendOp;
   /*!
   If enabled and the material is translucent it will write into the depth buffer.
   
    */
   bool translucentZWrite;
   /*!
   Enables alpha test when rendering the material.
@see alphaRef

   
    */
   bool alphaTest;
   /*!
   The alpha reference value for alpha testing.  Must be between 0 to 255.
@see alphaTest

   
    */
   int alphaRef;
   /*!
   The name of a CubemapData for environment mapping.
   
    */
   string cubemap;
   /*!
   Enables the material to use the dynamic cubemap from the ShapeBase object its applied to.
   
    */
   bool dynamicCubemap;

   /*! @name Behavioral
   @{ */
   /*! */
   /*!
   Whether to show player footprint decals on this material.

@see PlayerData::decalData
   
    */
   bool showFootprints;
   /*!
   Whether to emit dust particles from a shape moving over the material.  This is, for example, used by vehicles or players to decide whether to show dust trails.
   
    */
   bool showDust;
   /*!
   If #showDust is true, this is the set of colors to use for the ParticleData of the dust emitter.

@see ParticleData::colors
   
    */
   ColorF effectColor;
   /*!
   What sound to play from the PlayerData sound list when the player walks over the material.  -1 (default) to not play any sound.

The IDs are:

- 0: PlayerData::FootSoftSound
- 1: PlayerData::FootHardSound
- 2: PlayerData::FootMetalSound
- 3: PlayerData::FootSnowSound
- 4: PlayerData::FootShallowSound
- 5: PlayerData::FootWadingSound
- 6: PlayerData::FootUnderwaterSound
- 7: PlayerData::FootBubblesSound
- 8: PlayerData::movingBubblesSound
- 9: PlayerData::waterBreathSound
- 10: PlayerData::impactSoftSound
- 11: PlayerData::impactHardSound
- 12: PlayerData::impactMetalSound
- 13: PlayerData::impactSnowSound
- 14: PlayerData::impactWaterEasy
- 15: PlayerData::impactWaterMedium
- 16: PlayerData::impactWaterHard
- 17: PlayerData::exitingWater

   
    */
   int footstepSoundId;
   /*!
   The sound to play when the player walks over the material.  If this is set, it overrides #footstepSoundId.  This field is useful for directly assigning custom footstep sounds to materials without having to rely on the PlayerData sound assignment.

@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too.
   
    */
   SFXTrack customFootstepSound;
   /*!
   What sound to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.

For a list of IDs, see #footstepSoundId
   
    */
   int impactSoundId;
   /*!
   The sound to play when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.  If this is set, it overrides #impactSoundId.  This field is useful for directly assigning custom impact sounds to materials without having to rely on the PlayerData sound assignment.

@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too.
   
    */
   SFXTrack customImpactSound;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Material object which provides more control over surface properties.

CustomMaterials allow the user to specify their own shaders via the ShaderData datablock. Because CustomMaterials are derived from Materials, they can hold a lot of the same properties. It is up to the user to code how these properties are used.

@tsexample
singleton CustomMaterial( WaterBasicMat )
{
   sampler["reflectMap"] = "$reflectbuff";
   sampler["refractBuff"] = "$backbuff";

   cubemap = NewLevelSkyCubemap;
   shader = WaterBasicShader;
   stateBlock = WaterBasicStateBlock;
   version = 2.0;
};
@endtsexample

@see Material, GFXStateBlockData, ShaderData

@ingroup Materials
 */
class  CustomMaterial : public Material {
  public:
   /*!
   @brief Specifies pixel shader version for hardware.

Valid pixel shader versions include 2.0, 3.0, etc. @note All features aren't compatible with all pixel shader versions.
   
    */
   float version;
   /*!
   @brief Alternate material for targeting lower end hardware.

If the CustomMaterial requires a higher pixel shader version than the one it's using, it's fallback Material will be processed instead. If the fallback material wasn't defined, Torque 3D will assert and attempt to use a very basic material in it's place.


   
    */
   Material fallback;
   /*!
   @brief Name of the ShaderData to use for this effect.


   
    */
   string shader;
   /*!
   @brief Name of a GFXStateBlockData for this effect.


   
    */
   GFXStateBlockData stateBlock;
   /*!
   @brief String identifier of this material's target texture.
   
    */
   string target;
   /*!
   @brief Determines if the material should recieve lights in Basic Lighting. Has no effect in Advanced Lighting.


   
    */
   bool forwardLit;

   /*! @name Behavioral
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A fullscreen shader effect.

@section PFXTextureIdentifiers

@ingroup Rendering
 */
class  PostEffect : public SimGroup {
  public:
      /*! Called when this object is first created and registered. */
      void onAdd();

      /*! Called when an effect is processed but before textures are bound. This allows the user to change texture related paramaters or macros at runtime.
@tsexample
function SSAOPostFx::preProcess( %this )
{
   if ( $SSAOPostFx::quality !$= %this.quality )
   {
      %this.quality = mClamp( mRound( $SSAOPostFx::quality ), 0, 2 );
      
      %this.setShaderMacro( "QUALITY", %this.quality );
   }
   %this.targetScale = $SSAOPostFx::targetScale;
}
@endtsexample
@see setShaderConst
@see setShaderMacro */
      void preProcess();

      /*! Called immediate before processing this effect. This is the user's chance to set the value of shader uniforms (constants).
@see setShaderConst */
      void setShaderConsts();

      /*! Called when this effect becomes enabled. If the user returns false from this callback the effect will not be enabled.
@return True to allow this effect to be enabled. */
      bool onEnabled();

      /*! Called when this effect becomes disabled. */
      void onDisabled();

   /*! Reloads the effect shader and textures. */
   virtual void reload(()) {}
   /*! Enables the effect. */
   virtual void enable(()) {}
   /*! Disables the effect. */
   virtual void disable(()) {}
   /*! Toggles the effect between enabled / disabled.
@return True if effect is enabled. */
   virtual bool toggle(()) {}
   /*! @return True if the effect is enabled. */
   virtual bool isEnabled(()) {}
   /*! This is used to set the texture file and load the texture on a running effect. If the texture file is not different from the current file nothing is changed.  If the texture cannot be found a null texture is assigned.
@param index The texture stage index.
@param filePath The file name of the texture to set.
 */
   virtual void setTexture(( int index, string filePath )) {}
   /*! Sets the value of a uniform defined in the shader. This will usually be called within the setShaderConsts callback. Array type constants are not supported.
@param name Name of the constanst, prefixed with '$'.
@param value Value to set, space seperate values with more than one element.
@tsexample
function MyPfx::setShaderConsts( %this )
{
   // example float4 uniform
   %this.setShaderConst( "$colorMod", "1.0 0.9 1.0 1.0" );
   // example float1 uniform
   %this.setShaderConst( "$strength", "3.0" );
   // example integer uniform
   %this.setShaderConst( "$loops", "5" );}
@endtsexample */
   virtual void setShaderConst(( string name, string value )) {}
   /*! @return Width over height of the backbuffer. */
   virtual float getAspectRatio(()) {}
   /*! Dumps this PostEffect shader's disassembly to a temporary text file.
@return Full path to the dumped file or an empty string if failed. */
   virtual string dumpShaderDisassembly(()) {}
   /*! Adds a macro to the effect's shader or sets an existing one's value. This will usually be called within the onAdd or preProcess callback.
@param key lval of the macro.@param value rval of the macro, or may be empty.@tsexample
function MyPfx::onAdd( %this )
{
   %this.setShaderMacro( "NUM_SAMPLES", "10" );
   %this.setShaderMacro( "HIGH_QUALITY_MODE" );
   
   // In the shader looks like... 
   // #define NUM_SAMPLES 10
   // #define HIGH_QUALITY_MODE
}
@endtsexample */
   virtual void setShaderMacro(( string key, string value="" )) {}
   /*! Remove a shader macro. This will usually be called within the preProcess callback.
@param key Macro to remove. */
   virtual void removeShaderMacro(( string key )) {}
   /*! Remove all shader macros. */
   virtual void clearShaderMacros(()) {}
   /*!
   Name of a GFXShaderData for this effect.
   
    */
   string shader;
   /*!
   Name of a GFXStateBlockData for this effect.
   
    */
   GFXStateBlockData stateBlock;
   /*!
   String identifier of this effect's target texture.
@see PFXTextureIdentifiers
   
    */
   string target;
   /*!
   Optional string identifier for this effect's target depth/stencil texture.
@see PFXTextureIdentifiers
   
    */
   string targetDepthStencil;
   /*!
   If targetSize is zero this is used to set a relative size from the current target.
   
    */
   Point2F targetScale;
   /*!
   If non-zero this is used as the absolute target size.
   
    */
   Point2I targetSize;
   /*!
   Format of the target texture, not applicable if writing to the backbuffer.
   
    */
   GFXFormat targetFormat;
   /*!
   Color to which the target texture is cleared before rendering.
   
    */
   ColorF targetClearColor;
   /*!
   Describes when the target texture should be cleared.
   
    */
   PFXTargetClear targetClear;
   /*!
   Specifies how the viewport should be set up for a target texture.
   
    */
   PFXTargetViewport targetViewport;
   /*!
   Input textures to this effect ( samplers ).
@see PFXTextureIdentifiers
   
    */
   filename texture;
   /*!
   When to process this effect during the frame.
   
    */
   PFXRenderTime renderTime;
   /*!
   Name of a renderBin, used if renderTime is PFXBeforeBin or PFXAfterBin.
   
    */
   string renderBin;
   /*!
   PostEffects are processed in DESCENDING order of renderPriority if more than one has the same renderBin/Time.
   
    */
   float renderPriority;
   /*!
   Is this effect processed during reflection render passes.
   
    */
   bool allowReflectPass;
   /*!
   Is the effect on.
   
    */
   bool isEnabled;
   /*!
   Allows you to turn on a PostEffect for only a single frame.
   
    */
   bool onThisFrame;
   /*!
   Allows you to turn on a PostEffect for only a single frame.
   
    */
   bool oneFrameOnly;
   /*!
   Skip processing of this PostEffect and its children even if its parent is enabled. Parent and sibling PostEffects in the chain are still processed.
   
    */
   bool skip;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A fullscreen shader effect used with the Oculus Rift.

@section PFXTextureIdentifiers

@ingroup Rendering
 */
class  BarrelDistortionPostEffect : public PostEffect {
  public:
   /*!
   Oculus VR HMD index to reference.
   
    */
   int hmdIndex;
   /*!
   Oculus VR sensor index to reference.
   
    */
   int sensorIndex;
   /*!
   Used to increase the size of the window into the world at the expense of apparent resolution.
   
    */
   float scaleOutput;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class responsible for displaying an OS file browser.

FileDialog is a platform agnostic dialog interface for querying the user for file locations. It is designed to be used through the exposed scripting interface.

FileDialog is the base class for Native File Dialog controls in Torque. It provides these basic areas of functionality:

   - Inherits from SimObject and is exposed to the scripting interface
   - Provides blocking interface to allow instant return to script execution
   - Simple object configuration makes practical use easy and effective

FileDialog is *NOT* intended to be used directly in script and is only exposed to script to expose generic file dialog attributes.

This base class is usable in TorqueScript, but is does not specify what functionality is intended (open or save?). Its children, OpenFileDialog and SaveFileDialog, do make use of DialogStyle flags and do make use of specific funcationality. These are the preferred classes to use

However, the FileDialog base class does contain the key properties and important method for file browing. The most important function is Execute(). This is used by both SaveFileDialog and OpenFileDialog to initiate the browser.

@tsexample
// NOTE: This is not he preferred class to use, but this still works

// Create the file dialog
%baseFileDialog = new FileDialog()
{
   // Allow browsing of all file types
   filters = "*.*";

   // No default file
   defaultFile = ;

   // Set default path relative to project
   defaultPath = "./";

   // Set the title
   title = "Durpa";

   // Allow changing of path you are browsing
   changePath = true;
};

 // Launch the file dialog
 %baseFileDialog.Execute();
 
 // Don't forget to cleanup
 %baseFileDialog.delete();


@endtsexample

@note FileDialog and its related classes are only availble in a Tools build of Torque.

@see OpenFileDialog for a practical example on opening a file
@see SaveFileDialog for a practical example of saving a file
@ingroup FileSystem
 */
class  FileDialog : public SimObject {
  public:
   /*! @brief Launches the OS file browser

After an Execute() call, the chosen file name and path is available in one of two areas.  If only a single file selection is permitted, the results will be stored in the @a fileName attribute.

If multiple file selection is permitted, the results will be stored in the @a files array.  The total number of files in the array will be stored in the @a fileCount attribute.

@tsexample
// NOTE: This is not he preferred class to use, but this still works

// Create the file dialog
%baseFileDialog = new FileDialog()
{
   // Allow browsing of all file types
   filters = "*.*";

   // No default file
   defaultFile = ;

   // Set default path relative to project
   defaultPath = "./";

   // Set the title
   title = "Durpa";

   // Allow changing of path you are browsing
   changePath = true;
};

 // Launch the file dialog
 %baseFileDialog.Execute();
 
 // Don't forget to cleanup
 %baseFileDialog.delete();


 // A better alternative is to use the 
 // derived classes which are specific to file open and save

 // Create a dialog dedicated to opening files
 %openFileDlg = new OpenFileDialog()
 {
    // Look for jpg image files
    // First part is the descriptor|second part is the extension
    Filters = "Jepg Files|*.jpg";
    // Allow browsing through other folders
    ChangePath = true;

    // Only allow opening of one file at a time
    MultipleFiles = false;
 };

 // Launch the open file dialog
 %result = %openFileDlg.Execute();

 // Obtain the chosen file name and path
 if ( %result )
 {
    %seletedFile = %openFileDlg.file;
 }
 else
 {
    %selectedFile = "";
 }
 // Cleanup
 %openFileDlg.delete();


 // Create a dialog dedicated to saving a file
 %saveFileDlg = new SaveFileDialog()
 {
    // Only allow for saving of COLLADA files
    Filters = "COLLADA Files (*.dae)|*.dae|";

    // Default save path to where the WorldEditor last saved
    DefaultPath = $pref::WorldEditor::LastPath;

    // No default file specified
    DefaultFile = "";

    // Do not allow the user to change to a new directory
    ChangePath = false;

    // Prompt the user if they are going to overwrite an existing file
    OverwritePrompt = true;
 };

 // Launch the save file dialog
 %result = %saveFileDlg.Execute();

 // Obtain the file name
 %selectedFile = "";
 if ( %result )
    %selectedFile = %saveFileDlg.file;

 // Cleanup
 %saveFileDlg.delete();
@endtsexample

@return True if the file was selected was successfully found (opened) or declared (saved). */
   virtual bool Execute(()) {}
   /*!
   The default directory path when the dialog is shown.
   
    */
   string defaultPath;
   /*!
   The default file path when the dialog is shown.
   
    */
   string defaultFile;
   /*!
   The default file name when the dialog is shown.
   
    */
   string fileName;
   /*!
   The filter string for limiting the types of files visible in the dialog.  It makes use of the pipe symbol '|' as a delimiter.  For example:

'All Files|*.*'

'Image Files|*.png;*.jpg|Png Files|*.png|Jepg Files|*.jpg'
   
    */
   string filters;
   /*!
   The title for the dialog.
   
    */
   string title;
   /*!
   True/False whether to set the working directory to the directory returned by the dialog.
   
    */
   bool changePath;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Derived from FileDialog, this class is responsible for opening a file browser with the intention of opening a file.

The core usage of this dialog is to locate a file in the OS and return the path and name. This does not handle the actual file parsing or data manipulation. That functionality is left up to the FileObject class.

@tsexample
 // Create a dialog dedicated to opening files
 %openFileDlg = new OpenFileDialog()
 {
    // Look for jpg image files
    // First part is the descriptor|second part is the extension
    Filters = "Jepg Files|*.jpg";
    // Allow browsing through other folders
    ChangePath = true;

    // Only allow opening of one file at a time
    MultipleFiles = false;
 };

 // Launch the open file dialog
 %result = %openFileDlg.Execute();

 // Obtain the chosen file name and path
 if ( %result )
 {
    %seletedFile = %openFileDlg.file;
 }
 else
 {
    %selectedFile = "";
 }

 // Cleanup
 %openFileDlg.delete();


@endtsexample

@note FileDialog and its related classes are only availble in a Tools build of Torque.

@see FileDialog
@see SaveFileDialog
@see FileObject
@ingroup FileSystem
 */
class  OpenFileDialog : public FileDialog {
  public:
   /*!
   True/False whether the file returned must exist or not
   
    */
   bool MustExist;
   /*!
   True/False whether multiple files may be selected and returned or not
   
    */
   bool MultipleFiles;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Derived from FileDialog, this class is responsible for opening a file browser with the intention of saving a file.

The core usage of this dialog is to locate a file in the OS and return the path and name. This does not handle the actual file writing or data manipulation. That functionality is left up to the FileObject class.

@tsexample
 // Create a dialog dedicated to opening file
 %saveFileDlg = new SaveFileDialog()
 {
    // Only allow for saving of COLLADA files
    Filters        = "COLLADA Files (*.dae)|*.dae|";

    // Default save path to where the WorldEditor last saved
    DefaultPath    = $pref::WorldEditor::LastPath;

    // No default file specified
    DefaultFile    = "";

    // Do not allow the user to change to a new directory
    ChangePath     = false;

    // Prompt the user if they are going to overwrite an existing file
    OverwritePrompt   = true;
 };

 // Launch the save file dialog
 %saveFileDlg.Execute();

 if ( %result )
 {
    %seletedFile = %openFileDlg.file;
 }
 else
 {
    %selectedFile = "";
 }

 // Cleanup
 %saveFileDlg.delete();
@endtsexample

@note FileDialog and its related classes are only availble in a Tools build of Torque.

@see FileDialog
@see OpenFileDialog
@see FileObject
@ingroup FileSystem
 */
class  SaveFileDialog : public FileDialog {
  public:
   /*!
   True/False whether the dialog should prompt before accepting an existing file name
   
    */
   bool OverwritePrompt;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief OS level dialog used for browsing folder structures.

This is essentially an OpenFileDialog, but only used for returning directory paths, not files.

@note FileDialog and its related classes are only availble in a Tools build of Torque.

@see OpenFileDialog for more details on functionality.

@ingroup FileSystem
 */
class  OpenFolderDialog : public OpenFileDialog {
  public:
   /*!
   File that must be in selected folder for it to be valid
   
    */
   filename fileMustExist;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin for mesh rendering.

This is the primary render bin in Torque which does most of the work of rendering DTS shapes and arbitrary mesh geometry.  It knows how to render mesh instances using materials and supports hardware mesh instancing.

@ingroup RenderBin
 */
class  RenderMeshMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Basically the same as RenderMeshMgr, but will override the material of the instance. Exists for backwards compatibility, not currently used, soon to be deprecated

 */
class  ForcedMaterialMeshMgr : public RenderMeshMgr {
  public:
   /*!
   Material used to draw all meshes in the render bin.
   
    */
   Material Material;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Abstract base class for RenderFormatToken, used to manipulate what goes on in the render manager

You cannot actually instantiate RenderPassToken, only its child: RenderFormatToken. RenderFormatToken is an implementation which changes the format of the back buffer and/or the depth buffer.

The RenderPassStateBin manager changes the rendering state associated with a token it is declared with. In stock Torque 3D, a single example exists in the way of AL_FormatToken (found in renderManager.cs). In that script file, all the render managers are intialized, and a single RenderFormatToken is used. This implementation basically exists to ensure Advanced Lighting works with MSAA.

@see RenderFormatToken
@see RenderPassStateBin
@see game/core/scripts/client/renderManager.cs
@ingroup RenderBin
 */
class  RenderPassStateToken : public SimObject {
  public:
   /*! @brief Enables the token. */
   virtual void enable(()) {}
   /*! @brief Disables the token. */
   virtual void disable(()) {}
   /*! @brief Toggles the token from enabled to disabled or vice versa. */
   virtual void toggle(()) {}
   /*!
   Enables or disables this token.
   
    */
   bool enabled;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Used to change the render target format when rendering in AL.

RenderFormatToken is an implementation which changes the format of the back buffer and/or the depth buffer.

The RenderPassStateBin manager changes the rendering state associated with this token. In stock Torque 3D, a single example exists in the way of AL_FormatToken (found in renderManager.cs). In that script file, all the render managers are intialized, and a single RenderFormatToken is used. This implementation basically exists to ensure Advanced Lighting works with MSAA.

The actions for this token toggle the format of the back/depth buffers and it lets you specify a custom shader to "copy" the data so it can be reformatted or altered. This is done through the variables copyEffect and resolveEffect (which are post processes just like fog or glow)

@tsexample
// This token, and the associated render managers, ensure that driver MSAA does not get used for Advanced Lighting renders.
// The 'AL_FormatResolve' PostEffect copies the result to the backbuffer.
new RenderFormatToken(AL_FormatToken)
{
   enabled = "false";

   format = "GFXFormatR8G8B8A8";
   depthFormat = "GFXFormatD24S8";
   aaLevel = 0; // -1 = match backbuffer

   // The contents of the back buffer before this format token is executed
   // is provided in $inTex
   copyEffect = "AL_FormatCopy";

   // The contents of the render target created by this format token is
   // provided in $inTex
   resolveEffect = "AL_FormatCopy";
};
@endtsexample

@see RenderPassToken

@see RenderPassStateBin
@see game/core/scripts/client/renderManager.cs
@ingroup GFX
 */
class  RenderFormatToken : public RenderPassStateToken {
  public:
   /*!
   Sets the color buffer format for this token.
   
    */
   GFXFormat format;
   /*!
   Sets the depth/stencil buffer format for this token.
   
    */
   GFXFormat depthFormat;
   /*!
   This PostEffect will be run when the render target is changed to the format specified by this token. It is used to copy/format data into the token rendertarget
   
    */
   PostEffect copyEffect;
   /*!
   This PostEffect will be run when the render target is changed back to the format active prior to this token. It is used to copy/format data from the token rendertarget to the backbuffer.
   
    */
   PostEffect resolveEffect;
   /*!
   Anti-ailiasing level for the this token. 0 disables, -1 uses adapter default.
   
    */
   int aaLevel;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin for the glow pass.

When the glow buffer PostEffect is enabled this bin gathers mesh render instances with glow materials and renders them to the #glowbuffer offscreen render target.

This render target is then used by the 'GlowPostFx' PostEffect to blur and render the glowing portions of the screen.

@ingroup RenderBin
 */
class  RenderGlowMgr : public RenderTexTargetBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin for batch rendering imposters.

This render bin gathers imposter render instances and renders them in large batches.

You can type 'metrics( imposter )' in the console to see rendering statistics.

@ingroup RenderBin
 */
class  RenderImposterMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin which uses object callbacks for rendering.

This render bin gathers object render instances and calls its delegate method to perform rendering.  It is used infrequently for specialized scene objects which perform custom rendering.

@ingroup RenderBin
 */
class  RenderObjectMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin which renders occlusion query requests.

This render bin gathers occlusion query render instances and renders them. It is currently used by light flares and ShapeBase reflection cubemaps.

You can type '$RenderOcclusionMgr::debugRender = true' in the console to see debug rendering of the occlusion geometry.

@ingroup RenderBin
 */
class  RenderOcclusionMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin which renders particle geometry.

This render bin gathers particle render instances, sorts, and renders them. It is currently used by ParticleEmitter and LightFlareData.

@ingroup RenderBin
 */
class  RenderParticleMgr : public RenderTexTargetBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A non-rendering render bin used to enable/disable a RenderPassStateToken.

This is a utility RenderBinManager which does not render any render instances.  Its only used to define a point in the render bin order at which a RenderPassStateToken is triggered.

@see RenderPassStateToken
@ingroup RenderBin
 */
class  RenderPassStateBin : public RenderBinManager {
  public:
   /*!
    */
   RenderPassStateToken stateToken;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The render bin which performs a z+normals prepass used in Advanced Lighting.

This render bin is used in Advanced Lighting to gather all opaque mesh render instances and render them to the g-buffer for use in lighting the scene and doing effects.

PostEffect and other shaders can access the output of this bin by using the #prepass texture target name.  See the edge anti-aliasing post effect for an example.

@see game/core/scripts/client/postFx/edgeAA.cs
@ingroup RenderBin
 */
class  RenderPrePassMgr : public RenderTexTargetBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin for terrain mesh rendering.

This bin renders terrain render instances from a TerrainBlock. Normally a mesh would render via the RenderMeshMgr, but terrain uses a TerrainMaterial designed for multi-layered surfaces which this bin can processs.

@ingroup RenderBin
 */
class  RenderTerrainMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A render bin for rendering translucent meshes.

This bin is used to render translucent render mesh instances and render object instances. It is generally ordered late in the RenderPassManager after all opaque geometry bins.

@ingroup RenderBin
 */
class  RenderTranslucentMgr : public RenderBinManager {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Class responsible for the registration, transmission, and management of paths on client and server.

For internal use only, not intended for use in TorqueScript or game development

@internal
 */
class  PathManagerEvent {
  public:
};

/*!
@brief A datablock which defines performance and quality properties for dynamic reflections.

ReflectorDesc is not itself a reflection and does not render reflections. It is a dummy class for holding and exposing to the user a set of reflection related properties. Objects which support dynamic reflections may then reference a ReflectorDesc.

@tsexample
datablock ReflectorDesc( ExampleReflectorDesc )
{
   texSize = 256;
   nearDist = 0.1;
   farDist = 500;
   objectTypeMask = 0xFFFFFFFF;
   detailAdjust = 1.0;
   priority = 1.0;
   maxRateMs = 0;
   useOcclusionQuery = true;
};
@endtsexample
@see ShapeBaseData::cubeReflectorDesc
 */
class  ReflectorDesc : public SimDataBlock {
  public:

   /*! @name ReflectorDesc
   @{ */
   /*! */
   /*!
   Size in pixels of the (square) reflection texture. For a cubemap this value is interpreted as size of each face.
   
    */
   int texSize;
   /*!
   Near plane distance to use when rendering this reflection. Adjust this to limit self-occlusion artifacts.
   
    */
   float nearDist;
   /*!
   Far plane distance to use when rendering reflections.
   
    */
   float farDist;
   /*!
   Object types which render into this reflection.
   
    */
   int objectTypeMask;
   /*!
   Scale applied to lod calculation of objects rendering into this reflection ( modulates $pref::TS::detailAdjust ).
   
    */
   float detailAdjust;
   /*!
   Priority for updating this reflection, relative to others.
   
    */
   float priority;
   /*!
   If less than maxRateMs has elapsed since this relfection was last updated, then do not update it again. This 'skip' can be disabled by setting maxRateMs to zero.
   
    */
   int maxRateMs;
   /*!
   If available on the device use HOQs to determine if the reflective object is visible before updating its reflection.
   
    */
   bool useOcclusionQuery;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A single joint, or knot, along a path. Should be stored inside a Path container object. A path markers can be
one of three primary movement types: "normal", "Position Only", or "Kink". 
@tsexample
new path()
^{
     isLooping = "1";

     new Marker()
^^{
^^^seqNum = "0";
^^^type = "Normal";
^^^msToNext = "1000";
^^^smoothingType = "Spline";
^^^position = "-0.054708 -35.0612 234.802";
^^^rotation = "1 0 0 0";
      };

^};
@endtsexample
@see Path
@ingroup enviroMisc
 */
class  Marker : public SceneObject {
  public:

   /*! @name Misc
   @{ */
   /*! */
   /*!
   Marker position in sequence of markers on this path.

   
    */
   int seqNum;
   /*!
   Type of this marker/knot. A "normal" knot will have a smooth camera translation/rotation effect.
"Position Only"will do the same for translations, leaving rotation un-touched.
Lastly, a "Kink" means the rotation will take effect immediately for an abrupt rotation change.

   
    */
   MarkerKnotType type;
   /*!
   Milliseconds to next marker in sequence.

   
    */
   int msToNext;
   /*!
   Path smoothing at this marker/knot. "Linear"means no smoothing, while "Spline" means to smooth.

   
    */
   MarkerSmoothingType smoothingType;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A datablock that describes an ambient sound space.

Each ambience datablock captures the properties of a unique ambient sound space.  A sound space is comprised of:
- an ambient audio track that is played when the listener is inside the space,
- a reverb environment that is active inside the space, and
- a number of SFXStates that are activated when entering the space and deactivated when exiting it.

Each of these properties is optional.

An important characteristic of ambient audio spaces is that their unique nature is not determined by their location in space but rather by their SFXAmbience datablock.  This means that the same SFXAmbience datablock assigned to multiple locations in a level represents the same unique audio space to the sound system.

This is an important distinction for the ambient sound mixer which will activate a given ambient audio space only once at any one time regardless of how many intersecting audio spaces with the same SFXAmbience datablock assigned the listener may currently be in.

All SFXAmbience instances are automatically added to the global @c SFXAmbienceSet.

At the moment, transitions between reverb environments are not blended and different reverb environments from multiple active SFXAmbiences will not be blended together.  This will be added in a future version.

@tsexample
singleton SFXAmbience( Underwater )
{
   environment = AudioEnvUnderwater;
   soundTrack = ScubaSoundList;
   states[ 0 ] = AudioLocationUnderwater;
};
@endtsexample

@see SFXEnvironment
@see SFXTrack
@see SFXState
@see LevelInfo::soundAmbience
@see Zone::soundAmbience

@ref Datablock_Networking
@ingroup SFX
@ingroup Datablocks
 */
class  SFXAmbience : public SimDataBlock {
  public:

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Reverb environment active in the ambience zone.
@ref SFX_reverb
   
    */
   SFXEnvironment environment;
   /*!
   Sound track to play in the ambience zone.
   
    */
   SFXTrack soundTrack;
   /*!
   The rolloff factor to apply to distance-based volume attenuation in this space.
Defaults to 1.0.

@note This applies to the logarithmic distance model only.

@ref SFXSource_volume
   
    */
   float rolloffFactor;
   /*!
   The factor to apply to the doppler affect in this space.
Defaults to 0.5.

@ref SFXSource_doppler
   
    */
   float dopplerFactor;
   /*!
   States to activate when the ambient zone is entered.
When the ambient sound state is entered, all states associated with the state will be activated (given that they are not disabled) and deactivated when the space is exited again.
   
    */
   SFXState states;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A description for how a sound should be played.

SFXDescriptions are used by the sound system to collect all parameters needed to set up a given sound for playback.  This includes information like its volume level, its pitch shift, etc. as well as more complex information like its fade behavior, 3D properties, and per-sound reverb properties.

Any sound playback will require a valid SFXDescription.

As datablocks, SFXDescriptions can be set up as either networked datablocks or non-networked datablocks, though it generally makes sense to keep all descriptions non-networked since they will be used exclusively by clients.

@tsexample
// A description for a 3D sound with a reasonable default range setting.
// The description is set up to assign sounds to the AudioChannelEffects source group
// (defined in the core scripts).  An alternative means to achieve this is to use the
// AudioEffects description as a copy source (": AudioEffects").

singleton SFXDescription( Audio3DSound )
{
  sourceGroup       = AudioChannelEffects;
  is3D              = true;
  referenceDistance = 20.0;
  maxDistance       = 100.0;
};
@endtsexample

@ingroup SFX
@ingroup Datablocks
 */
class  SFXDescription : public SimDataBlock {
  public:

   /*! @name Playback
   @{ */
   /*! */
   /*!
   Group that sources playing with this description should be put into.

When a sound source is allocated, it will be made a child of the source group that is listed in its 
description.  This group will then modulate several properties of the sound as it is played.

For example, one use of groups is to segregate sounds so that volume levels of different sound groups such as interface audio and game audio can be controlled independently.

@ref SFXSource_hierarchies
   
    */
   SFXSource sourceGroup;
   /*!
   Base volume level for the sound.

This will be the starting point for volume attenuation on the sound.  The final effective volume of a sound will be dependent on a number of parameters.

Must be between 0 (mute) and 1 (full volume).  Default is 1.

@ref SFXSource_volume
   
    */
   float volume;
   /*!
   Pitch shift to apply to playback.

The pitch assigned to a sound determines the speed at which it is played back.  A pitch shift of 1 plays the sound at its default speed.  A greater shift factor speeds up playback and a smaller shift factor slows it down.

Must be >0.  Default is 1.
   
    */
   float pitch;
   /*!
   If true, the sound will be played in an endless loop.

Default is false.
   
    */
   bool isLooping;
   /*!
   Priority level for virtualization of sounds (1 = base level).
When there are more concurrently active sounds than supported by the audio mixer, some of the sounds need to be culled.  Which sounds are culled first depends primarily on total audibility of individual sounds. However, the priority of invidual sounds may be decreased or decreased through this field.

@ref SFXSound_virtualization
   
    */
   float priority;
   /*!
   Whether the sound is allowed to be mixed in hardware.
If true, the sound system will try to allocate the voice for the sound directly on the sound hardware for mixing by the hardware mixer.  Be aware that a hardware mixer may not provide all features available to sounds mixed in software.

@note This flag currently only takes effect when using FMOD.

@note Generally, it is preferable to let sounds be mixed in software.


   
    */
   bool useHardware;
   /*!
   Names of the parameters to which sources using this description will automatically be linked.

Individual parameters are identified by their #internalName.

@ref SFX_interactive
   
    */
   string parameters;
   /// @}


   /*! @name Fading
   @{ */
   /*! */
   /*!
   Number of seconds to gradually fade in volume from zero when playback starts.
Must be >= 0.

@ref SFXSource_fades
   
    */
   float fadeInTime;
   /*!
   Number of seconds to gradually fade out volume down to zero when playback is stopped or paused.
Must be >=0.

@ref SFXSource_fades
   
    */
   float fadeOutTime;
   /*!
   Easing curve for fade-in transition.
Volume fade-ins will interpolate volume along this curve.

@ref SFXSource_fades
   
    */
   EaseF fadeInEase;
   /*!
   Easing curve for fade-out transition.
Volume fade-outs will interpolate volume along this curve.

@ref SFXSource_fades
   
    */
   EaseF fadeOutEase;
   /*!
   Fade each cycle of a loop in and/or out; otherwise only fade-in first cycle.
By default, volume fading is applied to the beginning and end of the playback range, i.e. a fade-in segment is placed at the beginning of the sound and a fade-out segment is paced at the end of a sound.  However, when looping playback, this may be undesirable as each iteration of the sound will then have a fade-in and fade-out effect.

To set up looping sounds such that a fade-in is applied only when the sound is first started (or playback resumed) and a fade-out is only applied when the sound is explicitly paused or stopped, set this field to true.

Default is false.

@ref SFXSource_fades
   
    */
   bool fadeLoops;
   /// @}


   /*! @name 3D
   @{ */
   /*! */
   /*!
   If true, sounds played with this description will have a position and orientation in space.
Unlike a non-positional sound, a 3D sound will have its volume attenuated depending on the distance to the listener in space.  The farther the sound moves away from the listener, the less audible it will be.

Non-positional sounds, in contrast, will remain at their original volume regardless of where the listener is.

@note Whether a sound is positional or non-positional cannot be changed once the sound was created so this field determines up front which is the case for a given sound.

@ref SFX_3d
@ref SFXSource_volume
   
    */
   bool is3D;
   /*!
   Distance at which volume attenuation begins.
Up to this distance, the sound retains its base volume.

In the linear distance model, the volume will linearly from this distance onwards up to maxDistance where it reaches zero.

In the logarithmic distance model, the reference distance determine how fast the sound volume decreases with distance.  Each referenceDistance steps (scaled by the rolloff factor), the volume halves.

A rule of thumb is that for sounds that require you to be close to hear them in the real world, set the reference distance to small values whereas for sounds that are widely audible set it to larger values.

Only applies to 3D sounds.
@see LevelInfo::soundDistanceModel

@ref SFX_3d
@ref SFXSource_volume
   
    */
   float referenceDistance;
   /*!
   The distance at which attenuation stops.
In the linear distance model, the attenuated volume will be zero at this distance.

In the logarithmic model, attenuation will simply stop at this distance and the sound will keep its attenuated volume from there on out.  As such, it primarily functions as a cutoff factor to exponential distance attentuation to limit the number of voices relevant to updates.

Only applies to 3D sounds.
@see LevelInfo::soundDistanceModel

@ref SFX_3d
@ref SFXSource_volume
   
    */
   float maxDistance;
   /*!
   Bounds on random displacement of 3D sound positions.
When a 3D sound is created and given its initial position in space, this field is used to determine the amount of randomization applied to the actual position given to the sound system.

The randomization uses the following scheme:@verbatim
x += rand( - scatterDistance[ 0 ], scatterDistance[ 0 ] );
y += rand( - scatterDistance[ 1 ], scatterDistance[ 1 ] );
z += rand( - scatterDistance[ 2 ], scatterDistance[ 2 ] );
@endverbatim

   
    */
   Point3F scatterDistance;
   /*!
   Inner sound cone angle in degrees.
This value determines the angle of the inner volume cone that protrudes out in the direction of a sound.  Within this cone, the sound source retains full volume that is unaffected by sound cone settings (though still affected by distance attenuation.)

Valid values are from 0 to 360. Must be less than coneOutsideAngle. Default is 360. Only for 3D sounds.

@ref SFXSource_cones
   
    */
   int coneInsideAngle;
   /*!
   Outer sound cone angle in degrees.
This value determines the angle of the outer volume cone that protrudes out in the direction of a sound and surrounds the inner volume cone.  Within this cone, volume will linearly interpolate from the outer cone hull inwards to the inner coner hull starting with the base volume scaled by coneOutsideVolume and ramping up/down to the full base volume.

Valid values are from 0 to 360.  Must be >= coneInsideAngle.  Default is 360.  Only for 3D sounds.

@ref SFXSource_cones
   
    */
   int coneOutsideAngle;
   /*!
   Determines the volume scale factor applied the a source's base volume level outside of the outer cone.
In the outer cone, starting from outside the inner cone, the scale factor smoothly interpolates from 1.0 (within the inner cone) to this value.  At the moment, the allowed range is 0.0 (silence) to 1.0 (no attenuation) as amplification is only supported on XAudio2 but not on the other devices.

Only for 3D sound.

@ref SFXSource_cones
   
    */
   float coneOutsideVolume;
   /*!
   Scale factor to apply to logarithmic distance attenuation curve.  If -1, the global rolloff setting is used.

@note Per-sound rolloff is only supported on OpenAL and FMOD at the moment.  With other divices, the global rolloff setting is used for all sounds.
@see LevelInfo::soundDistanceModel
   
    */
   float rolloffFactor;
   /// @}


   /*! @name Streaming
   @{ */
   /*! */
   /*!
   If true, incrementally stream sounds; otherwise sounds are loaded in full.

@ref SFX_streaming
   
    */
   bool isStreaming;
   /*!
   Number of seconds of sample data per single streaming packet.
This field allows to fine-tune streaming for individual sounds.  The streaming system processes streamed sounds in batches called packets.  Each packet will contain a set amount of sample data determined by this field.  The greater its value, the more sample data each packet contains, the more work is done per packet.

@note This field only takes effect when Torque's own sound system performs the streaming. When FMOD is used, this field is ignored and streaming is performed by FMOD.

@ref SFX_streaming
   
    */
   int streamPacketSize;
   /*!
   Number of sample packets to read and buffer in advance.
This field determines the number of packets that the streaming system will try to keep buffered in advance.  As such it determines the number of packets that can be consumed by the sound device before the playback queue is running dry.  Greater values thus allow for more lag in the streaming pipeline.

@note This field only takes effect when Torque's own sound system performs the streaming. When FMOD is used, this field is ignored and streaming is performed by FMOD.

@ref SFX_streaming
   
    */
   int streamReadAhead;
   /// @}


   /*! @name Reverb
   @{ */
   /*! */
   /*!
   If true, use the reverb properties defined here on sounds.
By default, sounds will be assigned a generic reverb profile.  By setting this flag to true, a custom reverb setup can be defined using the "Reverb" properties that will then be assigned to sounds playing with the description.

@ref SFX_reverb
   
    */
   bool useCustomReverb;
   /*!
   Direct path level (at low and mid frequencies).
@note SUPPORTED: EAX/I3DL2/FMODSFX

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbDirect;
   /*!
   Relative direct path level at high frequencies.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbDirectHF;
   /*!
   Room effect level (at low and mid frequencies).
@note SUPPORTED: EAX/I3DL2/FMODSFX

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbRoom;
   /*!
   Relative room effect level at high frequencies.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbRoomHF;
   /*!
   Main obstruction control (attenuation at high frequencies).
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbObstruction;
   /*!
   Obstruction low-frequency level re. main control.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbObstructionLFRatio;
   /*!
   Main occlusion control (attenuation at high frequencies).@note SUPPORTED: EAX/I3DL2


@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbOcclusion;
   /*!
   Occlusion low-frequency level re. main control.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbOcclusionLFRatio;
   /*!
   Relative occlusion control for room effect.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbOcclusionRoomRatio;
   /*!
   Relative occlusion control for direct path.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbOcclusionDirectRatio;
   /*!
   Main exclusion control (attenuation at high frequencies).
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbExclusion;
   /*!
   Exclusion low-frequency level re. main control.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbExclusionLFRatio;
   /*!
   Outside sound cone level at high frequencies.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   int reverbOutsideVolumeHF;
   /*!
   Per-source doppler factor.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbDopplerFactor;
   /*!
   Per-source logarithmic falloff factor.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbReverbRolloffFactor;
   /*!
   Room effect falloff factor.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbRoomRolloffFactor;
   /*!
   Multiplies SFXEnvironment::airAbsorptionHR.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf
   
    */
   float reverbAirAbsorptionFactor;
   /*!
   Bitfield combination of per-sound reverb flags.
@see REVERB_DIRECTHFAUTO
@see REVERB_ROOMAUTO
@see REVERB_ROOMHFAUTO
@see REVERB_INSTANCE0
@see REVERB_INSTANCE1
@see REVERB_INSTANCE2
@see REVERB_INSTANCE3

   
    */
   int reverbFlags;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Description of a reverb environment.

A reverb environment specifies how the audio mixer should render advanced environmental audio effects.  

To use reverb environments in your level, set up one or more ambient audio spaces, assign reverb environments appropriately, and then attach the SFXAmbiences to your LevelInfo (taking effect globally) or Zone objects (taking effect locally).

To define your own custom reverb environments, it is usually easiest to adapt one of the pre-existing reverb definitions:
@tsexample_nopar
singleton SFXEnvironment( AudioEnvCustomUnderwater : AudioEnvUnderwater )
{
   // Override select properties from AudioEnvUnderwater here.
};
@endtsexample

In the Datablock Editor, this can be done by selecting an existing environment to copy from when creating the SFXEnvironment datablock.

For a precise description of reverb audio and the properties of this class, please consult the EAX documentation.

All SFXEnvironment instances are automatically added to the global @c SFXEnvironmentSet.

@see http://www.atc.creative.com/algorithms/eax20.pdf
@see http://connect.creativelabs.com/developer/Gaming/Forms/AllItems.aspx
@see SFXAmbience::environment

@ref SFX_reverb
@ingroup SFX
 */
class  SFXEnvironment : public SimDataBlock {
  public:

   /*! @name Reverb
   @{ */
   /*! */
   /*!
   Environment size in meters.
   
    */
   float envSize;
   /*!
   Environment diffusion.
   
    */
   float envDiffusion;
   /*!
   Room effect level at mid-frequencies.
   
    */
   int room;
   /*!
   Relative room effect level at high frequencies.
   
    */
   int roomHF;
   /*!
   Relative room effect level at low frequencies.
   
    */
   int roomLF;
   /*!
   Reverberation decay time at mid frequencies.
   
    */
   float decayTime;
   /*!
   High-frequency to mid-frequency decay time ratio.
   
    */
   float decayHFRatio;
   /*!
   Low-frequency to mid-frequency decay time ratio.
   
    */
   float decayLFRatio;
   /*!
   Early reflections level relative to room effect.
   
    */
   int reflections;
   /*!
   Initial reflection delay time.
   
    */
   float reflectionsDelay;
   /*!
   Early reflections panning vector.
   
    */
   float reflectionsPan;
   /*!
   Late reverberation level relative to room effect.
   
    */
   int reverb;
   /*!
   Late reverberation delay time relative to initial reflection.
   
    */
   float reverbDelay;
   /*!
   Late reverberation panning vector.
   
    */
   float reverbPan;
   /*!
   Echo time.
   
    */
   float echoTime;
   /*!
   Echo depth.
   
    */
   float echoDepth;
   /*!
   Modulation time.
   
    */
   float modulationTime;
   /*!
   Modulation depth.
   
    */
   float modulationDepth;
   /*!
   Change in level per meter at high frequencies.
   
    */
   float airAbsorptionHF;
   /*!
   Reference high frequency in Hertz.
   
    */
   float HFReference;
   /*!
   Reference low frequency in Hertz.
   
    */
   float LFReference;
   /*!
   Logarithmic distance attenuation rolloff scale factor for reverb room size effect.
   
    */
   float roomRolloffFactor;
   /*!
   Value that controls the echo density in the late reverberation decay.
   
    */
   float diffusion;
   /*!
   Value that controls the modal density in the late reverberation decay.
   
    */
   float density;
   /*!
   A bitfield of reverb flags.
@see REVERB_DECAYTIMESCALE
@see REVERB_REFLECTIONSSCALE
@see REVERB_REFLECTIONSDELAYSCALE
@see REVERB_REVERBSCALE
@see REVERB_REVERBDELAYSCALE
@see REVERB_DECAYHFLIMIT
@see REVERB_ECHOTIMESCALE
@see REVERB_MODULATIONTIMESCALE
@see REVERB_CORE0
@see REVERB_CORE1
@see REVERB_HIGHQUALITYREVERB
@see REVERB_HIGHQUALITYDPL2REVERB

   
    */
   int flags;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Abstract base class for sound data that can be played back by the sound system.

The term "track" is used in the sound system to refer to any entity that can be played back as a sound source.  These can be individual files (SFXProfile), patterns of other tracks (SFXPlayList), or special sound data defined by a device layer (SFXFMODEvent).

Any track must be paired with a SFXDescription that tells the sound system how to set up playback for the track.

All objects that are of type SFXTrack will automatically be added to @c SFXTrackSet.

@note This class cannot be instantiated directly.

@ingroup SFX
@ingroup Datablocks
 */
class  SFXTrack : public SimDataBlock {
  public:

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Playback setup description for this track.

If unassigned, the description named "AudioEffects" will automatically be assigned to the track.  If this description is not defined, track creation will fail.
   
    */
   SFXDescription description;
   /*!
   Parameters to automatically attach to SFXSources created from this track.
Individual parameters are identified by their #internalName.
   
    */
   string parameters;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A datablock describing a playback pattern of sounds.

Playlists allow to define intricate playback patterns of invidual tracks and thus allow the sound system to be easily used for playing multiple sounds in single operations.

As playlists are %SFXTracks, they can thus be used anywhere in the engine where sound data can be assigned.

Each playlist can hold a maximum of 16 tracks.  Longer playlists may be constructed by cascading lists, i.e. by creating a playlist that references other playlists.

Processing of a single playlist slot progresses in a fixed set of steps that are invariably iterated through for each slot (except the slot is assigned a state and its state is deactivated; in this case, the controller will exit out of the slot directly):

<ol>
<li><b>delayIn:</b><p>Waits a set amount of time before processing the slot. This is 0 by default and is determined by the #delayTimeIn (seconds to wait) and #delayTimeInVariance (bounds on randomization) properties.</p></li>
<li><b>#transitionIn:</b><p>Decides what to do @b before playing the slot.  Defaults to @c None which makes this stage a no-operation.  Alternatively, the slot can be configured to wait for playback of other slots to finish (@c Wait and @c WaitAll) or to stop playback of other slots (@c Stop and @c StopAll). Note that @c Wait and @c Stop always refer to the source that was last started by the list.</p></li>
<li><b>play:</b><p><p>Finally, the #track attached to the slot is played. However, this will only @b start playback of the track and then immediately move on to the next stage.  It will @b not wait for the track to finish playing.  Note also that depending on the @c replay setting for the slot, this stage may pick up a source that is already playing on the slot rather than starting a new one.</p> <p>Several slot properties (fade times, min/max distance, and volume/pitch scale) are used in this stage.</p></li>
<li><b>delayOut:</b><p>Waits a set amount of time before transitioning out of the slot. This works the same as @c delayIn and is set to 0 by default (i.e. no delay).</p></li>
<li><b>#transitionOut:</b><p>Decides what to do @b after playing the slot. This works like #transitionIn.</p></li>
</ol>

This is a key difference to playlists in normal music players where upon reaching a certain slot, the slot will immediately play and the player then wait for playback to finish before moving on to the next slot.

@note Be aware that time limits set on slot delays are soft limits.  The sound system updates sound sources in discrete (and equally system update frequency dependent) intervals which thus determines the granularity at which time-outs can be handled.

@section SFXPlayList_randomization Value Randomization

For greater variety, many of the values for individual slots may be given a randomization limit that will trigger a dynamic variance of the specified base value.

Any given field @c xyz that may be randomized has a corresponding field @c xyzVariance which is a two-dimensional vector.  The first number specifies the greatest value that may be subtracted from the given base value (i.e. the @c xyz field) whereas the second number specifies the greatest value that may be added to the base value.  Between these two limits, a random number is generated.

The default variance settings of "0 0" will thus not allow to add or subtract anything from the base value and effectively disable randomization.

Randomization is re-evaluated on each cycle through a list.

@section SFXPlayList_states Playlists and States

A unique aspect of playlists is that they allow their playback to be tied to the changing set of active sound states. This feature enables playlists to basically connect to an extensible state machine that can be leveraged by the game code to signal a multitude of different gameplay states with the audio system then automatically reacting to state transitions.

Playlists react to states in three ways:
- Before a controller starts processing a slot it checks whether the slot is assigned a #state.  If this is the case, the controller checks whether the particular state is active.  If it is not, the entire slot is skipped.  If it is, the controller goes on to process the slot.
- If a controller is in one of the delay stages for a slot that has a #state assigned and the state is deactivated, the controller will stop the delay and skip any of the remaining processing stages for the slot.
- Once the play stage has been processed for a slot that has a #state assigned, the slot's #stateMode will determine what happens with the playing sound source if the slot's state is deactivated while the sound is still playing.

A simple example of how to make use of states in combination with playlists would be to set up a playlist for background music that reacts to the mood of the current gameplay situation.  For example, during combat, tenser music could play than during normal exploration.  To set this up, different %SFXStates would represent different moods in the game and the background music playlist would have one slot set up for each such mood.  By making use of volume fades and the @c PauseWhenDeactivated #stateMode, smooth transitions between the various audio tracks can be produced.

@tsexample
// Create a play list from two SFXProfiles.
%playList = new SFXPlayList()
{
   // Use a looped description so the list playback will loop.
   description = AudioMusicLoop2D;

   track[ 0 ] = Profile1;
   track[ 1 ] = Profile2;
};

// Play the list.
sfxPlayOnce( %playList );
@endtsexample

@ref SFX_interactive

 */
class  SFXPlayList : public SFXTrack {
  public:

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Slot playback order randomization pattern.
By setting this field to something other than "NotRandom" to order in which slots of the playlist are processed can be changed from sequential to a random pattern.  This allows to to create more varied playback patterns.
Defaults to "NotRandom".
   
    */
   SFXPlayListRandomMode random;
   /*!
   Behavior when description has looping enabled.
The loop mode determines whether the list will loop over a single slot or loop over all the entire list of slots being played.

@see SFXDescription::isLooping
   
    */
   SFXPlayListLoopMode loopMode;
   /*!
   Number of slots to play.
Up to a maximum of 16, this field determines the number of slots that are taken from the list for playback.  Only slots that have a valid #track assigned will be considered for this.
   
    */
   int numSlotsToPlay;
   /*!
   Track to play in this slot.
This must be set for the slot to be considered for playback.  Other settings for a slot will not take effect except this field is set.
   
    */
   SFXTrack track;
   /*!
   Behavior when an already playing sound is encountered on this slot from a previous cycle.
Each slot can have an arbitrary number of sounds playing on it from previous cycles.  This field determines how SFXController will handle these sources.
   
    */
   SFXPlayListReplayMode replay;
   /*!
   Behavior when moving into this slot.
After the delayIn time has expired (if any), this slot determines what the controller will do before actually playing the slot.
   
    */
   SFXPlayListTransitionMode transitionIn;
   /*!
   Behavior when moving out of this slot.
After the #detailTimeOut has expired (if any), this slot determines what the controller will do before moving on to the next slot.
   
    */
   SFXPlayListTransitionMode transitionOut;
   /*!
   Seconds to wait after moving into slot before #transitionIn.
   
    */
   float delayTimeIn;
   /*!
   Bounds on randomization of #delayTimeIn.

@ref SFXPlayList_randomization

   
    */
   Point2F delayTimeInVariance;
   /*!
   Seconds to wait before moving out of slot after #transitionOut.
   
    */
   float delayTimeOut;
   /*!
   Bounds on randomization of #delayTimeOut.

@ref SFXPlayList_randomization

   
    */
   Point2F delayTimeOutVariance;
   /*!
   Seconds to fade sound in (-1 to use the track's own fadeInTime.)
@see SFXDescription::fadeTimeIn
   
    */
   float fadeTimeIn;
   /*!
   Bounds on randomization of #fadeInTime.

@ref SFXPlayList_randomization

   
    */
   Point2F fadeTimeInVariance;
   /*!
   Seconds to fade sound out (-1 to use the track's own fadeOutTime.)
@see SFXDescription::fadeTimeOut
   
    */
   float fadeTimeOut;
   /*!
   Bounds on randomization of #fadeOutTime

@ref SFXPlayList_randomization

   
    */
   Point2F fadeTimeOutVariance;
   /*!
   @c referenceDistance to set for 3D sounds in this slot (<1 to use @c referenceDistance of track's own description).
@see SFXDescription::referenceDistance
   
    */
   float referenceDistance;
   /*!
   Bounds on randomization of #referenceDistance.

@ref SFXPlayList_randomization

   
    */
   Point2F referenceDistanceVariance;
   /*!
   @c maxDistance to apply to 3D sounds in this slot (<1 to use @c maxDistance of track's own description).
@see SFXDescription::maxDistance
   
    */
   float maxDistance;
   /*!
   Bounds on randomization of #maxDistance.

@ref SFXPlayList_randomization

   
    */
   Point2F maxDistanceVariance;
   /*!
   Scale factor to apply to volume of sounds played on this list slot.
This value will scale the actual volume level set on the track assigned to the slot, i.e. a value of 0.5 will cause the track to play at half-volume.
   
    */
   float volumeScale;
   /*!
   Bounds on randomization of #volumeScale.

@ref SFXPlayList_randomization

   
    */
   Point2F volumeScaleVariance;
   /*!
   Scale factor to apply to pitch of sounds played on this list slot.
This value will scale the actual pitch set on the track assigned to the slot, i.e. a value of 0.5 will cause the track to play at half its assigned speed.
   
    */
   float pitchScale;
   /*!
   Bounds on randomization of #pitchScale.

@ref SFXPlayList_randomization

   
    */
   Point2F pitchScaleVariance;
   /*!
   Number of times to loop this slot.
   
    */
   int repeatCount;
   /*!
   State that must be active for this slot to play.

@ref SFXPlayList_states
   
    */
   SFXState state;
   /*!
   Behavior when assigned state is deactivated while slot is playing.

@ref SFXPlayList_states
   
    */
   SFXPlayListStateMode stateMode;
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /*!
   Enable/disable execution tracing for this playlist (local only).
If this is true, SFXControllers attached to the list will automatically run in trace mode.
   
    */
   bool trace;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Internal event used for transmitting strings across the server.

For internal use only, not intended for TorqueScript or game development

@internal
 */
class  NetStringEvent {
  public:
};

/*!
@brief This event is used inside by the connection and subclasses to message itself when sequencing events occur.

Not intended for game development, for editors or internal use only.

 */
class  ConnectionMessageEvent {
  public:
};

/*!
@brief Used by NetConnection for transmitting requests to obtain files from server during loading.

Not intended for game development, for editors or internal use only.

 */
class  FileDownloadRequestEvent {
  public:
};

/*!
@brief Used by NetConnection for sending/receiving chunks of data.

Not intended for game development, for editors or internal use only.

 */
class  FileChunkEvent {
  public:
};

/*!
@brief Legacy or soon to be locked down object.

Not intended for game development, for editors or internal use only.

 */
class  GhostAlwaysObjectEvent {
  public:
};

/*!
@brief Legacy from older component system.

Not intended for game development, for editors or internal use only.

 */
class  CachedInterfaceExampleComponent : public SimComponent {
  public:

   /*! @name Component
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Undo actions which can be created as script objects.

Not intended for game development, for editors or internal use only.

 */
class  UndoScriptAction : public UndoAction {
  public:

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  ScriptMsgListener : public SimObject {
  public:
      /*! Script callback when a listener is first created and registered.

@tsexample
function ScriptMsgListener::onAdd(%this)
{
^// Perform on add code here
}
@endtsexample

 */
      void onAdd();

      /*! Script callback when a listener is deleted.

@tsexample
function ScriptMsgListener::onRemove(%this)
{
^// Perform on remove code here
}
@endtsexample

 */
      void onRemove();

      /*! Called when the listener has received a message.
@param queue The name of the queue the message was dispatched to
@param event The name of the event (function) that was triggered
@param data The data (parameters) for the message

@return false to prevent other listeners receiving this message, true otherwise
 */
      bool onMessageReceived( string queue, string event, string data );

      /*! Called when a message object (not just the message data) is passed to a listener.
@param queue The name of the queue the message was dispatched to
@param msg The message object
@return false to prevent other listeners receiving this message, true otherwise
@see Message
@see onMessageReceived */
      bool onMessageObjectReceived( string queue, Message  msg );

      /*! @brief Callback for when the listener is added to a queue

The default implementation of onAddToQueue() and onRemoveFromQueue() provide tracking of the queues this listener is added to through the mQueues member. Overrides of onAddToQueue() or onRemoveFromQueue() should ensure they call the parent implementation in any overrides.
@param queue The name of the queue that the listener added to
@see onRemoveFromQueue() */
      void onAddToQueue( string queue );

      /*! @brief Callback for when the listener is removed from a queue

The default implementation of onAddToQueue() and onRemoveFromQueue() provide tracking of the queues this listener is added to through the mQueues member. Overrides of onAddToQueue() or onRemoveFromQueue() should ensure they call the parent implementation in any overrides.
@param queue The name of the queue that the listener was removed from
@see onAddToQueue() */
      void onRemoveFromQueue( string queue );


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Forward messages from one queue to another

MessageForwarder is a script class that can be used to forward messages from one queue to another.

@tsexample
%fwd = new MessageForwarder()
{
^toQueue = "QueueToSendTo";
};

registerMessageListener("FromQueue", %fwd);
@endtsexample

Where "QueueToSendTo" is the queue you want to forward to, and "FromQueue" is the queue you want to forward from.

@ingroup Messaging
 */
class  MessageForwarder : public ScriptMsgListener {
  public:
   /*!
   Name of queue to forward to
   
    */
   caseString toQueue;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AwGui : public GuiControl {
  public:
   virtual void execJavaScript(( string script )) {}
   /*! @brief Loads the specified URL. */
   virtual void loadURL(( string url )) {}
   /*! @brief Returns the start URL. */
   virtual string getStartURL(()) {}
   /*! @brief Returns the current URL. */
   virtual string getCurrentURL(()) {}
   /*! @brief Refreshes the current page. */
   virtual void reload(()) {}
   /*! @brief If there's a page being loaded, this stops it from doing so. */
   virtual void stop(()) {}
   /*!
   The URL which is loaded initially.
   
    */
   string StartURL;
   /*!
   Path to a session file which will contain cookies, history, passwords etc. A blank path forces the control to use the default session.
   
    */
   string SessionPath;
   /*!
   The amount of frames per second to render. 0 means unlimited.
   
    */
   char Framerate;
   /*!
   Whether this control supports transparency or not. Default: Disabled
   
    */
   bool IsTransparent;
   /*!
   Forced resolution. Defaults to (0, 0) which lets AwGui and AwShape decide. In that case AwGui will set the resolution to the size of the Gui control and AwShape will set the size to 800 x 600.
   
    */
   Point2I Resolution;
   /*!
   Unloads all resources if the AwGui goes asleep. This can be used to keep the memory footprint down. Default: Enabled
   
    */
   bool UnloadOnSleep;
   /*!
   If the amount of alpha is below this value, no mouse events will be processed for that pixel.
   
    */
   char AlphaCutoff;
   /*!
   Shows the loading screen if true. Default: Disabled
   
    */
   bool ShowLoadingScreen;
   /*!
   If enabled will bring the control to the top of the GUI stack when clicked. Default: Disabled
   
    */
   bool BringToFrontWhenClicked;
   /*!
   Enables right-mouse clicks. If you're using Flash, this might not be desired as it can bring up an annoying context menu. Default: Disabled
   
    */
   bool EnableRightMouseButton;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A static object derived from a 3D model file and placed within the game world.

TSStatic is the most basic 3D shape in Torque.  Unlike StaticShape it doesn't make use of a datablock.  It derrives directly from SceneObject.  This makes TSStatic extremely light weight, which is why the Tools use this class when you want to drop in a DTS or DAE object.

While a TSStatic doesn't provide any motion -- it stays were you initally put it -- it does allow for a single ambient animation sequence to play when the object is first added to the scene.

@tsexample
new TSStatic(Team1Base) {
   shapeName = "art/shapes/desertStructures/station01.dts";
   playAmbient = "1";
   receiveSunLight = "1";
   receiveLMLighting = "1";
   useCustomAmbientLighting = "0";
   customAmbientLighting = "0 0 0 1";
   collisionType = "Visible Mesh";
   decalType = "Collision Mesh";
   allowPlayerStep = "1";
   renderNormals = "0";
   forceDetail = "-1";
   position = "315.18 -180.418 244.313";
   rotation = "0 0 1 195.952";
   scale = "1 1 1";
   isRenderEnabled = "true";
   canSaveDynamicFields = "1";
};
@endtsexample
@ingroup gameObjects
 */
class  TSStatic : public SceneObject {
  public:
   /*! Get the name of the indexed shape material.
@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.
@see getTargetCount()
 */
   virtual string getTargetName(( int index=0 )) {}
   /*! Get the number of materials in the shape.
@return the number of materials in the shape.
@see getTargetName()
 */
   virtual int getTargetCount(()) {}
   /*! @brief Change one of the materials on the shape.

This method changes materials per mapTo with others. The material that is being replaced is mapped to unmapped_mat as a part of this transition.
@note Warning, right now this only sort of works. It doesn't do a live update like it should.
@param mapTo the name of the material target to remap (from getTargetName)
@param oldMat the old Material that was mapped 
@param newMat the new Material to map

@tsexample
// remap the first material in the shape
%mapTo = %obj.getTargetName( 0 );
%obj.changeMaterial( %mapTo, 0, MyMaterial );
@endtsexample
 */
   virtual void changeMaterial(( string mapTo="", Material oldMat=NULL, Material newMat=NULL )) {}
   /*! @brief Get the model filename used by this shape.

@return the shape filename

@tsexample
// Acquire the model filename used on this shape.
%modelFilename = %obj.getModelFile();
@endtsexample
 */
   virtual string getModelFile(()) {}

   /*! @name Media
   @{ */
   /*! */
   /*!
   %Path and filename of the model file (.DTS, .DAE) to use for this TSStatic.
   
    */
   filename shapeName;
   /*!
   @brief The skin applied to the shape.

'Skinning' the shape effectively renames the material targets, allowing different materials to be used on different instances of the same model.

Any material targets that start with the old skin name have that part of the name replaced with the new skin name. The initial old skin name is "base". For example, if a new skin of "blue" was applied to a model that had material targets <i>base_body</i> and <i>face</i>, the new targets would be <i>blue_body</i> and <i>face</i>. Note that <i>face</i> was not renamed since it did not start with the old skin name of "base".

To support models that do not use the default "base" naming convention, you can also specify the part of the name to replace in the skin field itself. For example, if a model had a material target called <i>shapemat</i>, we could apply a new skin "shape=blue", and the material target would be renamed to <i>bluemat</i> (note "shape" has been replaced with "blue").

Multiple skin updates can also be applied at the same time by separating them with a semicolon. For example: "base=blue;face=happy_face".

Material targets are only renamed if an existing Material maps to that name, or if there is a diffuse texture in the model folder with the same name as the new target.


   
    */
   string skin;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   Enables automatic playing of the animation sequence named "ambient" (if it exists) when the TSStatic is loaded.
   
    */
   bool playAmbient;
   /*!
   Enables detailed culling of meshes within the TSStatic. Should only be used with large complex shapes like buildings which contain many submeshes.
   
    */
   bool meshCulling;
   /*!
   Enables translucent sorting of the TSStatic by its origin instead of the bounds.
   
    */
   bool originSort;
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /*!
   The type of mesh data to use for collision queries.
   
    */
   TSMeshType collisionType;
   /*!
   The type of mesh data used to clip decal polygons against.
   
    */
   TSMeshType decalType;
   /*!
   @brief Allow a Player to walk up sloping polygons in the TSStatic (based on the collisionType).

When set to false, the slightest bump will stop the player from walking on top of the object.

   
    */
   bool allowPlayerStep;
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /*!
   Debug rendering mode shows the normals for each point in the TSStatic's mesh.
   
    */
   float renderNormals;
   /*!
   Forces rendering to a particular detail level.
   
    */
   int forceDetail;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AwShape : public TSStatic {
  public:
   virtual void execJavaScript(( string script )) {}

   /*! @name Media
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  AwTextureTarget : public SimObject {
  public:
   virtual void execJavaScript(( string script )) {}
   virtual void reload(()) {}
   /*!
   The URL which is loaded initially.
   
    */
   string StartURL;
   /*!
   Name of the texture target. The texture name can be used in materials to reference this AwTextureTarget.
   
    */
   string TextureTargetName;
   /*!
   The amount of frames per second to render. 0 means unlimited.
   
    */
   char Framerate;
   /*!
   Resolution. Defaults to (640, 480).
   
    */
   Point2I Resolution;
   /*!
   The bitmap which is used as a cursor. A default cursor will be used if none is set.
   
    */
   string CursorBitmap;
   /*!
   Tells this AwTextureTarget to only generate a single frame. This consumes much less resources than a regular AwTextureTarget. Default: Disabled
   
    */
   bool IsSingleFrame;
   /*!
   If set, enables the bitmap cache. This cache is useful when the webpage is loading and you want the user to see something right away.
   
    */
   bool UseBitmapCache;
   /*!
   Forces the BitmapCache filename instead of letting the system chose a filename automatically.
   
    */
   string BitmapCachePath;
   /*!
   The sound profile to play when gaining mouse input.
   
    */
   SFXTrack OnGainMouseInputSound;
   /*!
   The sound profile to play when losing mouse input.
   
    */
   SFXTrack OnLoseMouseInputSound;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!

 */
class  NetSimGroup : public NetObject {
  public:
   /*! 

 */
   virtual bool setMembershipPath(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The TerrainMaterial class orginizes the material settings for a single terrain material layer.

@note You should not be creating TerrainMaterials by hand in code. All TerrainMaterials should be created in the editors, as intended by the system.

@tsexample
// Created by the Terrain Painter tool in the World Editor
new TerrainMaterial()
{
^internalName = "grass1";
^diffuseMap = "art/terrains/Test/grass1";
^detailMap = "art/terrains/Test/grass1_d";
^detailSize = "10";
^isManaged = "1";
^detailBrightness = "1";
^Enabled = "1";
^diffuseSize = "200";
};
@endtsexample

@see Materials
@ingroup enviroMisc
 */
class  TerrainMaterial : public SimObject {
  public:
   /*! Sends the material to the server
@ingroup AFX */
   virtual void RemoteTerrainMaterialAdd(()) {}
   /*! Sends the material to the server
@ingroup AFX */
   virtual void RemoteTerrainMaterialDel(()) {}
   /*! Sends the material to the server
@ingroup AFX */
   virtual void RemoteTerrainMaterialAddToTerrain(( TerrainBlock tb )) {}
   /*!
   Base texture for the material
   
    */
   filename diffuseMap;
   /*!
   Used to scale the diffuse map to the material square
   
    */
   float diffuseSize;
   /*!
   Bump map for the material
   
    */
   filename normalMap;
   /*!
   Detail map for the material
   
    */
   filename detailMap;
   /*!
   Used to scale the detail map to the material square
   
    */
   float detailSize;
   /*!
   Exponentially sharpens or lightens the detail map rendering on the material
   
    */
   float detailStrength;
   /*!
   Changes how far camera can see the detail map rendering on the material
   
    */
   float detailDistance;
   /*!
   Makes that terrain material project along the sides of steep slopes instead of projected downwards
   
    */
   bool useSideProjection;
   /*!
   Macro map for the material
   
    */
   filename macroMap;
   /*!
   Used to scale the Macro map to the material square
   
    */
   float macroSize;
   /*!
   Exponentially sharpens or lightens the Macro map rendering on the material
   
    */
   float macroStrength;
   /*!
   Changes how far camera can see the Macro map rendering on the material
   
    */
   float macroDistance;
   /*!
   Used to scale the height from the normal map to give some self occlusion effect (aka parallax) to the terrain material
   
    */
   float parallaxScale;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Provides the basis for implementing a multiplayer game protocol.

NetConnection combines a low-level notify protocol implemented in ConnectionProtocol with a SimGroup, and implements several distinct subsystems:

- <b>Event Manager</b>  This is responsible for transmitting NetEvents over the wire.  It deals with ensuring that the various types of NetEvents are delivered appropriately, and with notifying the event of its delivery status.

- <b>Move Manager</b>  This is responsible for transferring a Move to the server 32 times a second (on the client) and applying it to the control object (on the server).

- <b>Ghost Manager</b>  This is responsible for doing scoping calculations (on the server side) and transmitting most-recent ghost information to the client.

- <b>File Transfer</b>  It is often the case that clients will lack important files when connecting to a server which is running a mod or new map. This subsystem allows the server to transfer such files to the client.

- <b>Networked String Table</b>  String data can easily soak up network bandwidth, so for efficiency, we implement a networked string table. We can then notify the connection of strings we will reference often, such as player names, and transmit only a tag, instead of the whole string.

- <b>Demo Recording</b>  A demo in Torque is a log of the network traffic between client and server; when a NetConnection records a demo, it simply logs this data to a file. When it plays a demo back, it replays the logged data.

- <b>Connection Database</b>  This is used to keep track of all the NetConnections; it can be iterated over (for instance, to send an event to all active connections), or queried by address.

The NetConnection is a SimGroup. On the client side, it contains all the objects which have been ghosted to that client. On the server side, it is empty; it can be used (typically in script) to hold objects related to the connection. For instance, you might place an observation camera in the NetConnnection. In both cases, when the connection is destroyed, so are the contained objects.

The NetConnection also has the concept of local connections.  These are used when the client and server reside in the same process.  A local connection is typically required to use the standard Torque world building tools.  A local connection is also required when building a single player game.

@see @ref Networking, @ref ghosting_scoping, @ref netconnection_simgroup, @ref local_connections, GameConnection, AIConnection, and AIClient.

@ingroup Networking
 */
class  NetConnection : public SimGroup {
  public:
   /*! Returns the ghost-index for an object.

@ingroup AFX */
   virtual int GetGhostIndex(( NetObject obj )) {}
   /*! Resolves a ghost-index into an object ID.

@ingroup AFX */
   virtual int ResolveGhost(( int ghostIndex )) {}
   /*! @brief Sent by the server during phase 2 of the mission download to update motion spline paths.

The server transmits all spline motion paths that are within the mission (Path) separate from other objects.  This is due to the potentially large number of nodes within each path, which may saturate a packet sent to the client.  By managing this step separately, Torque has finer control over how packets are organised vs. doing it during the ghosting stage.

Internally a PathManager is used to track all paths defined within a mission on the server, and each one is transmitted using a PathManagerEvent.  The client side collects these events and builds the given paths within its own PathManager.  This is typically done during the standard mission start phase 2 when following Torque's example mission startup sequence.

When a mission is ended, all paths need to be cleared from their respective path managers.@tsexample
function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
{
   // Make sure to ignore calls from a previous mission load
   if (%seq != $missionSequence || !$MissionRunning)
      return;
   if (%client.currentPhase != 1.5)
      return;
   %client.currentPhase = 2;

   // Set the player datablock choice
   %client.playerDB = %playerDB;

   // Update mission paths (SimPath), this needs to get there before the objects.
   %client.transmitPaths();

   // Start ghosting objects to the client
   %client.activateGhosting();
}
@endtsexample
@see clearPaths()
@see Path
 */
   virtual void transmitPaths(()) {}
   /*! @brief On the server, resets the connection to indicate that motion spline paths have not been transmitted.

Typically when a mission has ended on the server, all connected clients are informed of this change and their connections are reset back to a starting state.  This method resets a connection on the server to indicate that motion spline paths have not been transmitted.

@tsexample
   // Inform the clients
   for (%clientIndex = 0; %clientIndex < ClientGroup.getCount(); %clientIndex++)
   {
      // clear ghosts and paths from all clients
      %cl = ClientGroup.getObject(%clientIndex);
      %cl.endMission();
      %cl.resetGhosting();
      %cl.clearPaths();
   }
@endtsexample
@see transmitPaths()
@see Path
 */
   virtual void clearPaths(()) {}
   /*! @brief Returns the far end network address for the connection.

The address will be in one of the following forms:
- <b>IP:Broadcast:&lt;port&gt;</b> for broadcast type addresses
- <b>IP:&lt;address&gt;:&lt;port&gt;</b> for IP addresses
- <b>local</b> when connected locally (server and client running in same process
 */
   virtual string getAddress(()) {}
   /*! @brief Simulate network issues on the connection for testing.

@param packetLoss The fraction of packets that will be lost.  Ranges from 0.0 (no loss) to 1.0 (complete loss)
@param delay Delays packets being transmitted by simulating a particular ping.  This is an absolute integer, measured in ms.
 */
   virtual void setSimulatedNetParams(( float packetLoss, int delay )) {}
   /*! @brief Returns the average round trip time (in ms) for the connection.

The round trip time is recalculated every time a notify packet is received.  Notify packets are used to information the connection that the far end successfully received the sent packet.
 */
   virtual int getPing(()) {}
   /*! @brief Returns the percentage of packets lost per tick.

@note This method is not yet hooked up.
 */
   virtual int getPacketLoss(()) {}
   /*! @brief Ensures that all configured packet rates and sizes meet minimum requirements.

This method is normally only called when a NetConnection class is first constructed.  It need only be manually called if the global variables that set the packet rate or size have changed.

@note If @$pref::Net::PacketRateToServer, @$pref::Net::PacketRateToClient or @$pref::Net::PacketSize have been changed since a NetConnection has been created, this method must be called on all connections for them to follow the new rates or size.
 */
   virtual void checkMaxRate(()) {}
   /*! @brief On the client, convert a ghost ID from this connection to a real SimObject ID.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the client to discover an object's local SimObject ID when you only have a ghost ID.
@param ghostID The ghost ID of the object as sent by the server.
@returns The SimObject ID of the object, or 0 if it could not be resolved.

@tsexample
%object = ServerConnection.resolveGhostID( %ghostId );
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual int resolveGhostID(( int ghostID )) {}
   /*! @brief On the server, convert a ghost ID from this connection to a real SimObject ID.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the server to discover an object's local SimObject ID when you only have a ghost ID.
@param ghostID The ghost ID of the object as sent by the server.
@returns The SimObject ID of the object, or 0 if it could not be resolved.

@tsexample
%object = %client.resolveObjectFromGhostIndex( %ghostId );
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual int resolveObjectFromGhostIndex(( int ghostID )) {}
   /*! @brief On server or client, convert a real id to the ghost id for this connection.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the server or client to discover an object's ghost ID based on its real SimObject ID.
@param realID The real SimObject ID of the object.
@returns The ghost ID of the object for this connection, or -1 if it could not be resolved.

@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual int getGhostID(( int realID )) {}
   /*! @brief Connects to the remote address.

Attempts to connect with another NetConnection on the given address.  Typically once connected, a game's information is passed along from the server to the client, followed by the player entering the game world.  The actual procedure is dependent on the NetConnection subclass that is used.  i.e. GameConnection.
@param remoteAddress The address to connect to in the form of IP:&lt;address&gt;:&lt;port&rt; although the <i>IP:</i> portion is optional.  The <i>address</i> portion may be in the form of w.x.y.z or as a host name, in which case a DNS lookup will be performed.  You may also substitue the word <i>broadcast</i> for the address to broadcast the connect request over the local subnet.

@see NetConnection::connectLocal() to connect to a server running within the same process as the client.
 */
   virtual void connect(( string remoteAddress )) {}
   /*! @brief Connects with the server that is running within the same process as the client.

@returns An error text message upon failure, or an empty string when successful.

@see See @ref local_connections for a description of local connections and their use.  See NetConnection::connect() to connect to a server running in another process (on the same machine or not).
 */
   virtual string connectLocal(()) {}
   /*! @brief Provides the number of active ghosts on the connection.

@returns The number of active ghosts.
@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual int getGhostsActive(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The game-specific subclass of NetConnection.

The GameConnection introduces the concept of the control object.  The control object is simply the object that the client is associated with that network connection controls.  By default the control object is an instance of the Player class, but can also be an instance of Camera (when editing the mission, for example), or any other ShapeBase derived class as appropriate for the game.

Torque uses a model in which the server is the authoritative master of the simulation.  To prevent clients from cheating, the server simulates all player moves and then tells the client where his player is in the world.  This model, while secure, can have problems.  If the network latency is high, this round-trip time can give the player a very noticeable sense of movement lag.  To correct this problem, the game uses a form of prediction - it simulates the movement of the control object on the client and on the server both.  This way the client doesn't need to wait for round-trip verification of his moves.  Only in the case of a force acting on the control object on the server that doesn't exist on the client does the client's position need to be forcefully changed.

To support this, all control objects (derivative of ShapeBase) must supply a writePacketData() and readPacketData() function that send enough data to accurately simulate the object on the client.  These functions are only called for the current control object, and only when the server can determine that the client's simulation is somehow out of sync with the server.  This occurs usually if the client is affected by a force not present on the server (like an interpolating object) or if the server object is affected by a server only force (such as the impulse from an explosion).

The Move structure is a 32 millisecond snapshot of player input, containing x, y, and z positional and rotational changes as well as trigger state changes. When time passes in the simulation moves are collected (depending on how much time passes), and applied to the current control object on the client. The same moves are then packed over to the server in GameConnection::writePacket(), for processing on the server's version of the control object.

@see @ref Networking, NetConnection, ShapeBase

@ingroup Networking
 */
class  GameConnection : public NetConnection {
  public:
   virtual void SetSpeedModifier(( float amount=0 )) {}
      /*! @brief Called on the client when the connection to the server times out.

 */
      void onConnectionTimedOut();

      /*! @brief Called on the client when the connection to the server has been established.

 */
      void onConnectionAccepted();

      /*! @brief Called when connection attempts have timed out.

 */
      void onConnectRequestTimedOut();

      /*! @brief Called on the client when the connection to the server has been dropped.

@param reason The reason why the connection was dropped.

 */
      void onConnectionDropped( string reason );

      /*! @brief Called on the client when the connection to the server has been rejected.

@param reason The reason why the connection request was rejected.

 */
      void onConnectRequestRejected( string reason );

      /*! @brief Called on the client when there is an error with the connection to the server.

@param errorString The connection error text.

 */
      void onConnectionError( string errorString );

      /*! @brief Called on the server when the client's connection has been dropped.

@param disconnectReason The reason why the connection was dropped.

 */
      void onDrop( string disconnectReason );

      /*! @brief Called on the client when the first control object has been set by the server and we are now ready to go.

A common action to perform when this callback is called is to switch the GUI canvas from the loading screen and over to the 3D game GUI. */
      void initialControlSet();

      /*! @brief Called on the client when the control object has been changed by the server.

 */
      void onControlObjectChange();

      /*! @brief Called on the client to display the lag icon.

When the connection with the server is lagging, this callback is called to allow the game GUI to display some indicator to the player.

@param state Set to true if the lag icon should be displayed.

 */
      void setLagIcon( bool state );

      /*! @brief Called on the server when all datablocks has been sent to the client.

During phase 1 of the mission download, all datablocks are sent from the server to the client.  Once all datablocks have been sent, this callback is called and the mission download procedure may move on to the next phase.

@param sequence The sequence is common between the server and client and ensures that the client is acting on the most recent mission start process.  If an errant network packet (one that was lost but has now been found) is received by the client with an incorrect sequence, it is just ignored.  This sequence number is updated on the server every time a mission is loaded.

@see GameConnection::transmitDataBlocks()

 */
      void onDataBlocksDone( int sequence );

      /*! @brief Called on the client when the damage flash or white out states change.

When the server changes the damage flash or white out values, this callback is called either is on or both are off.  Typically this is used to enable the flash postFx.

@param state Set to true if either the damage flash or white out conditions are active.

 */
      void onFlash( bool state );

   /*! @brief On the client, set the password that will be passed to the server.

On the server, this password is compared with what is stored in $pref::Server::Password.  If $pref::Server::Password is empty then the client's sent password is ignored.  Otherwise, if the passed in client password and the server password do not match, the CHR_PASSWORD error string is sent back to the client and the connection is immediately terminated.

This password checking is performed quite early on in the connection request process so as to minimize the impact of multiple failed attempts -- also known as hacking. */
   virtual void setJoinPassword(( string password )) {}
   /*! @brief On the client, pass along a variable set of parameters to the server.

Once the connection is established with the server, the server calls its onConnect() method with the client's passed in parameters as aruments.

@see GameConnection::onConnect()

 */
   virtual void setConnectArgs((const char* args)) {}
   /*! @brief Sent by the server during phase 1 of the mission download to send the datablocks to the client.

SimDataBlocks, also known as just datablocks, need to be transmitted to the client prior to the client entering the game world.  These represent the static data that most objects in the world reference.  This is typically done during the standard mission start phase 1 when following Torque's example mission startup sequence.

When the datablocks have all been transmitted, onDataBlocksDone() is called to move the mission start process to the next phase.@param sequence The sequence is common between the server and client and ensures that the client is acting on the most recent mission start process.  If an errant network packet (one that was lost but has now been found) is received by the client with an incorrect sequence, it is just ignored.  This sequence number is updated on the server every time a mission is loaded.

@tsexample
function serverCmdMissionStartPhase1Ack(%client, %seq)
{
   // Make sure to ignore calls from a previous mission load
   if (%seq != $missionSequence || !$MissionRunning)
      return;
   if (%client.currentPhase != 0)
      return;
   %client.currentPhase = 1;

   // Start with the CRC
   %client.setMissionCRC( $missionCRC );

   // Send over the datablocks...
   // OnDataBlocksDone will get called when have confirmation
   // that they've all been received.
   %client.transmitDataBlocks($missionSequence);
}
@endtsexample

@see GameConnection::onDataBlocksDone()

 */
   virtual void transmitDataBlocks(( int sequence )) {}
   /*! @brief Called by the server during phase 2 of the mission download to start sending ghosts to the client.

Ghosts represent objects on the server that are in scope for the client.  These need to be synchronized with the client in order for the client to see and interact with them.  This is typically done during the standard mission start phase 2 when following Torque's example mission startup sequence.

@tsexample
function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
{
   // Make sure to ignore calls from a previous mission load
   if (%seq != $missionSequence || !$MissionRunning)
      return;
   if (%client.currentPhase != 1.5)
      return;
   %client.currentPhase = 2;

   // Set the player datablock choice
   %client.playerDB = %playerDB;

   // Update mod paths, this needs to get there before the objects.
   %client.transmitPaths();

   // Start ghosting objects to the client
   %client.activateGhosting();
}
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual void activateGhosting(()) {}
   /*! @brief On the server, resets the connection to indicate that ghosting has been disabled.

Typically when a mission has ended on the server, all connected clients are informed of this change and their connections are reset back to a starting state.  This method resets a connection on the server to indicate that ghosts are no longer being transmitted.  On the client end, all ghost information will be deleted.

@tsexample
   // Inform the clients
   for (%clientIndex = 0; %clientIndex < ClientGroup.getCount(); %clientIndex++)
   {
      // clear ghosts and paths from all clients
      %cl = ClientGroup.getObject(%clientIndex);
      %cl.endMission();
      %cl.resetGhosting();
      %cl.clearPaths();
   }
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.

 */
   virtual void resetGhosting(()) {}
   /*! @brief On the server, sets the object that the client will control.

By default the control object is an instance of the Player class, but can also be an instance of Camera (when editing the mission, for example), or any other ShapeBase derived class as appropriate for the game.

@param ctrlObj The GameBase object on the server to control. */
   virtual bool setControlObject(( GameBase ctrlObj )) {}
   /*! @brief Clear any display device.

A display device may define a number of properties that are used during rendering.

 */
   virtual void clearDisplayDevice(()) {}
   /*! @brief On the server, returns the object that the client is controlling.By default the control object is an instance of the Player class, but can also be an instance of Camera (when editing the mission, for example), or any other ShapeBase derived class as appropriate for the game.

@see GameConnection::setControlObject()

 */
   virtual string getControlObject(()) {}
   /*! @brief Returns true if this connection is AI controlled.

@see AIConnection */
   virtual bool isAIControlled(()) {}
   /*! @brief Returns true if the object being controlled by the client is making use of a rotation damped camera.

@see Camera */
   virtual bool isControlObjectRotDampedCamera(()) {}
   /*! @brief Used on the server to play a 2D sound that is not attached to any object.

@param profile The SFXProfile that defines the sound to play.

@tsexample
function ServerPlay2D(%profile)
{
   // Play the given sound profile on every client.
   // The sounds will be transmitted as an event, not attached to any object.
   for(%idx = 0; %idx < ClientGroup.getCount(); %idx++)
      ClientGroup.getObject(%idx).play2D(%profile);
}
@endtsexample

 */
   virtual bool play2D(( SFXProfile profile )) {}
   /*! @brief Used on the server to play a 3D sound that is not attached to any object.

@param profile The SFXProfile that defines the sound to play.
@param location The position and orientation of the 3D sound given in the form of "x y z ax ay az aa".

@tsexample
function ServerPlay3D(%profile,%transform)
{
   // Play the given sound profile at the given position on every client
   // The sound will be transmitted as an event, not attached to any object.
   for(%idx = 0; %idx < ClientGroup.getCount(); %idx++)
      ClientGroup.getObject(%idx).play3D(%profile,%transform);
}
@endtsexample

 */
   virtual bool play3D(( SFXProfile profile, TransformF location )) {}
   /*! @brief Sets the size of the chase camera's matrix queue.

@note This sets the queue size across all GameConnections.

@note This is not currently hooked up.

 */
   virtual bool chaseCam(( int size )) {}
   /*! @brief Returns the default field of view as used by the control object's camera.

 */
   virtual float getControlCameraDefaultFov(()) {}
   /*! @brief On the server, sets the control object's camera's field of view.

@param newFOV New field of view (in degrees) to force the control object's camera to use.  This value is clamped to be within the range of 1 to 179 degrees.

@note When transmitted over the network to the client, the resolution is limited to one degree.  Any fraction is dropped. */
   virtual void setControlCameraFov(( float newFOV )) {}
   /*! @brief Returns the field of view as used by the control object's camera.

 */
   virtual float getControlCameraFov(()) {}
   /*! @brief On the client, get the control object's damage flash level.

@return flash level
 */
   virtual float getDamageFlash(()) {}
   /*! @brief On the client, get the control object's white-out level.

@return white-out level
 */
   virtual float getWhiteOut(()) {}
   /*! @brief On the server, sets the client's 3D display to fade to black.

@param doFade Set to true to fade to black, and false to fade from black.
@param timeMS Time it takes to perform the fade as measured in ms.

@note Not currently hooked up, and is not synchronized over the network. */
   virtual void setBlackOut(( bool doFade, int timeMS )) {}
   /*! @brief On the server, transmits the mission file's CRC value to the client.

Typically, during the standard mission start phase 1, the mission file's CRC value on the server is send to the client.  This allows the client to determine if the mission has changed since the last time it downloaded this mission and act appropriately, such as rebuilt cached lightmaps.

@param CRC The mission file's CRC value on the server.

@tsexample
function serverCmdMissionStartPhase1Ack(%client, %seq)
{
   // Make sure to ignore calls from a previous mission load
   if (%seq != $missionSequence || !$MissionRunning)
      return;
   if (%client.currentPhase != 0)
      return;
   %client.currentPhase = 1;

   // Start with the CRC
   %client.setMissionCRC( $missionCRC );

   // Send over the datablocks...
   // OnDataBlocksDone will get called when have confirmation
   // that they've all been received.
   %client.transmitDataBlocks($missionSequence);
}
@endtsexample

 */
   virtual void setMissionCRC(( int CRC )) {}
   /*! @brief On the server, disconnect a client and pass along an optional reason why.

This method performs two operations: it disconnects a client connection from the server, and it deletes the connection object.  The optional reason is sent in the disconnect packet and is often displayed to the user so they know why they've been disconnected.

@param reason [optional] The reason why the user has been disconnected from the server.

@tsexample
function kick(%client)
{
   messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

   if (!%client.isAIControlled())
      BanList::add(%client.guid, %client.getAddress(), $Pref::Server::KickBanTime);
   %client.delete("You have been kicked from this server");
}
@endtsexample

 */
   virtual void delete(( string reason="" )) {}
   /*! @brief On the client, starts recording the network connection's traffic to a demo file.

It is often useful to play back a game session.  This could be for producing a demo of the game that will be shown at a later time, or for debugging a game.  By recording the entire network stream it is possible to later play game the game exactly as it unfolded during the actual play session.  This is because all user control and server results pass through the connection.

@param fileName The file name to use for the demo recording.

@see GameConnection::stopRecording(), GameConnection::playDemo() */
   virtual void startRecording(( string fileName )) {}
   /*! @brief On the client, stops the recording of a connection's network traffic to a file.

@see GameConnection::startRecording(), GameConnection::playDemo() */
   virtual void stopRecording(()) {}
   /*! @brief On the client, play back a previously recorded game session.

It is often useful to play back a game session.  This could be for producing a demo of the game that will be shown at a later time, or for debugging a game.  By recording the entire network stream it is possible to later play game the game exactly as it unfolded during the actual play session.  This is because all user control and server results pass through the connection.

@returns True if the playback was successful.  False if there was an issue, such as not being able to open the demo file for playback.

@see GameConnection::startRecording(), GameConnection::stopRecording() */
   virtual bool playDemo(( string demoFileName )) {}
   /*! @brief Returns true if a previously recorded demo file is now playing.

@see GameConnection::playDemo() */
   virtual bool isDemoPlaying(()) {}
   /*! @brief Returns true if a demo file is now being recorded.

@see GameConnection::startRecording(), GameConnection::stopRecording() */
   virtual bool isDemoRecording(()) {}
   /*! @brief List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.

@note The list is sent to the console.

 */
   virtual void listClassIDs(()) {}
   /*! @brief On the client, this static mehtod will return the connection to the server, if any.

@returns The SimObject ID of the server connection, or -1 if none is found.

 */
   virtual int getServerConnection(()) {}
   /*! @brief On the server, set the connection's camera object used when not viewing through the control object.

@see GameConnection::getCameraObject() and GameConnection::clearCameraObject()

 */
   virtual bool setCameraObject(( GameBase camera )) {}
   /*! @brief Returns the connection's camera object used when not viewing through the control object.

@see GameConnection::setCameraObject() and GameConnection::clearCameraObject()

 */
   virtual string getCameraObject(()) {}
   /*! @brief Clear the connection's camera object reference.

@see GameConnection::setCameraObject() and GameConnection::getCameraObject()

 */
   virtual void clearCameraObject(()) {}
   /*! @brief Returns true if this connection is in first person mode.

@note Transition to first person occurs over time via mCameraPos, so this won't immediately return true after a set.

 */
   virtual bool isFirstPerson(()) {}
   /*! @brief On the server, sets this connection into or out of first person mode.

@param firstPerson Set to true to put the connection into first person mode.

 */
   virtual void setFirstPerson(( bool firstPerson )) {}
   /*! @brief Set the control scheme that may be used by a connection's control object.

@param absoluteRotation Use absolute rotation values from client, likely through ExtendedMove.
@param addYawToAbsRot Add relative yaw control to the absolute rotation calculation.  Only useful when absoluteRotation is true.

 */
   virtual void setControlSchemeParameters(( bool absoluteRotation, bool addYawToAbsRot, bool addPitchToAbsRot )) {}
   /*! @brief Get the connection's control scheme absolute rotation property.

@return True if the connection's control object should use an absolute rotation control scheme.

@see GameConnection::setControlSchemeParameters()

 */
   virtual bool getControlSchemeAbsoluteRotation(()) {}
   /*! @brief Connects to the remote address.

Attempts to connect with another NetConnection on the given address.  Typically once connected, a game's information is passed along from the server to the client, followed by the player entering the game world.  The actual procedure is dependent on the NetConnection subclass that is used.  i.e. GameConnection.
@param remoteAddress The address to connect to in the form of IP:&lt;address&gt;:&lt;port&rt; although the <i>IP:</i> portion is optional.  The <i>address</i> portion may be in the form of w.x.y.z or as a host name, in which case a DNS lookup will be performed.  You may also substitue the word <i>broadcast</i> for the address to broadcast the connect request over the local subnet.

@see NetConnection::connectLocal() to connect to a server running within the same process as the client.
 */
   virtual void connect(( string remoteAddress )) {}
   virtual void throttleClient(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Special client connection driven by an AI, rather than a human.

Unlike other net connections, AIConnection is intended to run unmanned. Rather than gathering input from a human using a device, move events, triggers, and look events are driven through functions like AIConnection::setMove.

In addition to having its own set of functions for managing client move events, a member variable inherited by GameConnection is toggle: mAIControlled. This is useful for a server to determine if a connection is AI driven via the function GameConnection::isAIControlled

AIConnection is an alternative to manually creating an AI driven game object. When you want the server to manage AI, you will create a specific one from script using a class like AIPlayer. If you do not want the server managing the AI and wish to simulate a complete client connection, you will use AIConnection

.To get more specific, if you want a strong alternative to AIPlayer (and wish to make use of the AIConnection structure), consider AIClient. AIClient inherits from AIConnection, contains quite a bit of functionality you will find in AIPlayer, and has its own Player object.

@tsexample
// Create a new AI client connection
%botConnection = aiConnect("MasterBlaster" @ %i, -1, 0.5, false, "SDF", 1.0);

// In another area of the code, you can locate this and any other AIConnections
// using the isAIControlled function
for(%i = 0; %i < ClientGroup.getCount(); %i++)
{
   %client = ClientGroup.getObject(%i);
   if(%client.isAIControlled())
   {
      // React to this AI controlled client
   }
}
@endtsexample

@note This is a legacy class, which you are discouraged from using as it will most likely be deprecated in a future version. For now it has been left in for backwards compatibility with TGE and the old RTS Kit. Use GameConnection and AIPlayer instead.

@see GameConnection, NetConnection, AIClient

@ingroup AI
@ingroup Networking
 */
class  AIConnection : public GameConnection {
  public:
   /*! Set a field on the current move.

@param   field One of {'x','y','z','yaw','pitch','roll'}
@param   value Value to set field to. */
   virtual void setMove((string field, float value)) {}
   /*! Get the given field of a move.

@param field One of {'x','y','z','yaw','pitch','roll'}
@returns The requested field on the current move. */
   virtual float getMove((string field)) {}
   /*! Enable/disable freelook on the current move. */
   virtual void setFreeLook((bool isFreeLook)) {}
   /*! getFreeLook()Is freelook on for the current move? */
   virtual bool getFreeLook() {}
   /*! Set a trigger. */
   virtual void setTrigger((int trigger, bool set)) {}
   /*! Is the given trigger set? */
   virtual bool getTrigger((int trigger)) {}
   virtual string getAddress() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Simulated client driven by AI commands.

This object is derived from the AIConnection class. It introduces its own Player object to solidify the purpose of this class: Simulated client connecting as a player

To get more specific, if you want a strong alternative to AIPlayer (and wish to make use of the AIConnection structure), consider AIClient. AIClient inherits from AIConnection, contains quite a bit of functionality you will find in AIPlayer, and has its own Player object.

@note This is a legacy class, which you are discouraged from using as it will most likely be deprecated in a future version. For now it has been left in for backwards compatibility with TGE and the old RTS Kit. Use AIPlayer instead.

@see AIPlayer, AIConnection

@ingroup AI
@ingroup Networking
 */
class  AIClient : public AIConnection {
  public:
   /*! ai.setMoveSpeed( float ); */
   virtual void setMoveSpeed() {}
   /*! ai.stop(); */
   virtual void stop() {}
   /*! ai.setAimLocation( x y z ); */
   virtual void setAimLocation() {}
   /*! ai.setMoveDestination( x y z ); */
   virtual void setMoveDestination() {}
   /*! ai.getAimLocation(); */
   virtual string getAimLocation() {}
   /*! ai.getMoveDestination(); */
   virtual string getMoveDestination() {}
   /*! ai.setTargetObject( obj ); */
   virtual void setTargetObject() {}
   /*! ai.getTargetObject(); */
   virtual int getTargetObject() {}
   /*! ai.missionCycleCleanup(); */
   virtual void missionCycleCleanup() {}
   /*! ai.move(); */
   virtual void move() {}
   /*! ai.getLocation(); */
   virtual string getLocation() {}
   /*! ai.moveForward(); */
   virtual void moveForward() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  GraphEmitterData : public ParticleEmitterData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name Expression
   @{ */
   /*! */
   /*!
   Emit particles along the terrain rather than at the nodes position.
   
    */
   bool Grounded;
   /*!
   The expression specifying the emitted particles X coordinate.
   
    */
   string xFunc;
   /*!
   The expression specifying the emitted particles Y coordinate.
   
    */
   string yFunc;
   /*!
   The expression specifying the emitted particles Z coordinate.
   
    */
   string zFunc;
   /*!
   The expressions interval, maximum.
   
    */
   int funcMax;
   /*!
   The expressions interval, minimum.
   
    */
   int funcMin;
   /*!
   The amount to scale the t value with.
   
    */
   float timeScale;
   /*!
   String value that controls how the t value is increased.
   
    */
   gProgressMode ProgressMode;
   /*!
   Reverse the graphEmitter.
   
    */
   bool Reverse;
   /*!
   Loop the graphEmitter.
   
    */
   bool Loop;
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  GroundEmitterData : public ParticleEmitterData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name GroundEmitterData
   @{ */
   /*! */
   /*!
   Terrain material name to limit coverage to, or blank to not limit.
   
    */
   string layers;
   /*!
   Radius of the circle from the ejection position to emit particles in.
   
    */
   float radius;
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  MaskEmitterData : public ParticleEmitterData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name MaskEmitter
   @{ */
   /*! */
   /*!
   Size of the inbound circle of the emission mask.
   
    */
   float radius;
   /*!
   Minimum alpha value of the pixels in the mask to eject particles on.
   
    */
   char Alpha_min;
   /*!
   Maximum alpha value of the pixels in the mask to eject particles on.
   
    */
   char Alpha_max;
   /*!
   Emit particles along the terrain rather than at the nodes position.
   
    */
   bool Grounded;
   /*!
   
   
    */
   PixelMask PixelMask;
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  SphereEmitterData : public ParticleEmitterData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name SphereEmitterData
   @{ */
   /*! */
   /*!
   Distance Padding along ejection Z axis from which to eject particles.
   
    */
   float ejectionOffsetVariance;
   /*!
   Minimum angle, from the horizontal plane, to eject from.
   
    */
   float thetaMin;
   /*!
   Maximum angle, from the horizontal plane, to eject particles from.
   
    */
   float thetaMax;
   /*!
   Reference angle, from the vertical plane, to eject particles from.
   
    */
   float phiReferenceVel;
   /*!
   Variance from the reference angle, from 0 - 360.
   
    */
   float phiVariance;
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  TimedDebugVector : public SceneObject {
  public:
   /*! A utility method for forcing a network update.
 */
   virtual void postApply(()) {}
   /*!
   
   
    */
   Point3F Start;
   /*!
   
   
    */
   Point3F End;
   /*!
   
   
    */
   int duration;

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An object which spawns local emitters and interpolates specific values.
 */
class  ParticleEffect : public GameBase {
  public:
   virtual void dumpEmitters(()) {}
   virtual void reset(()) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  BillboardParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   Speed at which to spin the particle.
   
    */
   float spinSpeed;
   /*!
   Minimum allowed spin speed of this particle, between -1000 and spinRandomMax.
   
    */
   float spinRandomMin;
   /*!
   Maximum allowed spin speed of this particle, between spinRandomMin and 1000.
   
    */
   float spinRandomMax;
   /*!
   @brief Controls how particles blend with the scene.

If true, particles blend like ParticleBlendStyle NORMAL, if false, blend like ParticleBlendStyle ADDITIVE.
@note If ParticleEmitterData::blendStyle is set, it will override this value.
   
    */
   bool useInvAlpha;
   /*!
   If true, allow the particle texture to be an animated sprite.
   
    */
   bool animateTexture;
   /*!
   If animateTexture is true, this defines the frames per second of the sprite animation.
   
    */
   int framesPerSec;
   /*!
   @brief 4 element array defining the UV coords into textureName to use for this particle.

Coords should be set for the first tile only when using animTexTiling; coordinates for other tiles will be calculated automatically. "0 0" is top left and "1 1" is bottom right.
   
    */
   Point2F textureCoords;
   /*!
   @brief The number of frames, in rows and columns stored in textureName (when animateTexture is true).

A maximum of 256 frames can be stored in a single texture when using animTexTiling. Value should be "NumColumns NumRows", for example "4 4".
   
    */
   Point2I animTexTiling;
   /*!
   @brief A list of frames and/or frame ranges to use for particle animation if animateTexture is true.

Each frame token must be separated by whitespace. A frame token must be a positive integer frame number or a range of frame numbers separated with a '-'. The range separator, '-', cannot have any whitspace around it.

Ranges can be specified to move through the frames in reverse as well as forward (eg. 19-14). Frame numbers exceeding the number of tiles will wrap.
@tsexample
animTexFrames = "0-16 20 19 18 17 31-21";
@endtsexample

   
    */
   string animTexFrames;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string HighResTexture;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string MidResTexture;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string LowResTexture;
   /*!
   @brief Texture file to use for this particle.

Deprecated. use HighResTexture instead.
   
    */
   string textureName;
   /*!
   @brief Texture file to use for this particle if animateTexture is true.

Deprecated. Use textureName instead.
   
    */
   string animTexName;
   /*!
   @brief Particle RGBA color keyframe values.

The particle color will linearly interpolate between the color/time keys over the lifetime of the particle.
   
    */
   ColorF colors;
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  BillboardRibbonParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   Speed at which to spin the particle.
   
    */
   float spinSpeed;
   /*!
   Minimum allowed spin speed of this particle, between -1000 and spinRandomMax.
   
    */
   float spinRandomMin;
   /*!
   Maximum allowed spin speed of this particle, between spinRandomMin and 1000.
   
    */
   float spinRandomMax;
   /*!
   @brief Controls how particles blend with the scene.

If true, particles blend like ParticleBlendStyle NORMAL, if false, blend like ParticleBlendStyle ADDITIVE.
@note If ParticleEmitterData::blendStyle is set, it will override this value.
   
    */
   bool useInvAlpha;
   /*!
   If true, allow the particle texture to be an animated sprite.
   
    */
   bool animateTexture;
   /*!
   If animateTexture is true, this defines the frames per second of the sprite animation.
   
    */
   int framesPerSec;
   /*!
   @brief 4 element array defining the UV coords into textureName to use for this particle.

Coords should be set for the first tile only when using animTexTiling; coordinates for other tiles will be calculated automatically. "0 0" is top left and "1 1" is bottom right.
   
    */
   Point2F textureCoords;
   /*!
   @brief The number of frames, in rows and columns stored in textureName (when animateTexture is true).

A maximum of 256 frames can be stored in a single texture when using animTexTiling. Value should be "NumColumns NumRows", for example "4 4".
   
    */
   Point2I animTexTiling;
   /*!
   @brief A list of frames and/or frame ranges to use for particle animation if animateTexture is true.

Each frame token must be separated by whitespace. A frame token must be a positive integer frame number or a range of frame numbers separated with a '-'. The range separator, '-', cannot have any whitspace around it.

Ranges can be specified to move through the frames in reverse as well as forward (eg. 19-14). Frame numbers exceeding the number of tiles will wrap.
@tsexample
animTexFrames = "0-16 20 19 18 17 31-21";
@endtsexample

   
    */
   string animTexFrames;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string HighResTexture;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string MidResTexture;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string LowResTexture;
   /*!
   @brief Texture file to use for this particle.

Deprecated. use HighResTexture instead.
   
    */
   string textureName;
   /*!
   @brief Texture file to use for this particle if animateTexture is true.

Deprecated. Use textureName instead.
   
    */
   string animTexName;
   /*!
   @brief Particle RGBA color keyframe values.

The particle color will linearly interpolate between the color/time keys over the lifetime of the particle.
   
    */
   ColorF colors;
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  EffectParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   
   
    */
   ParticleEffectData EffectDatablock;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  EmitterParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   
   
    */
   ParticleEmitterData EmitterDatablock;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  PointLightParticleData : public SimDataBlock {
  public:
      /*!  */
      int CreateSceneObject();

   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   
   
    */
   ColorF color;
   /*!
   
   
    */
   ColorF ColorVariance;
   /*!
   
   
    */
   bool UseParticleColors;
   /*!
   
   
    */
   float brightness;
   /*!
   
   
    */
   float flareScale;
   /*!
   
   
    */
   LightFlareData FlareData;
   /*!
   @brief Particle RGBA color keyframe values.

The particle color will linearly interpolate between the color/time keys over the lifetime of the particle.
   
    */
   ColorF colors;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float ranges;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@tsexample
datablock ParticleData( GLWaterExpSmoke )
{
   textureName = "art/shapes/particles/smoke";
   dragCoefficient = 0.4;
   gravityCoefficient = -0.25;
   inheritedVelFactor = 0.025;
   constantAcceleration = -1.1;
   lifetimeMS = 1250;
   lifetimeVarianceMS = 0;
   useInvAlpha = false;
   spinSpeed = 1;
   spinRandomMin = -200.0;
   spinRandomMax = 200.0;

   colors[0] = "0.1 0.1 1.0 1.0";
   colors[1] = "0.4 0.4 1.0 1.0";
   colors[2] = "0.4 0.4 1.0 0.0";

   sizes[0] = 2.0;
   sizes[1] = 6.0;
   sizes[2] = 2.0;

   times[0] = 0.0;
   times[1] = 0.5;
   times[2] = 1.0;
};
@endtsexample
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  TSShapeParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   
   
    */
   filename shapeFile;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A gui control that is used to display an image.

The image is stretched to the constraints of the control by default. However, the control can also
tile the image as well.

The image itself is stored inside the GuiBitmapCtrl::bitmap field. The boolean value that decides
whether the image is stretched or tiled is stored inside the GuiBitmapCtrl::wrap field.
@tsexample
// Create a tiling GuiBitmapCtrl that displays "myImage.png"
%bitmapCtrl = new GuiBitmapCtrl()
{
   bitmap = "myImage.png";
   wrap = "true";
};
@endtsexample

 */
class  GuiSpellCtrl : public GuiControl {
  public:
   /*! Set the offset of the bitmap within the control.
@param x The x-axis offset of the image.
@param y The y-axis offset of the image.
 */
   virtual void setValue(( int x, int y )) {}
   virtual void setCooldownManager(( SpellManager MGR )) {}
   /*! Assign an image to the control.

@hide */
   virtual void setBitmap(( String filename | String filename, bool resize )) {}

   /*! @name Bitmap
   @{ */
   /*! */
   /*!
   
   
    */
   SpellData Spell;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for almost all objects involved in the simulation.

@ingroup Console
 */
class  SpellData : public SimDataBlock {
  public:
      /*!  */
      void onInitializeCast( SimObjectId spellID );

      /*!  */
      void onChannelBegin( SimObjectId spellID );

      /*!  */
      void onChannel( SimObjectId spellID );

      /*!  */
      void onChannelEnd( SimObjectId spellID );

      /*!  */
      void onPreCast( SimObjectId spellID );

      /*!  */
      void onCast( SimObjectId spellID );

      /*!  */
      void onPostCast( SimObjectId spellID );

   /*! Usage */
   virtual void beginCast(( SimObjectId ID=U32_MAX )) {}
   /*!
   
   
    */
   PickTypes CastType;
   /*!
   
   
    */
   TargetTypes TargetType;
   /*!
   
   
    */
   int TypeMask;
   /*!
   
   
    */
   int ChannelTimesMS;
   /*!
   
   
    */
   int CastTimesMS;
   /*!
   
   
    */
   SpellDecalManagerData SpellDecalManager;
   /*!
   
   
    */
   float range;
   /*!
   
   
    */
   int CooldownMS;
   /*!
   
   
    */
   float Cost;
   /*!
   
   
    */
   filename Logo;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for almost all objects involved in the simulation.

@ingroup Console
 */
class  Spell : public SimObject {
  public:
   virtual string getTargetPosition(()) {}
   virtual int getTarget(()) {}
   virtual int getSource(()) {}
   virtual int getClient(()) {}
   virtual int getDataBlock(()) {}
};

class  SpellManager : public SimObject {
  public:
      /*!  */
      void onOOM( SimDataBlock spellID );

      /*!  */
      void onOutOfRange( SimDataBlock spellID );

      /*!  */
      void onNoTarget( SimDataBlock spellID );

      /*!  */
      void onCooldown( SimDataBlock spellID, int TimeLeft );

      /*!  */
      void onTargetNotFound( SimDataBlock spellID );

      /*!  */
      void onAlreadyCastingSpell( SimDataBlock spellID );

      /*!  */
      void onTechnicalError( SimDataBlock spellID );

   /*! Usage */
   virtual bool beginCast(( SimDataBlock data=NULL, NetConnection client=NULL )) {}
   /*! Usage */
   virtual bool beginTargetCast(( SimDataBlock data=NULL, NetConnection client=NULL, NetObject target=NULL )) {}
   /*! usage */
   virtual void attach(( SimObjectId ID=NULL )) {}
   virtual void Interrupt(()) {}
   /*!
    */
   NetConnection Client;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  TargetIndicatorManager : public GameBase {
  public:
   virtual void SetIndicatorDataBlock(( SimDataBlock dat=NULL )) {}
   virtual void setTarget(( SceneObject obj=NULL )) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  TAPLinkGui : public GuiControl {
  public:
   /*! Test whether the TAP-Link is connected.
@return True if the TL is connected and there is a texture to render.

 */
   virtual bool isConnected(()) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  TLShape : public TSStatic {
  public:
   virtual void execJavaScript(( string script )) {}
   /*!
   The name of the material applied to the TAP-Link screen.
   
    */
   string ScreenMaterialName;

   /*! @name Media
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /// @}


   /*! @name Debug
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Renders a bitmap background that can display at multiple aspect ratios without any stretching or skewing.

@ingroup GuiImages
 */
class  GuiBitmapBackgroundCtrl : public GuiControl {
  public:
   /*! Assign an image to the control.

@hide */
   virtual void setBitmap(( String filename )) {}

   /*! @name Bitmap
   @{ */
   /*! */
   /*!
   The bitmap file to display in the control.
   
    */
   filename bitmap;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   The horizontal focal point if the image needs cropped to fit the control.
   
    */
   bool neverCrop;
   /*!
   The horizontal focal point if the image needs cropped to fit the control.
   
    */
   GuiHorizontalSizing horizBias;
   /*!
   The vertical focal point if the image needs cropped to fit the control.
   
    */
   GuiVerticalSizing vertBias;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  GuiCaptureFrame : public GuiControl {
  public:
      /*! Called whenever a screen capture is completed.
 */
      void onCaptureDone();

   /*! Take a screenshot of the frame contents.

 */
   virtual void captureFrame((string file, GuiPlayerView ctrl, bool isFullAlpha, GuiControlProfile backgroundProfile, GuiControl hideControl)) {}
   virtual void setCaptureSize((int X_extent, int Y_extent)) {}
   virtual string getCaptureSize(()) {}
   /*! Sets the bitmap to use for the overlay

\param imageName Path to the image file to display.
 */
   virtual bool installOverlay((string imageName)) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

   /*!
    */
   string captureFormat;
};

/*!
@brief Abstract base class for controls that store and display multiple elements in a single view.

You cannot actually instantiate this class. Instead you can use its childre:

- GuiConsole
- GuiTextListCtrl
- GuiTreeViewCtrl
- DbgFileView
- CreatorTree
This base class is primarily used by other internal classes or those dedicated to editors.

@ingroup GuiCore
 */
class  GuiArrayCtrl : public GuiControl {
  public:
      /*! Call when a cell in the array is selected (clicked).

@param @cell Coordinates of the cell */
      void onCellSelected( Point2I cell );

      /*! Call when a cell in the array is highlighted (moused over).

@param @cell Coordinates of the cell */
      void onCellHighlighted( Point2I cell );


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI control that displays a tab delimited text list with a column header. Text row items in the list can be individually selected.

@tsexample
      new GuiModernTextListCtrl(GameServerList)
^^{
^^^columns = "0 256";
^        fitParentWidth = "1";
^^^clipColumnText = "0";
^^    //Properties not specific to this control have been omitted from this example.
^^};
@endtsexample

@see Reference

@ingroup GuiControls
 */
class  GuiModernTextListCtrl : public GuiArrayCtrl {
  public:
      /*! @brief Called when the user has dragged and dropped a column header to new position.

@param colKey Key associated with the column that was moved.
@param colOldPos Column's previous index position in the header.
@param colNewPos Column's new and current index position in the header.
@tsexample
function GuiModernTextListCtrl::OnColumnMoved(%this, %colKey, %colOldPos, %colNewPos)
{
^// User has dragged and dropped a column to another position.
}
@endtsexample

@see GuiControl

 */
      void onColumnMoved( int colKey, int colOldPos, int colNewPos );

      /*! @brief Called when the user has resized the column header and just now let go of the resizer handle.

@param colKey Key associated with the column that was just resized.
@param colPos Index position of the column within the list's header.
@param width The new and current width of the column.
@tsexample
function GuiModernTextListCtrl::OnColumnResized(%this, %colKey, %colPos, %width)
{
^// User has resized the column in the list's header and just now let go of the resizer.
}
@endtsexample

@see GuiControl

 */
      void onColumnResized( int colKey, int colPos, int width );

      /*! @brief Called when the user has clicked on a column header.

@param colKey Key associated with the column that was just clicked.
@param colPos Index position of the column that was just clicked.
@param sortOrder Current sort order of the column that was just clicked.
@param doubleClick Value of one or true when this a double-click event.
@tsexample
function GuiModernTextListCtrl::OnColumnSelect(%this, %colKey, %colPos, %sortOrder, %doubleClick)
{
^// User has clicked on the column header and it's up to this function to decide on the response action to this event.
^// Such as the column's sort order rule could be changed to resort the column or do nothing to not allow the the user
^// to resort the column.
}
@endtsexample

@see GuiControl

 */
      void onColumnSelect( int colKey, int colPos, int sortOrder, bool doubleClick );

      /*! @brief Called when the user has selected a text row. Still called whether or not the selection is different since last time.

@param rowKey Key associated with the new and currently selected row.
@param rowPos Index position of the new and currently selected row.
@param colKey Key associated with the clicked on column during row selection.
@param colPos Index position of the clicked on column during row selection.
@param doubleClick Value of one or true when this a double-click event.
@tsexample
function GuiModernTextListCtrl::OnRowSelect(%this, %rowKey, %rowPos, %colKey, %colPos, %doubleClick)
{
^// User has clicked on a text row item and this event still fires even though the selection may not have changed.
}
@endtsexample

@see GuiControl

 */
      void onRowSelect( int rowKey, int rowPos, int colKey, int colPos, bool doubleClick );

      /*! @brief Called when the user has unselected a text row and no other row was selected. Also called when the selected row is removed from the list.

@tsexample
function GuiModernTextListCtrl::OnRowUnselect(%this)
{
^// User has deselected a text row item and no other items are selected.
}
@endtsexample

@see GuiControl

 */
      void onRowUnselect();

      /*! @brief Called when the delete key has been pressed.

@param index Index position of the row that is currently selected.
@param key The key associated with the row that is currently selected.n@tsexample
// The delete key was pressed while the GuiTextListCtrl was in focus, causing the callback to occur.
function GuiModernTextListCtrl::onDeleteKey(%this, %index, %key)
{
^// Code to run when the delete key is pressed
}
@endtsexample

@see GuiControl

 */
      void onDeleteKey( int index, int key );

   /*! 
 */
   virtual int addColumn(( int key=0, string name="", int width=50, int minWidth=10, int maxWidth=250, string flags="" )) {}
   /*! @brief Adds a new row at end of the list with the defined id and text.
If index is used, then the new row is inserted at the row location of 'index'.

@param Key The key to be associated with the new row.
@param text Text to display at the new row.
@param index Index to insert the new row at. If not used, new row will be placed at the end of the list.
@tsexample
// Define the id
%id = "4";

// Define the text to display
%text = "Display Text"

// Define the index (optional)
%index = "2"

// Inform the GuiTextListCtrl control to add the new row with the defined information.
%rowIndex = %thisGuiTextListCtrl.addRow(%id,%text,%index);
@endtsexample

@return Returns the row index of the new row.

@see References */
   virtual int addRow(( int key=0, string text="", int index=-1, string flags="" )) {}
   /*! 
 */
   virtual void removeRow(( int index )) {}
   /*! 
 */
   virtual void clearColumns(()) {}
   /*! 
 */
   virtual void clearRows(()) {}
   /*! 
 */
   virtual void clearSortOrders(()) {}
   /*! 
 */
   virtual string getColumnFlags(( int index )) {}
   /*! 
 */
   virtual string getColumnName(( int index )) {}
   /*! 
 */
   virtual int getColumnKey(( int index )) {}
   /*! 
 */
   virtual int getColumnWidth(( int index )) {}
   /*! 
 */
   virtual int getColumnIndex(( int key )) {}
   /*! 
 */
   virtual int getColumnCount(()) {}
   /*! 
 */
   virtual int getSortOrderCount(()) {}
   /*! 
 */
   virtual string getSortOrder(( int index )) {}
   /*! 
 */
   virtual int getSelectedRow(()) {}
   /*! 
 */
   virtual int getRowCount(()) {}
   /*! 
 */
   virtual string getRowFlags(( int index )) {}
   /*! 
 */
   virtual string getRowText(( int index )) {}
   /*! 
 */
   virtual int getRowKey(( int index )) {}
   /*! 
 */
   virtual int getRowIndex(( int key )) {}
   /*! @brief Scroll so the specified row is visible

@param rowNum Row number to make visible
@tsexample
// Define the row number to make visible
%rowNum = "4";

// Inform the GuiTextListCtrl control to scroll the list so the defined rowNum is visible.
%thisGuiTextListCtrl.scrollVisible(%rowNum);
@endtsexample

@see GuiControl */
   virtual void scrollVisible(( int rowNum )) {}
   /*! 
 */
   virtual void setSelectedRow(( int index )) {}
   /*! 
 */
   virtual void setSortOrder(( string rule )) {}
   /*! 
 */
   virtual void setColumnFlags(( int index, string flags )) {}
   /*! 
 */
   virtual void setColumnSortOrder(( int key, int order, bool pushToFirst=false )) {}
   /*! 
 */
   virtual void setColumnWidth(( int index, int width )) {}
   /*! 
 */
   virtual void setRowFlags(( int index, string flags )) {}
   /*! 
 */
   virtual void setRowText(( int index, string text )) {}
   /*! Set the header profile for the control to use.
The header profile used by a control determines a great part of its behavior and appearance for the column headers.
@param profile The new header profile the control should use.
@ref GuiControl_Profiles */
   virtual void setHeaderProfile(( GuiControlProfile profile )) {}
   /*! Set the column header sort indicator profile for the control to use.
The header profile used by a control determines a great part of its behavior and appearance for the column header sort indicator.
@param profile The new header profile the control should use.
@ref GuiControl_Profiles */
   virtual void setSortProfile(( GuiControlProfile profile )) {}
   /*! 
 */
   virtual void sortColumns(()) {}
   /*! 
 */
   virtual void moveColumn(( int key, int index )) {}
   /*! 
 */
   virtual void moveRow(( int key, int index )) {}
   /*! 
 */
   virtual string stripMarkup(( string text )) {}
   /*! 
 */
   virtual void updateSize(()) {}

   /*! @name Control
   @{ */
   /*! */
   /*!
   The control profile that determines fill styles, font settings, etc. for column headers
   
    */
   GuiControlProfile headerProfile;
   /*!
   The control profile that determines fill styles, font settings, etc. for sort order indicator
   
    */
   GuiControlProfile sortProfile;
   /*!
   Number of pixels that will need to be offset when drawing a column header cell's texture. First number is for left and right and second is for top and bottom.
   
    */
   Point2I headerGlowOffset;
   /*!
   Number of pixels that will need to be offset when drawing a row column's texture. First number is for left and right and second is for top and bottom.
   
    */
   Point2I rowGlowOffset;
   /*!
   Number of pixels for padding text when drawing column header cells. First number is for horizontal and second is for vertical offsets.
   
    */
   Point2I headerTextPadding;
   /*!
   Number of pixels for padding text when drawing row column cells. First number is for horizontal and second is for vertical offsets.
   
    */
   Point2I rowTextPadding;
   /*!
   Whether or not user is allowed to resize columns using the mouse cursor
   
    */
   bool allowColumnResize;
   /*!
   Whether or not user is allowed to move columns via drag and drop
   
    */
   bool allowColumnMove;
   /*!
   Whether the control should use or just ignore markup language within row contents
   
    */
   bool useMarkup;
   /*!
   Whether or not to update the control size for the scroller upon content changes, ex. Add[Row|Column], etc..
   
    */
   bool resizeOnChange;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Abstract base class for controls that render 3D scenes.

GuiTSCtrl is the base class for controls that render 3D camera views in Torque.  The class itself does not implement a concrete scene rendering.  Use GuiObjectView to display invidiual shapes in the Gui and GameTSCtrl to render full scenes.

@see GameTSCtrl
@see GuiObjectView
@ingroup Gui3D
 */
class  GuiTSCtrl : public GuiContainer {
  public:
   /*! Transform 3D screen-space coordinates (x, y, depth) to world space.
This method can be, for example, used to find the world-space position relating to the current mouse cursor position.
@param screenPosition The x/y position on the screen plus the depth from the screen-plane outwards.
@return The world-space position corresponding to the given screen-space coordinates. */
   virtual string unproject(( Point3F screenPosition )) {}
   /*! Transform world-space coordinates to screen-space (x, y, depth) coordinates.
@param worldPosition The world-space position to transform to screen-space.
@return The  */
   virtual string project(( Point3F worldPosition )) {}
   /*! Get the ratio between world-space units and pixels.
@return The amount of world-space units covered by the extent of a single pixel. */
   virtual string getWorldToScreenScale(()) {}
   /*! Given the camera's current FOV, get the distance from the camera's viewpoint at which the given radius will fit in the render area.
@param radius Radius in world-space units which should fit in the view.
@return The distance from the viewpoint at which the given radius would be fully visible. */
   virtual float calculateViewDistance(( float radius )) {}

   /*! @name Camera
   @{ */
   /*! */
   /*!
   Z rotation angle of camera.
   
    */
   float cameraZRot;
   /*!
   The vertical field of view in degrees or zero to use the normal camera FOV.
   
    */
   float forceFOV;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   The share of the per-frame reflection update work this control's rendering should run.
The reflect update priorities of all visible GuiTSCtrls are added together and each control is assigned a share of the per-frame reflection update time according to its percentage of the total priority value.
   
    */
   float reflectPriority;
   /*!
   Indicates how this control should render its contents.
   
    */
   GuiTSRenderStyles renderStyle;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  GuiPlayerView : public GuiTSCtrl {
  public:
      /*!  */
      void onAnimationDone( int threadId );

   /*! Sets the model to be displayed in this control

\param shapeName Name of the model to display.
 */
   virtual void setModel((string shapeName)) {}
   /*! Mounts the given model to the specified mount point of the primary model displayed in this control.

\param imageData datablock for the image to mount.\param slot Index of the image slot to be mounted to. Corresponds to "mountN" in your shape where N is the number passed here. */
   virtual bool mountImage((ShapeBaseImageData imageData, int slot)) {}
   virtual bool unmountImage((int slot)) {}
   virtual int mountEquipment((const char* partShape, const char* nodeName)) {}
   virtual bool unmountEquipment((const char* nodeName)) {}
   /*! Return the number of equipment meshes currently mounted. */
   virtual int getNumMounts(()) {}
   /*! Get the name of the nount node name for the equipment item. */
   virtual string getMountSlotName((int index)) {}
   /*! Get the name of the shape for the equipment item. */
   virtual string getMountShapeName((int index)) {}
   /*! Set the force hidden state for all meshes in the model */
   virtual void hideAllMeshes((bool forceHidden)) {}
   /*! Set the force hidden state for the named mesh */
   virtual void hideMesh((const char* meshName, bool forceHidden)) {}
   /*! Return the number of meshes in the current model */
   virtual int GetNumMeshes(()) {}
   /*! Get the name and visibility of the mesh at the submitted index */
   virtual string GetMeshVisibility((int index)) {}
   /*! Show the base_n_ mesh only */
   virtual void ShowModelSkin(()) {}
   /*! Sync the mesh visibility states */
   virtual void UpdateMeshStates(()) {}
   /*! Assign mat to a skin on the base model */
   virtual void SetModelSkin((const char *skinTag, Material *mat)) {}
   /*! Assign mat to a skin on an image mounted in imageSlot */
   virtual void SetImageSkin((int imageSlot, const char *skinTag, Material *mat, int mountNode)) {}
   /*! Assign mat to a skin on a piece of mounted equipment */
   virtual void SetEquipmentSkin((const char *skinTag, Material *mat, int mountIdx)) {}
   /*! Start the named animation sequence\param threadID ID of the thread to assign. 0 - Action Thread, 1 - Look Thread, 2 - Blend Thread.\param seqName Name of the sequence to run.\param startPos Starting position for the animation (0 - 1).\param timeScale Time scale for playback. */
   virtual bool SetThread((int threadID, const char *seqName, F32 startPos, F32 timeScale)) {}
   /*! Pause the animation playing in threadID */
   virtual float pauseThread((int threadID)) {}
   /*! Stop the animation playing in threadID */
   virtual void stopThread((int threadID)) {}
   /*! Pause the animation playing in threadID */
   virtual float GetThreadTime((int threadID)) {}
   /*! Return the number of sequences in the current model */
   virtual int GetNumSequences(()) {}
   /*! Get the name of the sequence at the submitted index */
   virtual string getSequenceName((int index)) {}
   /*! Return the number of mount nodes in the current model */
   virtual int GetNumNodes(()) {}
   /*! Get the name of the mount node at the submitted index */
   virtual string getNodeName((int index)) {}
   /*! Return the number of levels of detail in the current model */
   virtual int GetNumDetails(()) {}
   /*! Set the detail level in the current model */
   virtual void SetCurrentDetail((S32 detailLevel)) {}
   /*! Returns the size for the selected detail level in the current model */
   virtual float GetDetailSize((S32 detailLevel)) {}
   /*! Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

\param distance The distance to set the orbit to (will be clamped). */
   virtual void setOrbitDistance((float distance)) {}
   /*! Prints list of visible and hidden meshes to the console for debugging purposes. */
   virtual void dumpMeshVisibility() {}
   /*! Return the number of materials used on the shape or mounted mesh. */
   virtual int getNumMaterials((int mountIndex = -1)) {}
   /*! Get the name of the texture used on the shape or mounted mesh. */
   virtual string getTextureName((int texIndex, int mountIndex = -1)) {}
   /*! Get the name of the material used on the shape or mounted mesh. */
   virtual string getMaterialName((int texIndex, int mountIndex = -1)) {}
   /*! @brief Set the light direction from which to light the model.

@param lightIndex The light to set direction for (0 - 3).
@param direction XYZ direction from which the light will shine on the model
@tsexample
// Set the light direction
%direction = "1.0 0.2 0.4"

// Inform the GuiPlayerView object to change the light direction to the defined value
%thisGuiObjectView.setLightDirection(0, %direction);
@endtsexample

@see GuiControl */
   virtual void setLightDir(( int lightIndex, Point3F direction )) {}
   /*! @brief Set the light color used to render the model.

@param lightIndex The light to set color for (0 - 3).
@param color Color of light.
@tsexample
// Set the color value for the light
%color = "1.0 0.4 0.5";

// Inform the GuiPlayerView object to change the light color to the defined value
%thisGuiObjectView.setLightColor(0, %color);
@endtsexample

@see GuiControl */
   virtual void setLightColor(( int lightIndex, ColorF color )) {}
   /*! @brief Set the light brightness used to render the model.

@param lightIndex The light to set brightness for (0 - 3).
@param brightness Brightness of light.
@tsexample
// Set the brightness value for the light
%brightness = "0.5";

// Inform the GuiPlayerView object to change the light brightness to the defined value
%thisGuiObjectView.setLightBrightness(0, %brightness);
@endtsexample

@see GuiControl */
   virtual void setLightBrightness(( int lightIndex, float brightness )) {}
   /*! @brief Turns on and off individual lights.

@param lightIndex The light to turn on or off (0 - 3).
@param isLightOn on/off state for the light.
@tsexample
// Turns on the second light
%thisGuiObjectView.setLightOn(1, true);
@endtsexample

@see GuiControl */
   virtual void setLightOn(( int lightIndex, bool isLightOn )) {}
   /*! @brief Rotates the model.

@see GuiControl */
   virtual void rotateModel(( float amount )) {}
   /*! @brief Zoom in or out.

@see GuiControl */
   virtual void zoom(( float amount )) {}
   /*! @brief sets camera rotation.

@see GuiControl */
   virtual void setCameraRot(( Point3F rotVal )) {}
   /*! @brief sets camera rotation.

@see GuiControl */
   virtual void setModelRot(( Point3F rotVal )) {}
   /*! @brief Clears the ground speed measurment values.

@see GuiControl */
   virtual void resetGSValues(()) {}
   /*! @brief Sets the node to use for measuring ground travel distances.

@see GuiControl */
   virtual void setGSMeasurementNode(( string nodeName )) {}
   /*! @brief Get the duration in seconds for the current action thread.

@see GuiControl */
   virtual float getActionDurration(()) {}

   /*! @name Camera
   @{ */
   /*! */
   /*!
   Distance from which to render the model.
   
    */
   float orbitDistance;
   /*!
   Minimum distance below which the camera will not zoom in further.
   
    */
   float minOrbitDistance;
   /*!
   Maxiumum distance to which the camera can be zoomed out.
   
    */
   float maxOrbitDistance;
   /*!
   Allow mouse input to move camera/model.
   
    */
   bool useMouseControl;
   /*!
   Slide the camera pos from center to eye node when zooming in.
   
    */
   bool useSlidingZ;
   /// @}


   /*! @name GS Measurement
   @{ */
   /*! */
   /*!
   Measured X Maximum.
   
    */
   float XMax;
   /*!
   Measured X Minimum.
   
    */
   float XMin;
   /*!
   Measured Y Maximum.
   
    */
   float YMax;
   /*!
   Measured Y Minimum.
   
    */
   float YMin;
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Renders a bitmap border control that can be moved/resized by dragging.

@ingroup GuiImages
 */
class  GuiResizableBdrCtrl : public GuiControl {
  public:
      /*! Called when the control has been resized with the mouse.

@param @newSize new extent for the control */
      void onSizeChanged( Point2I newSize );

      /*! Called when the control has been resized with the mouse.

@param @newPosition new position for the control */
      void onPositionChanged( Point2I newPosition );


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Whether the control can be resized horizontally.
   
    */
   bool resizeWidth;
   /*!
   Whether the control can be resized vertically.
   
    */
   bool resizeHeight;
   /*!
   Whether the control can be moved by dragging.
   
    */
   bool canMove;
   /*!
   The maximum width and height of the control. The control will not be resized larger than this.
   
    */
   Point2I maxExtent;
   /*!
   Time for mouse to hover over control until tooltip is shown (in milliseconds).
   
    */
   int grabSize;
   /*!
   Time for mouse to hover over control until tooltip is shown (in milliseconds).
   
    */
   int dragHeight;
   /*!
   Whether the control can be moved by dragging.
   
    */
   bool forceSquare;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that acts as first responder for a 3D web shape.

@ingroup GuiOther
 */
class  GuiWebResponderCtrl : public GuiControl {
  public:
   /*! @brief Sets a web shape as the current input target. Must provide the object and end points for the ray that was used to identify it.
@param webObj  Object (AwShape or TLShape) to give input focus too.
@param rayStart  Start point of the ray in world space.
@param rayEnd  End point of the ray in world space.
@param isDown  (Optional) Is the left mouse button down. Default false
@return true if successful, false if failed (objB is not valid or the ray did notintersect an active web material face.) */
   virtual bool setInputTarget(( SceneObject webObj, Point3F rayStart, Point3F rayEnd, bool isDown=false )) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines particle emission properties such as ejection angle, period and velocity for a ParticleEmitter.

@tsexample
datablock ParticleEmitterData( GrenadeExpDustEmitter )
{
   ejectionPeriodMS = 1;
   periodVarianceMS = 0;
   ejectionVelocity = 15;
   velocityVariance = 0.0;
   ejectionOffset = 0.0;
   thetaMin = 85;
   thetaMax = 85;
   phiReferenceVel = 0;
   phiVariance = 360;
   overrideAdvance = false;
   lifetimeMS = 200;
   particles = "GrenadeExpDust";
};
@endtsexample

@ingroup FX
@see ParticleEmitter
@see ParticleData
@see ParticleEmitterNode
 */
class  SpriteEmitterData : public SphereEmitterData {
  public:
   /*! Reloads the ParticleData datablocks and other fields used by this emitter.
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue( %propertyField, %value );

// Reload this emitter
%emitter.reload();
@endtsexample
 */
   virtual void reload(()) {}

   /*! @name SpriteEmitterData
   @{ */
   /*! */
   /*!
   Variance from the reference angle, from 0 - 360.
   
    */
   float sequential;
   /// @}


   /*! @name SphereEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleEmitterData
   @{ */
   /*! */
   /// @}


   /*! @name ParticleBehaviours
   @{ */
   /*! */
   /// @}


   /*! @name LevelOfDetail
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Contains information for how specific particles should look and react including particle colors, particle imagemap, acceleration value for individual particles and spin information.
@ingroup FX
@see ParticleEmitter
@see ParticleEmitterData
@see ParticleEmitterNode
 */
class  SpriteParticleData : public SimDataBlock {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
   /*!
   Speed at which to spin the particle.
   
    */
   float spinSpeed;
   /*!
   Minimum allowed spin speed of this particle, between -1000 and spinRandomMax.
   
    */
   float spinRandomMin;
   /*!
   Maximum allowed spin speed of this particle, between spinRandomMin and 1000.
   
    */
   float spinRandomMax;
   /*!
   @brief Controls how particles blend with the scene.

If true, particles blend like ParticleBlendStyle NORMAL, if false, blend like ParticleBlendStyle ADDITIVE.
@note If ParticleEmitterData::blendStyle is set, it will override this value.
   
    */
   bool useInvAlpha;
   /*!
   @brief Texture file to use for this particle.
   
    */
   string HighResTexture;
   /*!
   @brief Texture file to use for this particle.

Deprecated. use HighResTexture instead.
   
    */
   string textureName;
   /*!
   @brief Particle RGBA color keyframe values.

The particle color will linearly interpolate between the color/time keys over the lifetime of the particle.
   
    */
   ColorF colors;
   /*!
   @brief Time keys used with the colors and sizes keyframes.

Values are from 0.0 (particle creation) to 1.0 (end of lifespace).
   
    */
   float times;
   /*!
   @brief The number of columns and rows on the spritesheet.
   
    */
   Point2I gridSize;
   /*!
   Particle physics drag amount.
   
    */
   float dragCoefficient;
   /*!
   Strength of wind on the particles.
   
    */
   float windCoefficient;
   /*!
   Strength of gravity on the particles.
   
    */
   float gravityCoefficient;
   /*!
   Amount of emitter velocity to add to particle initial velocity.
   
    */
   float inheritedVelFactor;
   /*!
   Constant acceleration to apply to this particle.
   
    */
   float constantAcceleration;
   /*!
   Time in milliseconds before this particle is destroyed.
   
    */
   int lifetimeMS;
   /*!
   Variance in lifetime of particle, from 0 - lifetimeMS.
   
    */
   int lifetimeVarianceMS;
   /*!
   @brief Particle size keyframe values.

The particle size will linearly interpolate between the size/time keys over the lifetime of the particle.
   
    */
   float sizes;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  DatabaseConnection : public SimObject {
  public:
   /*! dbc.Connect(string) */
   virtual int connect() {}
   /*! dbc.ConnectDriver(driver, optionalArgs) */
   virtual int ConnectDriver() {}
   /*! dbc.ConnectDSN(dsn, optionalArgs) */
   virtual int ConnectDSN() {}
   /*! dbc.Disconnect() */
   virtual void disconnect() {}
   /*! dbc.Execute(sqlStatement) */
   virtual int Execute() {}
   /*! dbc.Prepare(sqlStatement,numParams) */
   virtual int Prepare() {}
   /*! dbc.ExecutePrepared(sqlPreparedID,param1,param2,...) */
   virtual int ExecutePrepared() {}
   /*! dbc.FreePrepared(sqlPreparedID) */
   virtual void FreePrepared() {}
};

class  DatabasePrepared : public SimObject {
  public:
   /*! dbp.getSql() - SQL Statement. */
   virtual string getSql() {}
   /*! dbp.getNumParams() - # of params in SQL statement. */
   virtual int getNumParams() {}
};

class  DatabaseResult : public SimObject {
  public:
   /*! dbr.Value(columnName) - returns value of current row at columnName. Equivalent to obj.columnName. Spaces are replaced by _'s in columnName */
   virtual string value() {}
   /*! dbr.ValueIndex(index) - returns the index'th value in the current row */
   virtual string ValueIndex() {}
   /*! dbr.ColName(index) - returns the index'th column name */
   virtual string ColName() {}
   /*! dbr.ColType(index) - returns the index'th column type (string, int, float, bool, unknown) */
   virtual string ColType() {}
   /*! dbr.NextRow() - advances the current row to the next row. Returns 1 for success */
   virtual int NextRow() {}
   /*! dbr.FirstRow() - moves current row to the first row. Returns 1 for success */
   virtual int FirstRow() {}
   /*! dbr.LastRow() - moves current row to the last row. Returns 1 for success */
   virtual int LastRow() {}
   /*! dbr.RowIndex(index) - moves current row to the index'th row. Returns 1 for success */
   virtual int RowIndex() {}
   /*! dbr.Commit() - commits any changes to the database */
   virtual int Commit() {}
   /*! dbr.Clear() - clears the result set */
   virtual int clear() {}
   /*! dbr.NumRows() - returns number of rows in the result set */
   virtual int NumRows() {}
   /*! dbr.getNumRows() - Number of rows in result. */
   virtual int getNumRows() {}
};

/*!
@brief Data structure for storing indexed sequences of key/value pairs.

This is a powerful array class providing PHP style arrays in TorqueScript.

The following features are supported:<ul>
<li>array pointers: this allows you to move forwards or backwards through the array as if it was a list, including jumping to the start or end.</li>
<li>sorting: the array can be sorted in either alphabetic or numeric mode, on the key or the value, and in ascending or descending order</li>
<li>add/remove elements: elements can be pushed/popped from the start or end of the array, or can be inserted/erased from anywhere in the middle</li>
<li>removal of duplicates: remove duplicate keys or duplicate values</li>
<li>searching: search the array and return the index of a particular key or value</li>
<li>counting: count the number of instaces of a particular value or key in the array, as well as the total number of elements</li>
<li>advanced features: array append, array crop and array duplicate</li>
</ul>

Array element keys and values can be strings or numbers

 */
class  InventoryObject : public SimObject {
  public:
   /*! Search the array from the current position for the element @param value Array value to search for
@return Index of the first element found, or -1 if none
 */
   virtual int getIndexFromValue(( string value )) {}
   /*! Search the array from the current position for the key @param value Array key to search for
@return Index of the first element found, or -1 if none
 */
   virtual int getIndexFromKey(( string key )) {}
   /*! Get the touched flag for the array element at the submitted index.
@param index 0-based index of the array element to get
@return The touched flag for the array element at the specified index, or false if the index is out of range
 */
   virtual bool isTouched(( int index )) {}
   /*! Clear the touched flag for all elements in inventory.
 */
   virtual void markAllUntouched(()) {}
   /*! Get the value of the array element at the submitted index.
@param index 0-based index of the array element to get
@return The value of the array element at the specified index, or "" if the index is out of range
 */
   virtual string getValue(( int index )) {}
   /*! Get the key of the array element at the submitted index.
@param index 0-based index of the array element to get
@return The key associated with the array element at the specified index, or "" if the index is out of range
 */
   virtual string getKey(( int index )) {}
   /*! Set the key at the given index.
@param key New key value
@param index 0-based index of the array element to update
 */
   virtual void setKey(( string key, int index )) {}
   /*! Set the value at the given index.
@param value New array element value
@param index 0-based index of the array element to update
 */
   virtual void setValue(( string value, int index )) {}
   /*! Get the number of elements in the array. */
   virtual int count(()) {}
   /*! Get the number of times a particular value is found in the array.
@param value Array element value to count
 */
   virtual int countValue(( string value )) {}
   /*! Get the number of times a particular key is found in the array.
@param key Key value to count
 */
   virtual int countKey(( string key )) {}
   /*! Adds a new element to the end of an array (same as push_back()).
@param key Key for the new element
@param value Value for the new element
 */
   virtual void add(( string key, string value="" )) {}
   /*! Adds a new element to the end of an array.
@param key Key for the new element
@param value Value for the new element
 */
   virtual void push_back(( string key, string value="" )) {}
   /*! Adds a new element to the front of an array */
   virtual void push_front(( string key, string value="" )) {}
   /*! Adds a new element to a specified position in the array.
- @a index = 0 will insert an element at the start of the array (same as push_front())
- @a index = %array.count() will insert an element at the end of the array (same as push_back())

@param key Key for the new element
@param value Value for the new element
@param index 0-based index at which to insert the new element */
   virtual void insert(( string key, string value, int index )) {}
   /*! Removes the last element from the array */
   virtual void pop_back(()) {}
   /*! Removes the first element from the array */
   virtual void pop_front(()) {}
   /*! Removes an element at a specific position from the array.
@param index 0-based index of the element to remove
 */
   virtual void erase(( int index )) {}
   /*! Emptys all elements from an array */
   virtual void empty(()) {}
   /*! Removes any elements that have duplicated values (leaving the first instance) */
   virtual void uniqueValue(()) {}
   /*! Removes any elements that have duplicated keys (leaving the first instance) */
   virtual void uniqueKey(()) {}
   /*! Alters array into an exact duplicate of the target array.
@param target InventoryObject to duplicate
 */
   virtual bool duplicate(( InventoryObject target )) {}
   /*! Removes elements with matching keys from array.
@param target InventoryObject containing keys to remove from this array
 */
   virtual bool crop(( InventoryObject target )) {}
   /*! Appends the target array to the array object.
@param target InventoryObject to append to the end of this array
 */
   virtual bool append(( InventoryObject target )) {}
   /*! Alpha sorts the array by value

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sort(( bool ascending=false )) {}
   /*! Alpha sorts the array by value in ascending order */
   virtual void sorta(()) {}
   /*! Alpha sorts the array by value in descending order */
   virtual void sortd(()) {}
   /*! Alpha sorts the array by key

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortk(( bool ascending=false )) {}
   /*! Alpha sorts the array by key in ascending order */
   virtual void sortka(()) {}
   /*! Alpha sorts the array by key in descending order */
   virtual void sortkd(()) {}
   /*! Numerically sorts the array by value

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortn(( bool ascending=false )) {}
   /*! Numerically sorts the array by value in ascending order */
   virtual void sortna(()) {}
   /*! Numerically sorts the array by value in descending order */
   virtual void sortnd(()) {}
   /*! Numerically sorts the array by key

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortnk(( bool ascending=false )) {}
   /*! Numerical sorts the array by key in ascending order */
   virtual void sortnka(()) {}
   /*! Numerical sorts the array by key in descending order */
   virtual void sortnkd(()) {}
   /*! Sorts the array by value in ascending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.

@tsexample
function mySortCallback(%a, %b)
{
   return strcmp( %a.name, %b.name );
}

%array.sortf( "mySortCallback" );
@endtsexample
 */
   virtual void sortf(( string functionName )) {}
   /*! Sorts the array by key in ascending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfk(( string functionName )) {}
   /*! Sorts the array by value in descending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfd(( string functionName )) {}
   /*! Sorts the array by key in descending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfkd(( string functionName )) {}
   /*! Moves array pointer to start of array

@return Returns the new array pointer */
   virtual int moveFirst(()) {}
   /*! Moves array pointer to end of array

@return Returns the new array pointer */
   virtual int moveLast(()) {}
   /*! Moves array pointer to next position

@return Returns the new array pointer, or -1 if already at the end */
   virtual int moveNext(()) {}
   /*! Moves array pointer to prev position

@return Returns the new array pointer, or -1 if already at the start */
   virtual int movePrev(()) {}
   /*! Gets the current pointer index */
   virtual int getCurrent(()) {}
   /*! Sets the current pointer index.
@param index New 0-based pointer index
 */
   virtual void setCurrent(( int index )) {}
   /*! Echos the array contents to the console */
   virtual void echo(()) {}
   /*!
   Makes the keys and values case-sensitive.
By default, comparison of key and value strings will be case-insensitive.
   
    */
   bool caseSensitive;
   /*!
   Helper field which allows you to add new key['keyname'] = value pairs.
   
    */
   caseString key;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@ingroup gameObjects
 */
class  Player : public ShapeBase {
  public:
   virtual void applySlow(( float amount )) {}
   virtual void removeSlow(( float amount )) {}
   virtual void applyHaste(( float amount )) {}
   virtual void removeHaste(( float amount )) {}
   /*! @brief Get the name of the player's current pose.

The pose is one of the following:

<ul><li>Stand - Standard movement pose.</li><li>Sprint - Sprinting pose.</li><li>Crouch - Crouch pose.</li><li>Prone - Prone pose.</li><li>Swim - Swimming pose.</li></ul>
@return The current pose; one of: "Stand", "Sprint", "Crouch", "Prone", "Swim"
 */
   virtual string getPose(()) {}
   /*! @brief Allow all poses a chance to occur.

This method resets any poses that have manually been blocked from occuring.  This includes the regular pose states such as sprinting, crouch, being prone and swimming.  It also includes being able to jump and jet jump.  While this is allowing these poses to occur it doesn't mean that they all can due to other conditions.  We're just not manually blocking them from being allowed.
@see allowJumping()
@see allowJetJumping()
@see allowSprinting()
@see allowCrouching()
@see allowProne()
@see allowSwimming()
 */
   virtual void allowAllPoses(()) {}
   /*! @brief Set if the Player is allowed to jump.

The default is to allow jumping unless there are other environmental concerns that prevent it.  This method is mainly used to explicitly disallow jumping at any time.
@param state Set to true to allow jumping, false to disable it.
@see allowAllPoses()
 */
   virtual void allowJumping(( bool state )) {}
   /*! @brief Set if the Player is allowed to sprint.

The default is to allow sprinting unless there are other environmental concerns that prevent it.  This method is mainly used to explicitly disallow sprinting at any time.
@param state Set to true to allow sprinting, false to disable it.
@see allowAllPoses()
 */
   virtual void allowSprinting(( bool state )) {}
   /*! @brief Set if the Player is allowed to crouch.

The default is to allow crouching unless there are other environmental concerns that prevent it.  This method is mainly used to explicitly disallow crouching at any time.
@param state Set to true to allow crouching, false to disable it.
@see allowAllPoses()
 */
   virtual void allowCrouching(( bool state )) {}
   /*! @brief Set if the Player is allowed to go prone.

The default is to allow being prone unless there are other environmental concerns that prevent it.  This method is mainly used to explicitly disallow going prone at any time.
@param state Set to true to allow being prone, false to disable it.
@see allowAllPoses()
 */
   virtual void allowProne(( bool state )) {}
   /*! @brief Set if the Player is allowed to swim.

The default is to allow swimming unless there are other environmental concerns that prevent it.  This method is mainly used to explicitly disallow swimming at any time.
@param state Set to true to allow swimming, false to disable it.
@see allowAllPoses()
 */
   virtual void allowSwimming(( bool state )) {}
   /*! @brief Get the name of the player's current state.

The state is one of the following:

<ul><li>Dead - The Player is dead.</li><li>Mounted - The Player is mounted to an object such as a vehicle.</li><li>Move - The Player is free to move.  The usual state.</li><li>Recover - The Player is recovering from a fall.  See PlayerData::recoverDelay.</li></ul>
@return The current state; one of: "Dead", "Mounted", "Move", "Recover"
 */
   virtual string getState(()) {}
   /*! @brief Get the named damage location and modifier for a given world position.

the Player object can simulate different hit locations based on a pre-defined set of PlayerData defined percentages.  These hit percentages divide up the Player's bounding box into different regions.  The diagram below demonstrates how the various PlayerData properties split up the bounding volume:

<img src="images/player_damageloc.png">

While you may pass in any world position and getDamageLocation() will provide a best-fit location, you should be aware that this can produce some interesting results.  For example, any position that is above PlayerData::boxHeadPercentage will be considered a 'head' hit, even if the world position is high in the sky.  Therefore it may be wise to keep the passed in point to somewhere on the surface of, or within, the Player's bounding volume.

@note This method will not return an accurate location when the player is prone or swimming.

@param pos A world position for which to retrieve a body region on this player.
@return a string containing two words (space separated strings), where the first is a location and the second is a modifier.

Posible locations:<ul><li>head</li><li>torso</li><li>legs</li></ul>
Head modifiers:<ul><li>left_back</li><li>middle_back</li><li>right_back</li><li>left_middle</li><li>middle_middle</li><li>right_middle</li><li>left_front</li><li>middle_front</li><li>right_front</li></ul>
Legs/Torso modifiers:<ul><li>front_left</li><li>front_right</li><li>back_left</li><li>back_right</li></ul>
@see PlayerData::boxHeadPercentage
@see PlayerData::boxHeadFrontPercentage
@see PlayerData::boxHeadBackPercentage
@see PlayerData::boxHeadLeftPercentage
@see PlayerData::boxHeadRightPercentage
@see PlayerData::boxTorsoPercentage
 */
   virtual string getDamageLocation(( Point3F pos )) {}
   /*! @brief Set the sequence that controls the player's arms (dynamically adjusted to match look direction).

@param name Name of the sequence to play on the player's arms.
@return true if successful, false if failed.
@note By default the 'look' sequence is used, if available.
 */
   virtual bool setArmThread(( string name )) {}
   /*! @brief Set the main action sequence to play for this player.

@param name Name of the action sequence to set
@param hold Set to false to get a callback on the datablock when the sequence ends (PlayerData::animationDone()).  When set to true no callback is made.
@param fsp True if first person and none of the spine nodes in the shape should animate.  False will allow the shape's spine nodes to animate.
@return True if succesful, false if failed
@note The spine nodes for the Player's shape are named as follows:

<ul><li>Bip01 Pelvis</li><li>Bip01 Spine</li><li>Bip01 Spine1</li><li>Bip01 Spine2</li><li>Bip01 Neck</li><li>Bip01 Head</li></ul>

You cannot use setActionThread() to have the Player play one of the motion determined action animation sequences.  These sequences are chosen based on how the Player moves and the Player's current pose.  The names of these sequences are:

<ul><li>root</li><li>run</li><li>side</li><li>side_right</li><li>crouch_root</li><li>crouch_forward</li><li>crouch_backward</li><li>crouch_side</li><li>crouch_right</li><li>prone_root</li><li>prone_forward</li><li>prone_backward</li><li>swim_root</li><li>swim_forward</li><li>swim_backward</li><li>swim_left</li><li>swim_right</li><li>fall</li><li>jump</li><li>standjump</li><li>land</li><li>jet</li></ul>

If the player moves in any direction then the animation sequence set using this method will be cancelled and the chosen mation-based sequence will take over.  This makes great for times when the Player cannot move, such as when mounted, or when it doesn't matter if the action sequence changes, such as waving and saluting.
@tsexample
// Place the player in a sitting position after being mounted
%player.setActionThread( "sitting", true, true );
@endtsexample
 */
   virtual bool setActionThread(( string name, bool hold=false, bool fsp=true )) {}
   /*! @brief Set the object to be controlled by this player

It is possible to have the moves sent to the Player object from the GameConnection to be passed along to another object.  This happens, for example when a player is mounted to a vehicle.  The move commands pass through the Player and on to the vehicle (while the player remains stationary within the vehicle).  With setControlObject() you can have the Player pass along its moves to any object.  One possible use is for a player to move a remote controlled vehicle.  In this case the player does not mount the vehicle directly, but still wants to be able to control it.
@param obj Object to control with this player
@return True if the object is valid, false if not
@see getControlObject()
@see clearControlObject()
@see GameConnection::setControlObject() */
   virtual bool setControlObject(( ShapeBase obj )) {}
   /*! @brief Get the current object we are controlling.

@return ID of the ShapeBase object we control, or 0 if not controlling an object.
@see setControlObject()
@see clearControlObject() */
   virtual int getControlObject(()) {}
   /*! @brief Clears the player's current control object.

Returns control to the player. This internally calls Player::setControlObject(0).
@tsexample
%player.clearControlObject();
echo(%player.getControlObject()); //<-- Returns 0, player assumes control
%player.setControlObject(%vehicle);
echo(%player.getControlObject()); //<-- Returns %vehicle, player controls the vehicle now.
@endtsexample
@note If the player does not have a control object, the player will receive all moves from its GameConnection.  If you're looking to remove control from the player itself (i.e. stop sending moves to the player) use GameConnection::setControlObject() to transfer control to another object, such as a camera.
@see setControlObject()
@see getControlObject()
@see GameConnection::setControlObject()
 */
   virtual void clearControlObject(()) {}
   /*! @brief Check if it is safe to dismount at this position.

Internally this method casts a ray from oldPos to pos to determine if it hits the terrain, an interior object, a water object, another player, a static shape, a vehicle (exluding the one currently mounted), or physical zone.  If this ray is in the clear, then the player's bounding box is also checked for a collision at the pos position.  If this displaced bounding box is also in the clear, then checkDismountPoint() returns true.
@param oldPos The player's current position
@param pos The dismount position to check
@return True if the dismount position is clear, false if not
@note The player must be already mounted for this method to not assert.
 */
   virtual bool checkDismountPoint(( Point3F oldPos, Point3F pos )) {}
   /*! @brief Get the number of death animations available to this player.

Death animations are assumed to be named death1-N using consecutive indices. */
   virtual int getNumDeathAnimations(()) {}
   /*! @brief Check if it is safe to spawn a fish thief at this position.

@param oldPos The player's current position
@param pos The spawn position to check
@return True if the spawn position is clear, false if not
 */
   virtual bool checkThiefSpawn(( Point3F oldPos, Point3F pos )) {}
   virtual bool setArmThreadPlayOnce((string sequenceName, F32 timeScale = 1.0, F32 startDamage = 0.0, F32 endDamage = 0.0)) {}
   virtual bool inArmThreadPlayOnce(()) {}
   virtual void stopPlayOnce() {}
   virtual bool SetArmThreadTransitionOnce((string sequenceName, F32 timeScale = 1.0)) {}
   /*! getActionAnim() */
   virtual string getActionAnimName() {}
   /*! @brief Removes any arm thread set on the player.

@return true if successful, false if failed.
 */
   virtual bool clearArmThread(()) {}
   /*! @brief Sets an attack animation in the action animation (whole body) slot on the player.

@param name Name of the animation sequence to play.
@param timeScale Animation thread speed (Default 1.0).
@param startDamage Time to begin melee damage in seconds (Default 0.0).
@param endDamage Time to end melee damage in seconds (Default 0.0 no damage).
@return true if successful, false if failed.
 */
   virtual bool setAttackThread(( string name, float timeScale=1.0, float startDamage=0.0, float endDamage=0.0 )) {}
   /*! @brief Sets a blended attack animation on the player.

@param slot Thread slot to play the animation in (0 - 3).
@param name Name of the animation sequence to play.
@param timeScale Animation thread speed (Default 1.0).
@param startDamage Time to begin melee damage in seconds (Default 0.0).
@param endDamage Time to end melee damage in seconds (Default 0.0 no damage).
@return true if successful, false if failed.
 */
   virtual bool setAttackBlend(( int slot, string name, float timeScale=1.0, float startDamage=0.0, float endDamage=0.0 )) {}
   /*! @brief Sets a point and teather distance so we get a callback if the player moves
beyond the set distance.

 */
   virtual void SetTeatherPos(( Point3F teatherPoint, float teatherDistance )) {}
   /*! @brief Clears any teather placed on the player.
 */
   virtual void BreakTeather(()) {}
   /*! @brief Return true if the player is aiming at a web shape that is in range to focus.
 */
   virtual bool testWebShapeHit(()) {}
   /*! @brief Return true if the player is moving.
 */
   virtual bool isMoving(()) {}
   /*! @brief Get the Aim direction for the player.

This will return the players aim with the current head yaw and pich factored in.
 */
   virtual string getAimVector(()) {}
   /*! @brief Sets the head look angles on our mount to match ours.
 */
   virtual void setMountHeadAngles(()) {}
   /*! @brief Return true if the player is swimming.
 */
   virtual bool isSwimming(()) {}
   /*! @brief Set the sequence that controls the player's head thread. This thread is automatically adjusted to match the vertical look direction (pitch).

@param name Name of the sequence to use for pitch.
@param maxPitch The maximum vertical rotation in radians.
@return true if successful, false if failed.
@note By default the 'head' sequence is used, if available.
 */
   virtual bool setHeadVThread(( string name, float maxPitch=1.0f )) {}
   /*! @brief Set the sequence that controls the player's head thread. This thread is automatically adjusted to match the horizontal look direction (yaw).

@param name Name of the sequence to use for yaw.
@param maxYaw The maximum horizontal rotation in radians.
@return true if successful, false if failed.
@note By default the 'headside' sequence is used, if available.
 */
   virtual bool setHeadHThread(( string name, float maxYaw=0.5f )) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A Player object not controlled by conventional input, but by an AI engine.

The AIPlayer provides a Player object that may be controlled from script.  You control where the player moves and how fast.  You may also set where the AIPlayer is aiming at -- either a location or another game object.

The AIPlayer class does not have a datablock of its own.  It makes use of the PlayerData datablock to define how it looks, etc.  As the AIPlayer is an extension of the Player class it can mount objects and fire weapons, or mount vehicles and drive them.

While the PlayerData datablock is used, there are a number of additional callbacks that are implemented by AIPlayer on the datablock.  These are listed here:

void onReachDestination(AIPlayer obj) 
Called when the player has reached its set destination using the setMoveDestination() method.  The actual point at which this callback is called is when the AIPlayer is within the mMoveTolerance of the defined destination.

void onMoveStuck(AIPlayer obj) 
While in motion, if an AIPlayer has moved less than moveStuckTolerance within a single tick, this callback is called.  From here you could choose an alternate destination to get the AIPlayer moving again.

void onTargetEnterLOS(AIPlayer obj) 
When an object is being aimed at (following a call to setAimObject()) and the targeted object enters the AIPlayer's line of sight, this callback is called.  The LOS test is a ray from the AIPlayer's eye position to the center of the target's bounding box.  The LOS ray test only checks against interiors, statis shapes, and terrain.

void onTargetExitLOS(AIPlayer obj) 
When an object is being aimed at (following a call to setAimObject()) and the targeted object leaves the AIPlayer's line of sight, this callback is called.  The LOS test is a ray from the AIPlayer's eye position to the center of the target's bounding box.  The LOS ray test only checks against interiors, statis shapes, and terrain.

@tsexample
// Create the demo player object
%player = new AiPlayer()
{
^dataBlock = DemoPlayer;
^path = "";
};
@endtsexample

@see Player for a list of all inherited functions, variables, and base description
@ingroup AI
@ingroup gameObjects
 */
class  AIPlayer : public Player {
  public:
      /*! @brief Called when an AI changes run mode.

@param newRunMode The run pose entered, 0, 1, 2 or 3 (root, slow, medium, fast)
 */
      void onRunPoseChange( int newRunMode );

   /*! @brief Tells the AIPlayer to stop moving.

 */
   virtual void stop(()) {}
   /*! @brief Use this to stop aiming at an object or a point.

@see setAimLocation()
@see setAimObject()
 */
   virtual void clearAim(()) {}
   /*! @brief Sets the move speed for an AI object.

@param speed A speed multiplier between 0.0 and 1.0.  This is multiplied by the AIPlayer's base movement rates (as defined in its PlayerData datablock)

@see getMoveDestination()
 */
   virtual void setMoveSpeed(( float speed )) {}
   /*! @brief Gets the move speed of an AI object.

@return A speed multiplier between 0.0 and 1.0.

@see setMoveSpeed()
 */
   virtual float getMoveSpeed(()) {}
   /*! @brief Sets the move tolerance for an AI object.

@param speed A tolerange range. This is the range the AIplayer will be from its destination before it fires a onDestinationReached.

 */
   virtual void setMoveTolerance(( float tolerance )) {}
   /*! @brief Tells the AI to move to the location provided

@param goal Coordinates in world space representing location to move to.
@param slowDown A boolean value. If set to true, the bot will slow down when it gets within 5-meters of its move destination. If false, the bot will stop abruptly when it reaches the move destination. By default, this is true.

@note Upon reaching a move destination, the bot will clear its move destination and calls to getMoveDestination will return "0 0 0".@see getMoveDestination()
 */
   virtual void setMoveDestination(( Point3F goal, bool slowDown=true )) {}
   /*! @brief Get the AIPlayer's current destination.

@return Returns a point containing the "x y z" position of the AIPlayer's current move destination. If no move destination has yet been set, this returns "0 0 0".@see setMoveDestination()
 */
   virtual string getMoveDestination(()) {}
   /*! @brief Tells the AIPlayer to aim at the location provided.

@param target An "x y z" position in the game world to target.

@see getAimLocation()
 */
   virtual void setAimLocation(( Point3F target )) {}
   /*! @brief Returns the point the AIPlayer is aiming at.

This will reflect the position set by setAimLocation(), or the position of the object that the bot is now aiming at.  If the bot is not aiming at anything, this value will change to whatever point the bot's current line-of-sight intercepts.@return World space coordinates of the object AI is aiming at. Formatted as "X Y Z".

@see setAimLocation()
@see setAimObject()
 */
   virtual string getAimLocation(()) {}
   /*! Sets the bot's target object. Optionally set an offset from target location.@hide */
   virtual void setAimObject(( GameBase obj, [Point3F offset] )) {}
   /*! @brief Gets the object the AIPlayer is targeting.

@return Returns -1 if no object is being aimed at, or the SimObjectID of the object the AIPlayer is aiming at.

@see setAimObject()
 */
   virtual int getAimObject(()) {}
   /*! @brief Check if it is safe spawn a horse at this position.

@param pos The position to check
@return True if the dismount position is clear, false if not
@note The player must be already mounted for this method to not assert.
 */
   virtual bool checkSpawnTrans(( TransformF txfm )) {}
   /*! @brief Sets the base move speed for a mounted AI object. This is the speed the Mount will return to every time it stops

@param speed A speed multiplier between 0.0 and 1.0.  This is multiplied by the AIPlayer's base movement rates (as defined in its PlayerData datablock)

@see getMoveDestination()
 */
   virtual void setMountBaseSpeed(( float speed )) {}

   /*! @name AI
   @{ */
   /*! */
   /*!
   @brief Distance from destination before stopping.

When the AIPlayer is moving to a given destination it will move to within this distance of the destination and then stop.  By providing this tolerance it helps the AIPlayer from never reaching its destination due to minor obstacles, rounding errors on its position calculation, etc.  By default it is set to 0.25.

   
    */
   float mMoveTolerance;
   /*!
   @brief Distance tolerance on stuck check.

When the AIPlayer is moving to a given destination, if it ever moves less than this tolerance during a single tick, the AIPlayer is considered stuck.  At this point the onMoveStuck() callback is called on the datablock.

   
    */
   float moveStuckTolerance;
   /*!
   @brief The number of ticks to wait before testing if the AIPlayer is stuck.

When the AIPlayer is asked to move, this property is the number of ticks to wait before the AIPlayer starts to check if it is stuck.  This delay allows the AIPlayer to accelerate to full speed without its initial slow start being considered as stuck.
@note Set to zero to have the stuck test start immediately.

   
    */
   int moveStuckTestDelay;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents a position, direction and field of view to render a scene from.

A camera is typically manipulated by a GameConnection.  When set as the connection's control object, the camera handles all movement actions ($mvForwardAction, $mvPitch, etc.) just like a Player.
@tsexample
// Set an already created camera as the GameConnection's control object
%connection.setControlObject(%camera);
@endtsexample

<h3>Methods of Operation</h3>

The camera has two general methods of operation.  The first is the standard mode where the camera starts and stops its motion and rotation instantly.  This is the default operation of the camera and is used by most games.  It may be specifically set with Camera::setFlyMode() for 6 DoF motion.  It is also typically the method used with Camera::setOrbitMode() or one of its helper methods to orbit about a specific object (such as the Player's dead body) or a specific point.

The second method goes under the name of Newton as it follows Newton's 2nd law of motion: F=ma.  This provides the camera with an ease-in and ease-out feel for both movement and rotation.  To activate this method for movement, either use Camera::setNewtonFlyMode() or set the Camera::newtonMode field to true.  To activate this method for rotation, set the Camera::newtonRotation to true.  This method of operation is not typically used in games, and was developed to allow for a smooth fly through of a game level while recording a demo video.  But with the right force and drag settings, it may give a more organic feel to the camera to games that use an overhead view, such as a RTS.

There is a third, minor method of operation but it is not generally used for games.  This is when the camera is used with Torque's World Editor in Edit Orbit Mode.  When set, this allows the camera to rotate about a specific point in the world, and move towards and away from this point.  See Camera::setEditOrbitMode() and Camera::setEditOrbitPoint().  While in this mode, Camera::autoFitRadius() may also be used.

@tsexample
// Create a camera in the level and set its position to a given spawn point.
// Note: The camera starts in the standard fly mode.
%cam = new Camera() {
   datablock = "Observer";
};
MissionCleanup.add( %cam );
%cam.setTransform( %spawnPoint.getTransform() );
@endtsexample

@tsexample
// Create a camera at the given spawn point for the specified
// GameConnection i.e. the client.  Uses the standard
// Sim::spawnObject() function to create the camera using the
// defined default settings.
// Note: The camera starts in the standard fly mode.
function GameConnection::spawnCamera(%this, %spawnPoint)
{
   // Set the control object to the default camera
   if (!isObject(%this.camera))
   {
      if (isDefined("$Game::DefaultCameraClass"))
         %this.camera = spawnObject($Game::DefaultCameraClass, $Game::DefaultCameraDataBlock);
   }

   // If we have a camera then set up some properties
   if (isObject(%this.camera))
   {
      // Make sure we're cleaned up when the mission ends
      MissionCleanup.add( %this.camera );

      // Make sure the camera is always in scope for the connection
      %this.camera.scopeToClient(%this);

      // Send all user input from the connection to the camera
      %this.setControlObject(%this.camera);

      if (isDefined("%spawnPoint"))
      {
         // Attempt to treat %spawnPoint as an object, such as a
         // SpawnSphere class.
         if (getWordCount(%spawnPoint) == 1 && isObject(%spawnPoint))
         {
            %this.camera.setTransform(%spawnPoint.getTransform());
         }
         else
         {
            // Treat %spawnPoint as an AngleAxis transform
            %this.camera.setTransform(%spawnPoint);
         }
      }
   }
}
@endtsexample

<h3>Motion Modes</h3>

Beyond the different operation methods, the Camera may be set to one of a number of motion modes.  These motion modes determine how the camera will respond to input and may be used to constrain how the Camera moves.  The CameraMotionMode enumeration defines the possible set of modes and the Camera's current may be obtained by using getMode().

Some of the motion modes may be set using specific script methods.  These often provide additional parameters to set up the mode in one go.  Otherwise, it is always possible to set a Camera's motion mode using the controlMode property.  Just pass in the name of the mode enum.  The following table lists the motion modes, how to set them up, and what they offer:

<table border='1' cellpadding='1'><tr><th>Mode</th><th>Set From Script</th><th>Input Move</th><th>Input Rotate</th><th>Can Use Newton Mode?</th></tr><tr><td>Stationary</td><td>controlMode property</td><td>No</td><td>No</td><td>No</td></tr><tr><td>FreeRotate</td><td>controlMode property</td><td>No</td><td>Yes</td><td>Rotate Only</td></tr><tr><td>Fly</td><td>setFlyMode()</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>OrbitObject</td><td>setOrbitMode()</td><td>Orbits object</td><td>Points to object</td><td>Move only</td></tr><tr><td>OrbitPoint</td><td>setOrbitPoint()</td><td>Orbits point</td><td>Points to location</td><td>Move only</td></tr><tr><td>TrackObject</td><td>setTrackObject()</td><td>No</td><td>Points to object</td><td>Yes</td></tr><tr><td>Overhead</td><td>controlMode property</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>EditOrbit (object selected)</td><td>setEditOrbitMode()</td><td>Orbits object</td><td>Points to object</td><td>Move only</td></tr><tr><td>EditOrbit (no object)</td><td>setEditOrbitMode()</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></table>

<h3>%Trigger Input</h3>

Passing a move trigger ($mvTriggerCount0, $mvTriggerCount1, etc.) on to a Camera performs different actions depending on which mode the camera is in.  While in Fly, Overhead or EditOrbit mode, either trigger0 or trigger1 will cause a camera to move twice its normal movement speed.  You can see this in action within the World Editor, where holding down the left mouse button while in mouse look mode (right mouse button is also down) causes the Camera to move faster.

Passing along trigger2 will put the camera into strafe mode.  While in this mode a Fly, FreeRotate or Overhead Camera will not rotate from the move input.  Instead the yaw motion will be applied to the Camera's x motion, and the pitch motion will be applied to the Camera's z motion.  You can see this in action within the World Editor where holding down the middle mouse button allows the user to move the camera up, down and side-to-side.

While the camera is operating in Newton Mode, trigger0 and trigger1 behave slightly differently.  Here trigger0 activates a multiplier to the applied acceleration force as defined by speedMultiplier.  This has the affect of making the camera move up to speed faster.  trigger1 has the opposite affect by acting as a brake.  When trigger1 is active a multiplier is added to the Camera's drag as defined by brakeMultiplier.

@see CameraData
@see CameraMotionMode
@see Camera::movementSpeed

@ingroup BaseCamera
 */
class  Camera : public ShapeBase {
  public:
   /*! Returns the current camera control mode.

@see CameraMotionMode */
   virtual string getMode(()) {}
   /*! Get the camera's position in the world.

@returns The position in the form of "x y z". */
   virtual string getPosition(()) {}
   /*! Get the camera's Euler rotation in radians.

@returns The rotation in radians in the form of "x y z". */
   virtual string getRotation(()) {}
   /*! Set the camera's Euler rotation in radians.

@param rot The rotation in radians in the form of "x y z".@note Rotation around the Y axis is ignored */
   virtual void setRotation(( Point3F rot )) {}
   /*! Get the camera's offset from its orbit or tracking point.

The offset is added to the camera's position when set to CameraMode::OrbitObject.
@returns The offset in the form of "x y z". */
   virtual string getOffset(()) {}
   /*! Set the camera's offset.

The offset is added to the camera's position when set to CameraMode::OrbitObject.
@param offset The distance to offset the camera by in the form of "x y z". */
   virtual void setOffset(( Point3F offset )) {}
   /*! Set the camera to orbit around the given object, or if none is given, around the given point.

@param orbitObject The object to orbit around.  If no object is given (0 or blank string is passed in) use the orbitPoint instead
@param orbitPoint The point to orbit around when no object is given.  In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform().
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param ownClientObj [optional] Are we orbiting an object that is owned by us?  Default is false.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@see Camera::setOrbitObject()
@see Camera::setOrbitPoint()
 */
   virtual void setOrbitMode(( GameBase orbitObject, TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, bool ownClientObj=false, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )) {}
   /*! Set the camera to orbit around a given object.

@param orbitObject The object to orbit around.
@param rotation The initial camera rotation about the object in radians in the form of "x y z".
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param ownClientObject [optional] Are we orbiting an object that is owned by us?  Default is false.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@returns false if the given object could not be found.
@see Camera::setOrbitMode()
 */
   virtual bool setOrbitObject(( GameBase orbitObject, VectorF rotation, float minDistance, float maxDistance, float initDistance, bool ownClientObject=false, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )) {}
   /*! Set the camera to orbit around a given point.

@param orbitPoint The point to orbit around.  In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform().
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@see Camera::setOrbitMode()
 */
   virtual void setOrbitPoint(( TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )) {}
   /*! Set the camera to track a given object.

@param trackObject The object to track.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@returns false if the given object could not be found.
 */
   virtual bool setTrackObject(( GameBase trackObject, Point3F offset=Point3F(0.0f, 0.0f, 0.0f) )) {}
   /*! Set the editor camera to orbit around a point set with Camera::setEditOrbitPoint().

@note This method is generally used only within the World Editor and other tools.  To orbit about an object or point within a game, see Camera::setOrbitMode() and its helper methods.
 */
   virtual void setEditOrbitMode(()) {}
   /*! Set the camera to fly freely.

Allows the camera to have 6 degrees of freedom.  Provides for instantaneous motion and rotation unless one of the Newton fields has been set to true.  See Camera::newtonMode and Camera::newtonRotation.
 */
   virtual void setFlyMode(()) {}
   /*! Set the camera to fly freely, but with ease-in and ease-out.

This method allows for the same 6 degrees of freedom as Camera::setFlyMode() but activates the ease-in and ease-out on the camera's movement.  To also activate Newton mode for the camera's rotation, set Camera::newtonRotation to true. */
   virtual void setNewtonFlyMode(()) {}
   /*! Is this a Newton Fly mode camera with damped rotation?

@returns true if the camera uses a damped rotation.  i.e. Camera::newtonRotation is set to true.
 */
   virtual bool isRotationDamped(()) {}
   /*! Get the angular velocity for a Newton mode camera.

@returns The angular velocity in the form of "x y z".
@note Only returns useful results when Camera::newtonRotation is set to true. */
   virtual string getAngularVelocity(()) {}
   /*! Set the angular velocity for a Newton mode camera.

@param velocity The angular velocity infor form of "x y z".
@note Only takes affect when Camera::newtonRotation is set to true. */
   virtual void setAngularVelocity(( VectorF velocity )) {}
   /*! Set the angular force for a Newton mode camera.

@param force The angular force applied when attempting to rotate the camera.@note Only takes affect when Camera::newtonRotation is set to true. */
   virtual void setAngularForce(( float force )) {}
   /*! Set the angular drag for a Newton mode camera.

@param drag The angular drag applied while the camera is rotating.@note Only takes affect when Camera::newtonRotation is set to true. */
   virtual void setAngularDrag(( float drag )) {}
   /*! Set the mass for a Newton mode camera.

@param mass The mass used during ease-in and ease-out calculations.@note Only used when Camera is in Newton mode. */
   virtual void setMass(( float mass )) {}
   /*! Get the velocity for the camera.

@returns The camera's velocity in the form of "x y z".@note Only useful when the Camera is in Newton mode. */
   virtual string getVelocity(()) {}
   /*! Set the velocity for the camera.

@param velocity The camera's velocity in the form of "x y z".@note Only affects the Camera when in Newton mode. */
   virtual void setVelocity(( VectorF velocity )) {}
   /*! Set the drag for a Newton mode camera.

@param drag The drag applied to the camera while moving.@note Only used when Camera is in Newton mode. */
   virtual void setDrag(( float drag )) {}
   /*! Set the force applied to a Newton mode camera while moving.

@param force The force applied to the camera while attempting to move.@note Only used when Camera is in Newton mode. */
   virtual void setFlyForce(( float force )) {}
   /*! Set the Newton mode camera speed multiplier when trigger[0] is active.

@param multiplier The speed multiplier to apply.@note Only used when Camera is in Newton mode. */
   virtual void setSpeedMultiplier(( float multiplier )) {}
   /*! Set the Newton mode camera brake multiplier when trigger[1] is active.

@param multiplier The brake multiplier to apply.@note Only used when Camera is in Newton mode. */
   virtual void setBrakeMultiplier(( float multiplier )) {}
   /*! Is the camera in edit orbit mode?

@returns true if the camera is in edit orbit mode. */
   virtual bool isEditOrbitMode(()) {}
   /*! Set if there is a valid editor camera orbit point.
When validPoint is set to false the Camera operates as if it is in Fly mode rather than an Orbit mode.

@param validPoint Indicates the validity of the orbit point.@note Only used when Camera is in Edit Orbit Mode. */
   virtual void setValidEditOrbitPoint(( bool validPoint )) {}
   /*! Set the editor camera's orbit point.

@param point The point the camera will orbit in the form of "x y z". */
   virtual void setEditOrbitPoint(( Point3F point )) {}
   /*! Move the camera to fully view the given radius.

@note For this operation to take affect a valid edit orbit point must first be specified.  See Camera::setEditOrbitPoint().
@param radius The radius to view. */
   virtual void autoFitRadius(( float radius )) {}
   /*! Point the camera at the specified position.  Does not work in Orbit or Track modes.

@param point The position to point the camera at. */
   virtual void lookAt(( Point3F point )) {}

   /*! @name Camera
   @{ */
   /*! */
   /*!
   The current camera control mode.
   
    */
   CameraMotionMode controlMode;
   /// @}


   /*! @name Camera: Newton Mode
   @{ */
   /*! */
   /*!
   Apply smoothing (acceleration and damping) to camera movements.
   
    */
   bool newtonMode;
   /*!
   Apply smoothing (acceleration and damping) to camera rotations.
   
    */
   bool newtonRotation;
   /*!
   The camera's mass (Newton mode only).  Default value is 10.
   
    */
   float mass;
   /*!
   Drag on camera when moving (Newton mode only).  Default value is 2.
   
    */
   float drag;
   /*!
   Force applied on camera when asked to move (Newton mode only).  Default value is 500.
   
    */
   float force;
   /*!
   Drag on camera when rotating (Newton mode only).  Default value is 2.
   
    */
   float angularDrag;
   /*!
   Force applied on camera when asked to rotate (Newton mode only).  Default value is 100.
   
    */
   float angularForce;
   /*!
   Speed multiplier when triggering the accelerator (Newton mode only).  Default value is 2.
   
    */
   float speedMultiplier;
   /*!
   Speed multiplier when triggering the brake (Newton mode only).  Default value is 2.
   
    */
   float brakeMultiplier;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base debris class. Uses the DebrisData datablock for properties of individual debris objects.

Debris is typically made up of a shape and up to two particle emitters.  In most cases Debris objects are not created directly.  They are usually produced automatically by other means, such as through the Explosion class.  When an explosion goes off, its ExplosionData datablock determines what Debris to emit.
@tsexample
datablock ExplosionData(GrenadeLauncherExplosion)
{
   // Assiging debris data
   debris = GrenadeDebris;

   // Adjust how debris is ejected
   debrisThetaMin = 10;
   debrisThetaMax = 60;
   debrisNum = 4;
   debrisNumVariance = 2;
   debrisVelocity = 25;
   debrisVelocityVariance = 5;

   // Note: other ExplosionData properties are not listed for this example
};
@endtsexample

@note Debris are client side only objects.
@see DebrisData
@see ExplosionData
@see Explosion
@ingroup FX
 */
class  Debris : public GameBase {
  public:
   /*! @brief Manually set this piece of debris at the given position with the given velocity.

Usually you do not manually create Debris objects as they are generated through other means, such as an Explosion.  This method exists when you do manually create a Debris object and want to have it start moving.
@param inputPosition Position to place the debris.
@param inputVelocity Velocity to move the debris after it has been placed.
@return Always returns true.
@tsexample
// Define the position
%position = "1.0 1.0 1.0";

// Define the velocity
%velocity = "1.0 0.0 0.0";

// Inform the debris object of its new position and velocity
%debris.init(%position,%velocity);
@endtsexample
 */
   virtual bool init(( string inputPosition="1.0 1.0 1.0", string inputVelocity="1.0 0.0 0.0" )) {}

   /*! @name Debris
   @{ */
   /*! */
   /*!
   @brief Length of time for this debris object to exist. When expired, the object will be deleted.

The initial lifetime value comes from the DebrisData datablock.
@see DebrisData::lifetime
@see DebrisData::lifetimeVariance

   
    */
   float lifetime;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The main 3D viewport for a Torque 3D game.

@ingroup Gui3D
 */
class  GameTSCtrl : public GuiTSCtrl {
  public:
   /*! Toggles detection of water clicks.

@ingroup PlayGui */
   virtual void SendWaterClicks(( bool doSend=false )) {}
   /*! Returns the last mouse click location.

@ingroup PlayGui */
   virtual string GetLastClick(()) {}
   /*! Forces move event callback even if the mouse is not over an item.

@ingroup PlayGui */
   virtual void setNeedsMoveEvent(( bool doSend=false )) {}

   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An infinite plane extending in all direction.

%GroundPlane is useful for setting up simple testing scenes, or it can be placed under an existing scene to keep objects from falling into 'nothing'.

%GroundPlane may not be moved or rotated, it is always at the world origin.

 */
class  GroundPlane : public SceneObject {
  public:
   /*! Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit material and other fields to client objects. */
   virtual void postApply(()) {}

   /*! @name Plane
   @{ */
   /*! */
   /*!
   Square size in meters to which %GroundPlane subdivides its geometry.
   
    */
   float squareSize;
   /*!
   Scale of texture repeat in the U direction.
   
    */
   float scaleU;
   /*!
   Scale of texture repeat in the V direction.
   
    */
   float scaleV;
   /*!
   Name of Material used to render %GroundPlane's surface.
   
    */
   string Material;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Visual preview of a specified Material

Editor use only.

 */
class  GuiMaterialPreview : public GuiTSCtrl {
  public:
   /*! Sets the model to be displayed in this control

@param shapeName Name of the model to display.
 */
   virtual void setModel(( string shapeName )) {}
   /*! Deletes the preview model.
 */
   virtual void deleteModel(()) {}
   /*! Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

@param distance The distance to set the orbit to (will be clamped). */
   virtual void setOrbitDistance(( float distance )) {}
   /*! Resets the viewport to default zoom, pan, rotate and lighting. */
   virtual void reset(()) {}
   /*! Sets the color of the light in the scene.
 */
   virtual void setLightColor(( ColorF color )) {}
   /*! Sets the color of the ambient light in the scene.
 */
   virtual void setAmbientLightColor(( ColorF color )) {}

   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI control which displays a 3D model.

Model displayed in the control can have other objects mounted onto it, and the light settings can be adjusted.

@tsexample
^new GuiObjectView(ObjectPreview)
^{
^^shapeFile = "art/shapes/items/kit/healthkit.dts";
^^mountedNode = "mount0";
^^lightColor = "1 1 1 1";
^^lightAmbient = "0.5 0.5 0.5 1";
^^lightDirection = "0 0.707 -0.707";
^^orbitDiststance = "2";
^^minOrbitDiststance = "0.917688";
^^maxOrbitDiststance = "5";
^^cameraSpeed = "0.01";
^^cameraZRot = "0";
^^forceFOV = "0";
^^reflectPriority = "0";
^};
@endtsexample

@see GuiControl

@ingroup Gui3D
 */
class  GuiObjectView : public GuiTSCtrl {
  public:
      /*! @brief Called whenever the mouse enters the control.

@tsexample
// The mouse has entered the control, causing the callback to occur
GuiObjectView::onMouseEnter(%this)
^{
^^// Code to run when the mouse enters this control
^}
@endtsexample

@see GuiControl

 */
      void onMouseEnter();

      /*! @brief Called whenever the mouse leaves the control.

@tsexample
// The mouse has left the control, causing the callback to occur
GuiObjectView::onMouseLeave(%this)
^{
^^// Code to run when the mouse leaves this control
^}
@endtsexample

@see GuiControl

 */
      void onMouseLeave();

   /*! @brief Return the model displayed in this view.

@tsexample
// Request the displayed model name from the GuiObjectView object.
%modelName = %thisGuiObjectView.getModel();
@endtsexample

@return Name of the displayed model.

@see GuiControl */
   virtual string getModel(()) {}
   /*! @brief Sets the model to be displayed in this control.

@param shapeName Name of the model to display.
@tsexample
// Define the model we want to display
%shapeName = "gideon.dts";

// Tell the GuiObjectView object to display the defined model
%thisGuiObjectView.setModel(%shapeName);
@endtsexample

@see GuiControl */
   virtual void setModel(( string shapeName )) {}
   /*! @brief Return the name of the mounted model.

@tsexample
// Request the name of the mounted model from the GuiObjectView object
%mountedModelName = %thisGuiObjectView.getMountedModel();
@endtsexample

@return Name of the mounted model.

@see GuiControl */
   virtual string getMountedModel(()) {}
   /*! @brief Sets the model to be mounted on the primary model.

@param shapeName Name of the model to mount.
@tsexample
// Define the model name to mount
%modelToMount = "GideonGlasses.dts";

// Inform the GuiObjectView object to mount the defined model to the existing model in the control
%thisGuiObjectView.setMountedModel(%modelToMount);
@endtsexample

@see GuiControl */
   virtual void setMountedModel(( string shapeName )) {}
   /*! @brief Return the name of skin used on the primary model.

@tsexample
// Request the name of the skin used on the primary model in the control
%skinName = %thisGuiObjectView.getSkin();
@endtsexample

@return Name of the skin used on the primary model.

@see GuiControl */
   virtual string getSkin(()) {}
   /*! @brief Sets the skin to use on the model being displayed.

@param skinName Name of the skin to use.
@tsexample
// Define the skin we want to apply to the main model in the control
%skinName = "disco_gideon";

// Inform the GuiObjectView control to update the skin the to defined skin
%thisGuiObjectView.setSkin(%skinName);
@endtsexample

@see GuiControl */
   virtual void setSkin(( string skinName )) {}
   /*! @brief Return the name of skin used on the mounted model.

@tsexample
// Request the skin name from the model mounted on to the main model in the control
%mountModelSkin = %thisGuiObjectView.getMountSkin();
@endtsexample

@return Name of the skin used on the mounted model.

@see GuiControl */
   virtual string getMountSkin(( int param1, int param2 )) {}
   /*! @brief Sets the skin to use on the mounted model.

@param skinName Name of the skin to set on the model mounted to the main model in the control
@tsexample
// Define the name of the skin
%skinName = "BronzeGlasses";

// Inform the GuiObjectView Control of the skin to use on the mounted model
%thisGuiObjectViewCtrl.setMountSkin(%skinName);
@endtsexample

@see GuiControl */
   virtual void setMountSkin(( string skinName )) {}
   /*! @brief Sets the animation to play for the viewed object.

@param indexOrName The index or name of the animation to play.
@tsexample
// Set the animation index value, or animation sequence name.
%indexVal = "3";
//OR:
%indexVal = "idle";

// Inform the GuiObjectView object to set the animation sequence of the object in the control.
%thisGuiObjectVew.setSeq(%indexVal);
@endtsexample

@see GuiControl */
   virtual void setSeq(( string indexOrName )) {}
   /*! @brief Mounts the given model to the specified mount point of the primary model displayed in this control.

Detailed description

@param shapeName Name of the model to mount.
@param mountNodeIndexOrName Index or name of the mount point to be mounted to. If index, corresponds to "mountN" in your shape where N is the number passed here.
@tsexample
// Set the shapeName to mount
%shapeName = "GideonGlasses.dts"

// Set the mount node of the primary model in the control to mount the new shape at
%mountNodeIndexOrName = "3";
//OR:
%mountNodeIndexOrName = "Face";

// Inform the GuiObjectView object to mount the shape at the specified node.
%thisGuiObjectView.setMount(%shapeName,%mountNodeIndexOrName);
@endtsexample

@see GuiControl */
   virtual void setMount(( string shapeName, string mountNodeIndexOrName )) {}
   /*! @brief Return the current distance at which the camera orbits the object.

@tsexample
// Request the current orbit distance
%orbitDistance = %thisGuiObjectView.getOrbitDistance();
@endtsexample

@return The distance at which the camera orbits the object.

@see GuiControl */
   virtual float getOrbitDistance(()) {}
   /*! @brief Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

Detailed description

@param distance The distance to set the orbit to (will be clamped).
@tsexample
// Define the orbit distance value
%orbitDistance = "1.5";

// Inform the GuiObjectView object to set the orbit distance to the defined value
%thisGuiObjectView.setOrbitDistance(%orbitDistance);
@endtsexample

@see GuiControl */
   virtual void setOrbitDistance(( float distance )) {}
   /*! @brief Return the current multiplier for camera zooming and rotation.

@tsexample
// Request the current camera zooming and rotation multiplier value
%multiplier = %thisGuiObjectView.getCameraSpeed();
@endtsexample

@return Camera zooming / rotation multiplier value.

@see GuiControl */
   virtual float getCameraSpeed(()) {}
   /*! @brief Sets the multiplier for the camera rotation and zoom speed.

@param factor Multiplier for camera rotation and zoom speed.
@tsexample
// Set the factor value
%factor = "0.75";

// Inform the GuiObjectView object to set the camera speed.
%thisGuiObjectView.setCameraSpeed(%factor);
@endtsexample

@see GuiControl */
   virtual void setCameraSpeed(( float factor )) {}
   /*! @brief Set the light color on the sun object used to render the model.

@param color Color of sunlight.
@tsexample
// Set the color value for the sun
%color = "1.0 0.4 0.5";

// Inform the GuiObjectView object to change the sun color to the defined value
%thisGuiObjectView.setLightColor(%color);
@endtsexample

@see GuiControl */
   virtual void setLightColor(( ColorF color )) {}
   /*! @brief Set the light ambient color on the sun object used to render the model.

@param color Ambient color of sunlight.
@tsexample
// Define the sun ambient color value
%color = "1.0 0.4 0.6";

// Inform the GuiObjectView object to set the sun ambient color to the requested value
%thisGuiObjectView.setLightAmbient(%color);
@endtsexample

@see GuiControl */
   virtual void setLightAmbient(( ColorF color )) {}
   /*! @brief Set the light direction from which to light the model.

@param direction XYZ direction from which the light will shine on the model
@tsexample
// Set the light direction
%direction = "1.0 0.2 0.4"

// Inform the GuiObjectView object to change the light direction to the defined value
%thisGuiObjectView.setLightDirection(%direction);
@endtsexample

@see GuiControl */
   virtual void setLightDirection(( Point3F direction )) {}

   /*! @name Model
   @{ */
   /*! */
   /*!
   The object model shape file to show in the view.
   
    */
   filename shapeFile;
   /*!
   The skin to use on the object model.
   
    */
   string skin;
   /// @}


   /*! @name Animation
   @{ */
   /*! */
   /*!
   The animation sequence to play on the model.
   
    */
   string animSequence;
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /*!
   Optional shape file to mount on the primary model (e.g. weapon).
   
    */
   filename mountedShapeFile;
   /*!
   Skin name used on mounted shape file.
   
    */
   string mountedSkin;
   /*!
   Name of node on primary model to which to mount the secondary shape.
   
    */
   string mountedNode;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Diffuse color of the sunlight used to render the model.
   
    */
   ColorF lightColor;
   /*!
   Ambient color of the sunlight used to render the model.
   
    */
   ColorF lightAmbient;
   /*!
   Direction from which the model is illuminated.
   
    */
   Point3F lightDirection;
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /*!
   Distance from which to render the model.
   
    */
   float orbitDiststance;
   /*!
   Maxiumum distance to which the camera can be zoomed out.
   
    */
   float minOrbitDiststance;
   /*!
   Minimum distance below which the camera will not zoom in further.
   
    */
   float maxOrbitDiststance;
   /*!
   Multiplier for mouse camera operations.
   
    */
   float cameraSpeed;
   /*!
   Set the camera rotation.
   
    */
   Point3F cameraRotation;
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base Item class. Uses the ItemData datablock for common properties.

Items represent an object in the world, usually one that the player will interact with.  One example is a health kit on the group that is automatically picked up when the player comes into contact with it.

@tsexample
// This is the "health patch" dropped by a dying player.
datablock ItemData(HealthKitPatch)
{
   // Mission editor category, this datablock will show up in the
   // specified category under the "shapes" root category.
   category = "Health";

   className = "HealthPatch";

   // Basic Item properties
   shapeFile = "art/shapes/items/patch/healthpatch.dts";
   mass = 2;
   friction = 1;
   elasticity = 0.3;
   emap = true;

   // Dynamic properties used by the scripts
   pickupName = "a health patch";
   repairAmount = 50;
};

%obj = new Item()
{
^dataBlock = HealthKitSmall;
^parentGroup = EWCreatorWindow.objectGroup;
^static = true;
^rotate = true;
};
@endtsexample

@see ItemData
@ingroup gameObjects
 */
class  Item : public ShapeBase {
  public:
      /*! @brief Informs the Item object that it is now sticking to another object.

This callback is only called if the ItemData::sticky property for this Item is true.
@param objID Object ID this Item object.
@note Server side only.
@see Item, ItemData
 */
      void onStickyCollision( string objID );

      /*! Informs an Item object that it has entered liquid, along with information about the liquid type.
@param objID Object ID for this Item object.
@param waterCoverage How much coverage of water this Item object has.
@param liquidType The type of liquid that this Item object has entered.
@note Server side only.
@see Item, ItemData, WaterObject
 */
      void onEnterLiquid( string objID, string waterCoverage, string liquidType );

      /*! Informs an Item object that it has left a liquid, along with information about the liquid type.
@param objID Object ID for this Item object.
@param liquidType The type of liquid that this Item object has left.
@note Server side only.
@see Item, ItemData, WaterObject
 */
      void onLeaveLiquid( string objID, string liquidType );

   /*! @brief Is the object static (ie, non-movable)?

@return True if the object is static, false if it is not.
@tsexample
// Query the item on if it is or is not static.
%isStatic = %itemData.isStatic();

@endtsexample

@see static
 */
   virtual bool isStatic(()) {}
   /*! @brief Is the object at rest (ie, no longer moving)?

@return True if the object is at rest, false if it is not.
@tsexample
// Query the item on if it is or is not at rest.
%isAtRest = %item.isAtRest();

@endtsexample

 */
   virtual bool isAtRest(()) {}
   /*! @brief Is the object still rotating?

@return True if the object is still rotating, false if it is not.
@tsexample
// Query the item on if it is or is not rotating.
%isRotating = %itemData.isRotating();

@endtsexample

@see rotate
 */
   virtual bool isRotating(()) {}
   /*! @brief Temporarily disable collisions against a specific ShapeBase object.

This is useful to prevent a player from immediately picking up an Item they have just thrown.  Only one object may be on the timeout list at a time.  The timeout is defined as 15 ticks.

@param objectID ShapeBase object ID to disable collisions against.
@return Returns true if the ShapeBase object requested could be found, false if it could not.
@tsexample
// Set the ShapeBase Object ID to disable collisions against
%ignoreColObj = %player.getID();

// Inform this Item object to ignore collisions temproarily against the %ignoreColObj.
%item.setCollisionTimeout(%ignoreColObj);

@endtsexample

 */
   virtual bool setCollisionTimeout(( int ignoreColObj=NULL )) {}
   /*! @brief Get the position on the surface on which this Item is stuck.

@return Returns The XYZ position of where this Item is stuck.
@tsexample
// Acquire the position where this Item is currently stuck
%stuckPosition = %item.getLastStickPos();

@endtsexample

@note Server side only.
 */
   virtual string getLastStickyPos(()) {}
   /*! @brief Get the normal of the surface on which the object is stuck.

@return Returns The XYZ normal from where this Item is stuck.
@tsexample
// Acquire the position where this Item is currently stuck
%stuckPosition = %item.getLastStickPos();

@endtsexample

@note Server side only.
 */
   virtual string getLastStickyNormal(()) {}

   /*! @name Misc
   @{ */
   /*! */
   /*!
   If true, the object is not moving in the world.

   
    */
   bool static;
   /*!
   If true, the object will automatically rotate around its Z axis.

   
    */
   bool rotate;
   /// @}


   /*! @name Inventory
   @{ */
   /*! */
   /*!
   If true, the item must be bought not just picked up.

   
    */
   bool buyable;
   /*!
   The number of items that will be picked up or bought.

   
    */
   int count;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Stores and controls the rendering and status information for a game level.

@tsexample
new LevelInfo(theLevelInfo)
{
  visibleDistance = "1000";
  fogColor = "0.6 0.6 0.7 1";
  fogDensity = "0";
  fogDensityOffset = "700";
  fogAtmosphereHeight = "0";
  canvasClearColor = "0 0 0 255";
  canSaveDynamicFields = "1";
  levelName = "Blank Room";
  desc0 = "A blank room ready to be populated with Torque objects.";
  Enabled = "1";
};
@endtsexample
@ingroup enviroMisc
 */
class  LevelInfo : public NetObject {
  public:
   /*! SetFog(Density,Offset) */
   virtual void SetFog(( float fDensity, float fOffset )) {}

   /*! @name Visibility
   @{ */
   /*! */
   /*!
   Closest distance from the camera's position to render the world.
   
    */
   float nearClip;
   /*!
   Furthest distance fromt he camera's position to render the world.
   
    */
   float visibleDistance;
   /*!
   Furthest distance fromt he camera's position to render players.
   
    */
   float visiblePlayers;
   /*!
   NearPlane bias used when rendering Decal and DecalRoad. This should be tuned to the visibleDistance in your level.
   
    */
   float decalBias;
   /// @}


   /*! @name Fog
   @{ */
   /*! */
   /*!
   The default color for the scene fog.
   
    */
   ColorF fogColor;
   /*!
   The 0 to 1 density value for the exponential fog falloff.
   
    */
   float fogDensity;
   /*!
   An offset from the camera in meters for moving the start of the fog effect.
   
    */
   float fogDensityOffset;
   /*!
   A height in meters for altitude fog falloff.
   
    */
   float fogAtmosphereHeight;
   /// @}


   /*! @name LevelInfo
   @{ */
   /*! */
   /*!
   The color used to clear the background before the scene or any GUIs are rendered.
   
    */
   ColorI canvasClearColor;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Number of seconds it takes to blend from one ambient light color to a different one.
   
    */
   float ambientLightBlendPhase;
   /*!
   Interpolation curve to use for blending from one ambient light color to a different one.
   
    */
   EaseF ambientLightBlendCurve;
   /*!
   Enable expanded support for mixing static and dynamic lighting (more costly)
   
    */
   bool advancedLightmapSupport;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /*!
   The global ambient sound environment.
   
    */
   SFXAmbience soundAmbience;
   /*!
   The distance attenuation model to use.
   
    */
   SFXDistanceModel soundDistanceModel;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A helper datablock used by classes (such as shapebase) that submit lights to the scene but do not use actual "LightBase" objects.

This datablock stores the properties of that light as fields that can be initialized from script.@tsexample
// Declare a light description to be used on a rocket launcher projectile
datablock LightDescription(RocketLauncherLightDesc)
{
   range = 4.0;
   color = "1 1 0";
   brightness = 5.0;
   animationType = PulseLightAnim;
   animationPeriod = 0.25;
};

// Declare a ProjectileDatablock which uses the light description
datablock ProjectileData(RocketLauncherProjectile)
{
   lightDesc = RocketLauncherLightDesc;

   projectileShapeName = "art/shapes/weapons/SwarmGun/rocket.dts";

   directDamage = 30;
   radiusDamage = 30;
   damageRadius = 5;
   areaImpulse = 2500;

   // ... remaining ProjectileData fields not listed for this example
};
@endtsexample

@see LightBase

@ingroup Lighting
 */
class  LightDescription : public SimDataBlock {
  public:
   /*! @brief Force an inspectPostApply call for the benefit of tweaking via the console

Normally this functionality is only exposed to objects via the World Editor, once changes have been made. Exposing apply to script allows you to make changes to it on the fly without the World Editor.

@note This is intended for debugging and tweaking, not for game play

@tsexample
// Change a property of the light description
RocketLauncherLightDesc.brightness = 10;

// Make it so
RocketLauncherLightDesc.apply();
@endtsexample

 */
   virtual void apply(()) {}

   /*! @name Light
   @{ */
   /*! */
   /*!
   Changes the base color hue of the light.
   
    */
   ColorF color;
   /*!
   Adjusts the lights power, 0 being off completely.
   
    */
   float brightness;
   /*!
   Controls the size (radius) of the light
   
    */
   float range;
   /*!
   Enables/disabled shadow casts by this light.
   
    */
   bool castShadows;
   /// @}


   /*! @name Light Animation
   @{ */
   /*! */
   /*!
   Datablock containing light animation information (LightAnimData)
   
    */
   LightAnimData animationType;
   /*!
   The length of time in seconds for a single playback of the light animation
   
    */
   float animationPeriod;
   /*!
   The phase used to offset the animation start time to vary the animation of nearby lights.
   
    */
   float animationPhase;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Datablock containing light flare information (LightFlareData)
   
    */
   LightFlareData flareType;
   /*!
   Globally scales all features of the light flare
   
    */
   float flareScale;
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /*!
   The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.
   
    */
   Point3F attenuationRatio;
   /*!
   The type of shadow to use on this light.
   
    */
   ShadowType shadowType;
   /*!
   A custom pattern texture which is projected from the light.
   
    */
   filename cookie;
   /*!
   The texture size of the shadow map.
   
    */
   int texSize;
   /*!
   The ESM shadow darkening factor
   
    */
   Point4F overDarkFactor;
   /*!
   The distance from the camera to extend the PSSM shadow.
   
    */
   float shadowDistance;
   /*!
   
   
    */
   float shadowSoftness;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   int numSplits;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   float logWeight;
   /*!
   Start fading shadows out at this distance.  0 = auto calculate this distance.
   
    */
   float fadeStartDistance;
   /*!
   This toggles only terrain being rendered to the last split of a PSSM shadow map.
   
    */
   bool lastSplitTerrainOnly;
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /*!
   This light is represented in lightmaps (static light, default: false)
   
    */
   bool representedInLightmap;
   /*!
   The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)
   
    */
   ColorF shadowDarkenColor;
   /*!
   This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)
   
    */
   bool includeLightmappedGeometryInShadow;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines a light flare effect usable by scene lights.

%LightFlareData is a datablock which defines a type of flare effect. This may then be referenced by other classes which support the rendering of a flare: Sun, ScatterSky, LightBase.

A flare contains one or more elements defined in the element* named fields of %LightFlareData, with a maximum of ten elements. Each element is rendered as a 2D sprite in screenspace.

@tsexample
// example from Full Template, core/art/datablocks/lights.cs
datablock LightFlareData( LightFlareExample0 )
{
   overallScale = 2.0;
   flareEnabled = true;
   renderReflectPass = true;
   flareTexture = "./../special/lensFlareSheet1";
   occlusionRadius = 0.25;
   
   elementRect[0] = "0 512 512 512";
   elementDist[0] = 0.0;
   elementScale[0] = 0.5;
   elementTint[0] = "1.0 1.0 1.0";
   elementRotate[0] = false;
   elementUseLightColor[0] = false;
   
   elementRect[1] = "512 0 512 512";
   elementDist[1] = 0.0;
   elementScale[1] = 2.0;
   elementTint[1] = "0.5 0.5 0.5";
   elementRotate[1] = false;
   elementUseLightColor[1] = false;
};
@endtsexample
The elementDist field defines where along the flare's beam the element appears. A distance of 0.0 is directly over the light source, a distance of 1.0 is at the screen center, and a distance of 2.0 is at the position of the light source mirrored across the screen center.
@image html images/lightFlareData_diagram.png
 */
class  LightFlareData : public SimDataBlock {
  public:
   /*! Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply */
   virtual void apply(()) {}

   /*! @name LightFlareData
   @{ */
   /*! */
   /*!
   Size scale applied to all elements of the flare.
   
    */
   float overallScale;
   /*!
   If positive an occlusion query is used to test flare visibility, else it uses simple raycasts.
   
    */
   float occlusionRadius;
   /*!
   If false the flare does not render in reflections, else only non-zero distance elements are rendered.
   
    */
   bool renderReflectPass;
   /// @}


   /*! @name FlareElements
   @{ */
   /*! */
   /*!
   Allows the user to disable this flare globally for any lights referencing it.
   
    */
   bool flareEnabled;
   /*!
   The texture / sprite sheet for this flare.
   
    */
   filename flareTexture;
   /*!
   A rectangle specified in pixels of the flareTexture image.
   
    */
   RectF elementRect;
   /*!
   Where this element appears along the flare beam.
   
    */
   float elementDist;
   /*!
   Size scale applied to this element.
   
    */
   float elementScale;
   /*!
   Used to modulate this element's color if elementUseLightColor is false.
@see elementUseLightColor
   
    */
   ColorF elementTint;
   /*!
   Defines if this element orients to point along the flare beam or if it is always upright.
   
    */
   bool elementRotate;
   /*!
   If true this element's color is modulated by the light color. If false, elementTint will be used.
@see elementTint
   
    */
   bool elementUseLightColor;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Level object which defines the boundaries of the level.

This is a simple box with starting points, width, depth, and height. It does not have any default functionality. Instead, when objects hit the boundaries certain script callbacks will be made allowing you to control the reaction.

@tsexample
new MissionArea(GlobalMissionArea)
{
^  Area = "-152 -352 1008 864";
^  flightCeiling = "300";
^  flightCeilingRange = "20";
^  canSaveDynamicFields = "1";
^^ enabled = "1";
^^ TypeBool locked = "false";
};
@endtsexample

@ingroup enviroMisc
 */
class  MissionArea : public NetObject {
  public:
   /*! Returns 4 fields: starting x, starting y, extents x, extents y.
 */
   virtual string getArea(()) {}
   /*! @brief - Defines the size of the MissionArea

param x Starting X coordinate position for MissionArea
param y Starting Y coordinate position for MissionArea
param width New width of the MissionArea
param height New height of the MissionArea
@note Only the server object may be set.
 */
   virtual void setArea(( int x, int y, int width, int height )) {}
   /*! Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit material and other fields ( not including nodes ) to client objects. */
   virtual void postApply(()) {}

   /*! @name Dimensions
   @{ */
   /*! */
   /*!
   Four corners (X1, X2, Y1, Y2) that makes up the level's boundaries
   
    */
   RectI area;
   /*!
   Represents the top of the mission area, used by FlyingVehicle. 
   
    */
   float flightCeiling;
   /*!
   Distance from ceiling before FlyingVehicle thrust is cut off. 
   
    */
   float flightCeilingRange;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This class is used for creating any type of game object, assigning it a class, datablock, and other properties when it is spawned.

Torque 3D uses a simple spawn system, which can be easily modified to spawn any kind of object (of any class). Each new level already contains at least one SpawnSphere, which is represented by a green octahedron in stock Torque 3D. The spawnClass field determines the object type, such as Player, AIPlayer, etc. The spawnDataBlock field applies the pre-defined datablock to each spawned object instance. The really powerful feature of this class is provided by the spawnScript field which allows you to define a simple script (multiple lines) that will be executed once the object has been spawned.

@tsexample
// Define an SpawnSphere that essentially performs the following each time an object is spawned
//$SpawnObject = new Player()
//{
//   dataBlock = "DefaultPlayerData";
//   name = "Bob";
//   lifeTotal = 3;
//};
//echo("Spawned a Player: " @ $SpawnObject);

new SpawnSphere(DefaultSpawnSphere)
{
   spawnClass = "Player";
   spawnDatablock = "DefaultPlayerData";
   spawnScript = "echo(\"Spawned a Player: \" @ $SpawnObject);"; // embedded quotes must be escaped with \ 
   spawnProperties = "name = \"Bob\";lifeTotal = 3;"; // embedded quotes must be escaped with \ 
   autoSpawn = "1";
   dataBlock = "SpawnSphereMarker";
   position = "-0.77266 -19.882 17.8153";
   rotation = "1 0 0 0";
   scale = "1 1 1";
   canSave = "1";
   canSaveDynamicFields = "1";
};

// Because autoSpawn is set to true in the above example, the following lines
// of code will execute AFTER the Player object has been spawned.
echo("Object Spawned");
echo("Hello World");

@endtsexample

@see MissionMarker

@see MissionMarkerData

@ingroup gameObjects
@ingroup enviroMisc
 */
class  SpawnSphere : public MissionMarker {
  public:
      /*! Called when the SpawnSphere is being created.
@param objectId The unique SimObjectId generated when SpawnSphere is created (%%this in script)
 */
      void onAdd( int objectId );

   /*! Spawns the object based on the SpawnSphere's class, datablock, properties, and script settings. Allows you to pass in extra properties.@hide */
   virtual int spawnObject(([string additionalProps])) {}

   /*! @name Spawn
   @{ */
   /*! */
   /*!
   Object class to create (eg. Player, AIPlayer, Debris etc)
   
    */
   string spawnClass;
   /*!
   Predefined datablock assigned to the object when created
   
    */
   string spawnDatablock;
   /*!
   String containing semicolon (;) delimited properties to set when the object is created.
   
    */
   string spawnProperties;
   /*!
   Command to execute immediately after spawning an object. New object id is stored in $SpawnObject.  Max 255 characters.
   
    */
   string spawnScript;
   /*!
   Flag to spawn object as soon as SpawnSphere is created, true to enable or false to disable.
   
    */
   bool autoSpawn;
   /*!
   Flag to set the spawned object's transform to the SpawnSphere's transform.
   
    */
   bool spawnTransform;
   /// @}


   /*! @name Dimensions
   @{ */
   /*! */
   /*!
   Deprecated
   
    */
   float radius;
   /// @}


   /*! @name Weight
   @{ */
   /*! */
   /*!
   Deprecated
   
    */
   float sphereWeight;
   /*!
   Deprecated
   
    */
   float indoorWeight;
   /*!
   Deprecated
   
    */
   float outdoorWeight;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A camera that moves along a path. The camera can then be made to travel along this path forwards or backwards.

A camera's path is made up of knots, which define a position, rotation and speed for the camera.  Traversal from one knot to another may be either linear or using a Catmull-Rom spline.  If the knot is part of a spline, then it may be a normal knot or defined as a kink.  Kinked knots are a hard transition on the spline rather than a smooth one.  A knot may also be defined as a position only.  In this case the knot is treated as a normal knot but is ignored when determining how to smoothly rotate the camera while it is travelling along the path (the algorithm moves on to the next knot in the path for determining rotation).

The datablock field for a PathCamera is a previously created PathCameraData, which acts as the interface between the script and the engine for this PathCamera object.

@see PathCameraData
@tsexample
%newPathCamera = new PathCamera()
{
  dataBlock = LoopingCam;
  position = "0 0 300 1 0 0 0";
};
@endtsexample
@ingroup PathCameras
 */
class  PathCamera : public ShapeBase {
  public:
      /*! A script callback that indicates the path camera has arrived at a specific node in its path.  Server side only.
@param Node Unique ID assigned to this node.
 */
      void onNode( string node );

   /*! Set the current position of the camera along the path.
@param position Position along the path, from 0.0 (path start) - 1.0 (path end), to place the camera.
@tsexample
// Set the camera on a position along its path from 0.0 - 1.0.
%position = "0.35";

// Force the pathCamera to its new position along the path.
%pathCamera.setPosition(%position);
@endtsexample
 */
   virtual void setPosition(( float position=0.0f )) {}
   /*! @brief Set the movement target for this camera along its path.

The camera will attempt to move along the path to the given target in the direction provided by setState() (the default is forwards).  Once the camera moves past this target it will come to a stop, and the target state will be cleared.
@param position Target position, between 0.0 (path start) and 1.0 (path end), for the camera to move to along its path.
@tsexample
// Set the position target, between 0.0 (path start) and 1.0 (path end), for this camera to move to.
%position = "0.50";

// Inform the pathCamera of the new target position it will move to.
%pathCamera.setTarget(%position);
@endtsexample
 */
   virtual void setTarget(( float position=1.0f )) {}
   /*! Set the movement state for this path camera.
@param newState New movement state type for this camera. Forward, Backward or Stop.
@tsexample
// Set the state type (forward, backward, stop).
// In this example, the camera will travel from the first node
// to the last node (or target if given with setTarget())
%state = "forward";

// Inform the pathCamera to change its movement state to the defined value.
%pathCamera.setState(%state);
@endtsexample
 */
   virtual void setState(( string newState="forward" )) {}
   /*! @brief Clear the camera's path and set the camera's current transform as the start of the new path.

What specifically occurs is a new knot is created from the camera's current transform.  Then the current path is cleared and the new knot is pushed onto the path.  Any previous target is cleared and the camera's movement state is set to Forward.  The camera is now ready for a new path to be defined.
@param speed Speed for the camera to move along its path after being reset.
@tsexample
//Determine the new movement speed of this camera. If not set, the speed will default to 1.0.
%speed = "0.50";

// Inform the path camera to start a new path at// the camera's current position, and set the new // path's speed value.
%pathCamera.reset(%speed);
@endtsexample
 */
   virtual void reset(( float speed=1.0f )) {}
   /*! @brief Adds a new knot to the back of a path camera's path.
@param transform Transform for the new knot.  In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform()
@param speed Speed setting for this knot.
@param type Knot type (Normal, Position Only, Kink).
@param path %Path type (Linear, Spline).
@tsexample
// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
%transform = "15.0 5.0 5.0 1.4 1.0 0.2 1.0"

// Speed setting for knot.
%speed = "1.0"

// Knot type. (Normal, Position Only, Kink)
%type = "Normal";

// Path Type. (Linear, Spline)
%path = "Linear";

// Inform the path camera to add a new knot to the back of its path
%pathCamera.pushBack(%transform,%speed,%type,%path);
@endtsexample
 */
   virtual void pushBack(( TransformF transform, float speed=1.0, string type="Normal", string path="Linear" )) {}
   /*! @brief Adds a new knot to the front of a path camera's path.
@param transform Transform for the new knot. In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform()
@param speed Speed setting for this knot.
@param type Knot type (Normal, Position Only, Kink).
@param path %Path type (Linear, Spline).
@tsexample
// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
%transform = "15.0 5.0 5.0 1.4 1.0 0.2 1.0"

// Speed setting for knot.
%speed = "1.0";

// Knot type. (Normal, Position Only, Kink)
%type = "Normal";

// Path Type. (Linear, Spline)
%path = "Linear";

// Inform the path camera to add a new knot to the front of its path
%pathCamera.pushFront(%transform, %speed, %type, %path);
@endtsexample
 */
   virtual void pushFront(( TransformF transform, float speed=1.0, string type="Normal", string path="Linear" )) {}
   /*! Removes the knot at the front of the camera's path.
@tsexample
// Remove the first knot in the camera's path.
%pathCamera.popFront();
@endtsexample
 */
   virtual void popFront(()) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Physical Zones are areas that modify the player's gravity and/or velocity and/or applied force.

The datablock properties determine how the physics, velocity and applied forces affect a player who enters this zone.
@tsexample
new PhysicalZone(Team1JumpPad) {
velocityMod = "1";gravityMod = "0";
appliedForce = "0 0 20000";
polyhedron = "0.0000000 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000 0.0000000 -1.0000000 0.0000000 0.0000000 0.0000000 1.0000000";
position = "273.559 -166.371 249.856";
rotation = "0 0 1 13.0216";
scale = "8 4.95 28.31";
isRenderEnabled = "true";
canSaveDynamicFields = "1";
enabled = "1";
};
@endtsexample

@ingroup enviroMisc
 */
class  PhysicalZone : public SceneObject {
  public:
   /*! Activate the physical zone's effects.
@tsexample
// Activate effects for a specific physical zone.
%thisPhysicalZone.activate();
@endtsexample
@ingroup Datablocks
 */
   virtual void activate(()) {}
   /*! Deactivate the physical zone's effects.
@tsexample
// Deactivate effects for a specific physical zone.
%thisPhysicalZone.deactivate();
@endtsexample
@ingroup Datablocks
 */
   virtual void deactivate(()) {}

   /*! @name Misc
   @{ */
   /*! */
   /*!
   Multiply velocity of objects entering zone by this value every tick.
   
    */
   float velocityMod;
   /*!
   Gravity in PhysicalZone. Multiplies against standard gravity.
   
    */
   float gravityMod;
   /*!
   Three-element floating point value representing forces in three axes to apply to objects entering PhysicalZone.
   
    */
   Point3F appliedForce;
   /*!
   The polyhedron type is really a quadrilateral and consists of a cornerpoint followed by three vectors representing the edges extending from the corner.
   
    */
   floatList polyhedron;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines properties for a Player object.

@see Player
@ingroup gameObjects
 */
class  PlayerData : public ShapeBaseData {
  public:
      /*! @brief Called when the player changes poses.

@param obj The Player object
@param oldPose The pose the player is switching from.
@param newPose The pose the player is switching to.
 */
      void onPoseChange( Player obj, string oldPose, string newPose );

      /*! @brief Called when the player starts swimming.

@param obj The Player object
 */
      void onStartSwim( Player obj );

      /*! @brief Called when the player stops swimming.

@param obj The Player object
 */
      void onStopSwim( Player obj );

      /*! @brief Called when the player starts moving while in a Sprint pose.

@param obj The Player object
 */
      void onStartSprintMotion( Player obj );

      /*! @brief Called when the player stops moving while in a Sprint pose.

@param obj The Player object
 */
      void onStopSprintMotion( Player obj );

      /*! @brief Called when attempting to dismount the player from a vehicle.

It is up to the doDismount() method to actually perform the dismount.  Often there are some conditions that prevent this, such as the vehicle moving too fast.
@param obj The Player object
 */
      void doDismount( Player obj );

      /*! @brief Called when the player enters a liquid.

@param obj The Player object
@param coverage Percentage of the player's bounding box covered by the liquid
@param type The type of liquid the player has entered
 */
      void onEnterLiquid( Player obj, float coverage, string type );

      /*! @brief Called when the player leaves a liquid.

@param obj The Player object
@param type The type of liquid the player has left
 */
      void onLeaveLiquid( Player obj, string type );

      /*! @brief Called on the server when a scripted animation completes.

@param obj The Player object
@see Player::setActionThread() for setting a scripted animation and its 'hold' parameter to determine if this callback is used.
 */
      void animationDone( Player obj );

      /*! @brief Called when the player enters the mission area.

@param obj The Player object
@see MissionArea
 */
      void onEnterMissionArea( Player obj );

      /*! @brief Called when the player leaves the mission area.
@param obj The Player object
@see MissionArea
 */
      void onLeaveMissionArea( Player obj );

      /*! @brief Called when the player moves beyond its teathered distance.
@param obj The Player object
@see Fishing docs
 */
      void onBreakTeather( Player obj );

      /*! @brief Called on the server when a player jumps.

@param isStandJump True is the player is standing still, False if the player is moving
 */
      void onPlayerJump( Player  obj, bool isStandJump );

   /*! @brief Gets the animation duration in seconds.

 */
   virtual float getSequenceDuration(( string name )) {}
   /*!
   @brief Radius around the player to collide with Items in the scene (on server).

Internally the pickupRadius is added to the larger side of the initial bounding box to determine the actual distance, to a maximum of 2 times the bounding box size.  The initial bounding box is that used for the root pose, and therefore doesn't take into account the change in pose.

   
    */
   float pickupRadius;
   /*!
   @brief Maximum time scale for action animations.

If an action animation has a defined ground frame, it is automatically scaled to match the player's ground velocity.  This field limits the maximum time scale used even if the player's velocity exceeds it.
   
    */
   float maxTimeScale;
   /*!
   @brief Minimum time scale for action animations.

If an action animation has a defined ground frame, it is automatically scaled to match the player's ground velocity.  This field limits the minimum time scale used even if the player's velocity is below it.
   
    */
   float minTimeScale;

   /*! @name Camera
   @{ */
   /*! */
   /*!
   @brief Flag controlling whether to render the player shape in first person view.


   
    */
   bool renderFirstPerson;
   /*!
   @brief Forces shadows to be rendered in first person when renderFirstPerson is disabled.  Defaults to false.


   
    */
   bool firstPersonShadows;
   /*!
   @brief Highest angle (in radians) the player can look.

@note An angle of zero is straight ahead, with positive up and negative down.
   
    */
   float maxLookAngle;
   /*!
   @brief Defines the maximum left and right angles (in radians) the player can look in freelook mode.


   
    */
   float maxFreelookAngle;
   /*!
   @brief Maximum angle (in radians) the player can look left/right.

@note An angle of zero is straight ahead, with positive right and negative left.
   
    */
   float maxHeadYawAngle;
   /// @}


   /*! @name Movement
   @{ */
   /*! */
   /*!
   @brief Flag controlling whether to let the player fly.


   
    */
   bool canFly;
   /*!
   @brief Flag controlling if the player can swim under water or not.


   
    */
   bool surfaceSwim;
   /*!
   @brief Flag controlling if the player transitions from swimming to walking frequently.


   
    */
   bool isAmphibious;
   /*!
   @brief Flag if it's a horse.


   
    */
   bool isHorse;
   /*!
   @brief Maximum height the player can step up.

The player will automatically step onto changes in ground height less than maxStepHeight.  The player will collide with ground height changes greater than this.
   
    */
   float maxStepHeight;
   /*!
   @brief Force used to accelerate the player when running.


   
    */
   float runForce;
   /*!
   @brief Energy value drained each tick that the player is moving.

The player will not be able to move when his energy falls below minRunEnergy.
@note Setting this to zero will disable any energy drain.
@see minRunEnergy

   
    */
   float runEnergyDrain;
   /*!
   @brief Minimum energy level required to run or swim.

@see runEnergyDrain

   
    */
   float minRunEnergy;
   /*!
   @brief Maximum forward speed when running.
   
    */
   float maxForwardSpeed;
   /*!
   @brief Maximum backward speed when running.
   
    */
   float maxBackwardSpeed;
   /*!
   @brief Maximum sideways speed when running.
   
    */
   float maxSideSpeed;
   /*!
   @brief Maximum angle from vertical (in degrees) the player can run up.


   
    */
   float runSurfaceAngle;
   /*!
   @brief Minimum impact speed to apply falling damage.

This field also sets the minimum speed for the onImpact callback to be invoked.
@see ShapeBaseData::onImpact()

   
    */
   float minImpactSpeed;
   /*!
   @brief Minimum impact speed to apply non-falling damage.

This field also sets the minimum speed for the onLateralImpact callback to be invoked.
@see ShapeBaseData::onLateralImpact()

   
    */
   float minLateralImpactSpeed;
   /*!
   @brief Maximum horizontal speed.

@note This limit is only enforced if the player's horizontal speed exceeds horizResistSpeed.
@see horizResistSpeed
@see horizResistFactor

   
    */
   float horizMaxSpeed;
   /*!
   @brief Horizontal speed at which resistence will take place.

@see horizMaxSpeed
@see horizResistFactor

   
    */
   float horizResistSpeed;
   /*!
   @brief Factor of resistence once horizResistSpeed has been reached.

@see horizMaxSpeed
@see horizResistSpeed

   
    */
   float horizResistFactor;
   /*!
   @brief Maximum upwards speed.

@note This limit is only enforced if the player's upward speed exceeds upResistSpeed.
@see upResistSpeed
@see upResistFactor

   
    */
   float upMaxSpeed;
   /*!
   @brief Upwards speed at which resistence will take place.

@see upMaxSpeed
@see upResistFactor

   
    */
   float upResistSpeed;
   /*!
   @brief Factor of resistence once upResistSpeed has been reached.

@see upMaxSpeed
@see upResistSpeed

   
    */
   float upResistFactor;
   /*!
   
   
    */
   float run2Speed;
   /*!
   
   
    */
   float run3Speed;
   /*!
   
   
    */
   float minRotationTime;
   /// @}


   /*! @name Movement: Jumping
   @{ */
   /*! */
   /*!
   @brief Force used to accelerate the player when a jump is initiated.


   
    */
   float jumpForce;
   /*!
   @brief Force used to accelerate the player when a jump is initiated.


   
    */
   float standJumpForce;
   /*!
   @brief Energy level drained each time the player jumps.

@note Setting this to zero will disable any energy drain
@see minJumpEnergy

   
    */
   float jumpEnergyDrain;
   /*!
   @brief Minimum energy level required to jump.

@see jumpEnergyDrain

   
    */
   float minJumpEnergy;
   /*!
   @brief Minimum speed needed to jump.

If the player's own z velocity is greater than this, then it is used to scale the jump speed, up to maxJumpSpeed.
@see maxJumpSpeed

   
    */
   float minJumpSpeed;
   /*!
   @brief Maximum vertical speed before the player can no longer jump.


   
    */
   float maxJumpSpeed;
   /*!
   @brief Angle from vertical (in degrees) where the player can jump.


   
    */
   float jumpSurfaceAngle;
   /*!
   @brief Delay time in number of ticks ticks between jumps.


   
    */
   int jumpDelay;
   /*!
   @brief Amount of movement control the player has when in the air.

This is applied as a multiplier to the player's x and y motion.

   
    */
   float airControl;
   /*!
   @brief Controls the direction of the jump impulse.
When false, jumps are always in the vertical (+Z) direction. When true jumps are in the direction of the ground normal so long as the player is not directly facing the surface.  If the player is directly facing the surface, then they will jump straight up.

   
    */
   bool jumpTowardsNormal;
   /// @}


   /*! @name Movement: Sprinting
   @{ */
   /*! */
   /*!
   @brief Force used to accelerate the player when sprinting.


   
    */
   float sprintForce;
   /*!
   @brief Energy value drained each tick that the player is sprinting.

The player will not be able to move when his energy falls below sprintEnergyDrain.
@note Setting this to zero will disable any energy drain.
@see minSprintEnergy

   
    */
   float sprintEnergyDrain;
   /*!
   @brief Minimum energy level required to sprint.

@see sprintEnergyDrain

   
    */
   float minSprintEnergy;
   /*!
   @brief Maximum forward speed when sprinting.
   
    */
   float maxSprintForwardSpeed;
   /*!
   @brief Maximum backward speed when sprinting.
   
    */
   float maxSprintBackwardSpeed;
   /*!
   @brief Maximum sideways speed when sprinting.
   
    */
   float maxSprintSideSpeed;
   /*!
   @brief Amount to scale strafing motion vector while sprinting.
   
    */
   float sprintStrafeScale;
   /*!
   @brief Amount to scale yaw motion while sprinting.
   
    */
   float sprintYawScale;
   /*!
   @brief Amount to scale pitch motion while sprinting.
   
    */
   float sprintPitchScale;
   /*!
   @brief Can the player jump while sprinting.
   
    */
   bool sprintCanJump;
   /// @}


   /*! @name Movement: Swimming
   @{ */
   /*! */
   /*!
   @brief Force used to accelerate the player when swimming.


   
    */
   float swimForce;
   /*!
   @brief Maximum forward speed when underwater.


   
    */
   float maxUnderwaterForwardSpeed;
   /*!
   @brief Maximum backward speed when underwater.


   
    */
   float maxUnderwaterBackwardSpeed;
   /*!
   @brief Maximum sideways speed when underwater.


   
    */
   float maxUnderwaterSideSpeed;
   /// @}


   /*! @name Movement: Crouching
   @{ */
   /*! */
   /*!
   @brief Force used to accelerate the player when crouching.


   
    */
   float crouchForce;
   /*!
   @brief Maximum forward speed when crouching.


   
    */
   float maxCrouchForwardSpeed;
   /*!
   @brief Maximum backward speed when crouching.


   
    */
   float maxCrouchBackwardSpeed;
   /*!
   @brief Maximum sideways speed when crouching.


   
    */
   float maxCrouchSideSpeed;
   /// @}


   /*! @name Movement: Prone
   @{ */
   /*! */
   /*!
   @brief Force used to accelerate the player when prone (laying down).


   
    */
   float proneForce;
   /*!
   @brief Maximum forward speed when prone (laying down).


   
    */
   float maxProneForwardSpeed;
   /*!
   @brief Maximum backward speed when prone (laying down).


   
    */
   float maxProneBackwardSpeed;
   /*!
   @brief Maximum sideways speed when prone (laying down).


   
    */
   float maxProneSideSpeed;
   /// @}


   /*! @name Falling
   @{ */
   /*! */
   /*!
   @brief Downward speed at which we consider the player falling.


   
    */
   float fallingSpeedThreshold;
   /*!
   @brief Number of ticks for the player to recover from falling.


   
    */
   int recoverDelay;
   /*!
   @brief Scale factor applied to runForce while in the recover state.

This can be used to temporarily slow the player's movement after a fall, or prevent the player from moving at all if set to zero.

   
    */
   float recoverRunForceScale;
   /*!
   @brief Time of land sequence play back when using new recover system.

If greater than 0 then the legacy fall recovery system will be bypassed in favour of just playing the player's land sequence.  The time to recover from a fall then becomes this parameter's time and the land sequence's playback will be scaled to match.
@see transitionToLand

   
    */
   float landSequenceTime;
   /*!
   @brief When going from a fall to a land, should we transition between the two.

@note Only takes affect when landSequenceTime is greater than 0.
@see landSequenceTime

   
    */
   bool transitionToLand;
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /*!
   @brief Size of the bounding box used by the player for collision.

Dimensions are given as "width depth height".
   
    */
   Point3F boundingBox;
   /*!
   @brief Collision bounding box used when the player is crouching.

@see boundingBox
   
    */
   Point3F crouchBoundingBox;
   /*!
   @brief Collision bounding box used when the player is prone (laying down).

@see boundingBox
   
    */
   Point3F proneBoundingBox;
   /*!
   @brief Collision bounding box used when the player is swimming.

@see boundingBox
   
    */
   Point3F swimBoundingBox;
   /*!
   @brief Percentage of the player's bounding box height that represents the head.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxHeadPercentage;
   /*!
   @brief Percentage of the player's bounding box height that represents the torso.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxTorsoPercentage;
   /*!
   @brief Percentage of the player's bounding box width that represents the left side of the head.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxHeadLeftPercentage;
   /*!
   @brief Percentage of the player's bounding box width that represents the right side of the head.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxHeadRightPercentage;
   /*!
   @brief Percentage of the player's bounding box depth that represents the back side of the head.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxHeadBackPercentage;
   /*!
   @brief Percentage of the player's bounding box depth that represents the front side of the head.

Used when computing the damage location.
@see Player::getDamageLocation
   
    */
   float boxHeadFrontPercentage;
   /// @}


   /*! @name Interaction: Footsteps
   @{ */
   /*! */
   /*!
   @brief Particle emitter used to generate footpuffs (particles created as the player walks along the ground).

@note The generation of foot puffs requires the appropriate triggeres to be defined in the player's animation sequences.  Without these, no foot puffs will be generated.

   
    */
   ParticleEmitterData footPuffEmitter;
   /*!
   @brief Number of footpuff particles to generate each step.

Each foot puff is randomly placed within the defined foot puff radius.  This includes having footPuffNumParts set to one.
@see footPuffRadius

   
    */
   int footPuffNumParts;
   /*!
   @brief Particle creation radius for footpuff particles.

This is applied to each foot puff particle, even if footPuffNumParts is set to one.  So set this value to zero if you want a single foot puff placed at exactly the same location under the player each time.

   
    */
   float footPuffRadius;
   /*!
   @brief Emitter used to generate dust particles.

@note Currently unused.
   
    */
   ParticleEmitterData dustEmitter;
   /*!
   @brief Decal to place on the ground for player footsteps.


   
    */
   DecalData DecalData;
   /*!
   @brief Distance from the center of the model to the right foot.

While this defines the distance to the right foot, it is also used to place the left foot decal as well.  Just on the opposite side of the player.
   
    */
   float decalOffset;
   /// @}


   /*! @name Interaction: Sounds
   @{ */
   /*! */
   /*!
   @brief Sound to play when walking on a surface with Material footstepSoundId 0.


   
    */
   SFXTrack FootSoftSound;
   /*!
   @brief Sound to play when walking on a surface with Material footstepSoundId 1.


   
    */
   SFXTrack FootHardSound;
   /*!
   @brief Sound to play when walking on a surface with Material footstepSoundId 2.


   
    */
   SFXTrack FootMetalSound;
   /*!
   @brief Sound to play when walking on a surface with Material footstepSoundId 3.


   
    */
   SFXTrack FootSnowSound;
   /*!
   @brief Sound to play when walking in water and coverage is less than footSplashHeight.

@see footSplashHeight

   
    */
   SFXTrack FootShallowSound;
   /*!
   @brief Sound to play when walking in water and coverage is less than 1, but > footSplashHeight.

@see footSplashHeight

   
    */
   SFXTrack FootWadingSound;
   /*!
   @brief Sound to play when walking in water and coverage equals 1.0 (fully underwater).


   
    */
   SFXTrack FootUnderwaterSound;
   /*!
   @brief Sound to play when walking in water and coverage equals 1.0 (fully underwater).


   
    */
   SFXTrack FootBubblesSound;
   /*!
   @brief Sound to play when in water and coverage equals 1.0 (fully underwater).

Note that unlike FootUnderwaterSound, this sound plays even if the player is not moving around in the water.

   
    */
   SFXTrack movingBubblesSound;
   /*!
   @brief Sound to play when in water and coverage equals 1.0 (fully underwater).

Note that unlike FootUnderwaterSound, this sound plays even if the player is not moving around in the water.

   
    */
   SFXTrack waterBreathSound;
   /*!
   @brief Sound to play after falling on a surface with Material footstepSoundId 0.


   
    */
   SFXTrack impactSoftSound;
   /*!
   @brief Sound to play after falling on a surface with Material footstepSoundId 1.


   
    */
   SFXTrack impactHardSound;
   /*!
   @brief Sound to play after falling on a surface with Material footstepSoundId 2.


   
    */
   SFXTrack impactMetalSound;
   /*!
   @brief Sound to play after falling on a surface with Material footstepSoundId 3.


   
    */
   SFXTrack impactSnowSound;
   /*!
   @brief Sound to play when entering the water with velocity < mediumSplashSoundVelocity.

@see mediumSplashSoundVelocity

   
    */
   SFXTrack impactWaterEasy;
   /*!
   @brief Sound to play when entering the water with velocity >= mediumSplashSoundVelocity and < hardSplashSoundVelocity.

@see mediumSplashSoundVelocity
@see hardSplashSoundVelocity

   
    */
   SFXTrack impactWaterMedium;
   /*!
   @brief Sound to play when entering the water with velocity >= hardSplashSoundVelocity.

@see hardSplashSoundVelocity

   
    */
   SFXTrack impactWaterHard;
   /*!
   @brief Sound to play when exiting the water with velocity >= exitSplashSoundVelocity.

@see exitSplashSoundVelocity

   
    */
   SFXTrack exitingWater;
   /*!
   @brief Sound to play when a flying AI's wings flap.

   
    */
   SFXTrack wingFlap;
   /*!
   @brief If true, this AI will begin it's talk sequence when clicked on.

   
    */
   bool hasClickAction;
   /// @}


   /*! @name Interaction: Splashes
   @{ */
   /*! */
   /*!
   @brief SplashData datablock used to create splashes when the player moves through water.


   
    */
   SplashData Splash;
   /*!
   @brief Minimum velocity when moving through water to generate splashes.


   
    */
   float splashVelocity;
   /*!
   @brief Maximum angle (in degrees) from pure vertical movement in water to generate splashes.


   
    */
   float splashAngle;
   /*!
   @brief Multipled by speed to determine the number of splash particles to generate.


   
    */
   float splashFreqMod;
   /*!
   @brief Minimum speed to generate splash particles.


   
    */
   float splashVelEpsilon;
   /*!
   @brief Time in seconds to generate bubble particles after entering the water.


   
    */
   float bubbleEmitTime;
   /*!
   @brief Particle emitters used to generate splash particles.


   
    */
   ParticleEmitterData splashEmitter;
   /*!
   @brief Water coverage level to choose between FootShallowSound and FootWadingSound.

@see FootShallowSound
@see FootWadingSound

   
    */
   float footstepSplashHeight;
   /*!
   @brief Minimum velocity when entering the water for choosing between the impactWaterEasy and impactWaterMedium sounds to play.

@see impactWaterEasy
@see impactWaterMedium

   
    */
   float mediumSplashSoundVelocity;
   /*!
   @brief Minimum velocity when entering the water for choosing between the impactWaterMedium and impactWaterHard sound to play.

@see impactWaterMedium
@see impactWaterHard

   
    */
   float hardSplashSoundVelocity;
   /*!
   @brief Minimum velocity when leaving the water for the exitingWater sound to play.

@see exitingWater
   
    */
   float exitSplashSoundVelocity;
   /// @}


   /*! @name Interaction: Ground Impact
   @{ */
   /*! */
   /*!
   @brief Minimum falling impact speed to apply damage and initiate the camera shaking effect.


   
    */
   float groundImpactMinSpeed;
   /*!
   @brief Frequency of the camera shake effect after falling.

This is how fast to shake the camera.

   
    */
   Point3F groundImpactShakeFreq;
   /*!
   @brief Amplitude of the camera shake effect after falling.

This is how much to shake the camera.

   
    */
   Point3F groundImpactShakeAmp;
   /*!
   @brief Duration (in seconds) of the camera shake effect after falling.

This is how long to shake the camera.

   
    */
   float groundImpactShakeDuration;
   /*!
   @brief Falloff factor of the camera shake effect after falling.

This is how to fade the camera shake over the duration.

   
    */
   float groundImpactShakeFalloff;
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /*!
   @brief Specifies the type of physics used by the player.

This depends on the physics module used.  An example is 'Capsule'.
@note Not current used.

   
    */
   string physicsPlayerType;
   /// @}


   /*! @name First Person Arms
   @{ */
   /*! */
   /*!
   @brief Optional prefix to all mounted image animation sequences in first person.

This defines a prefix that will be added when looking up mounted image animation sequences while in first person.  It allows for the customization of a first person image based on the type of player.

   
    */
   caseString imageAnimPrefixFP;
   /*!
   @brief File name of this player's shape that will be used in conjunction with the corresponding mounted image.

These optional parameters correspond to each mounted image slot to indicate a shape that is rendered in addition to the mounted image shape.  Typically these are a player's arms (or arm) that is animated along with the mounted image's state animation sequences.

   
    */
   filename shapeNameFP;
   /// @}


   /*! @name Third Person
   @{ */
   /*! */
   /*!
   @brief Optional prefix to all mounted image animation sequences in third person.

This defines a prefix that will be added when looking up mounted image animation sequences while in third person.  It allows for the customization of a third person image based on the type of player.

   
    */
   caseString imageAnimPrefix;
   /*!
   @brief Allow mounted images to request a sequence be played on the Player.

When true a new thread is added to the player to allow for mounted images to request a sequence be played on the player through the image's state machine.  It is only optional so that we don't create a TSThread on the player if we don't need to.

   
    */
   bool allowImageStateAnimation;
   /// @}


   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An object that represents an interior space.

A zone is an invisible volume that encloses an interior space.  All objects that have their world space axis-aligned bounding boxes (AABBs) intersect the zone's volume are assigned to the zone.  This assignment happens automatically as objects are placed and transformed.  Also, assignment is not exclusive meaning that an object can be assigned to many zones at the same time if it intersects all of them.

In itself, the volume of a zone is fully sealed off from the outside.  This means that while viewing the scene from inside the volume, only objects assigned to the zone are rendered while when viewing the scene from outside the volume, objects <em>exclusively</em> only assigned the zone are not rendered.

Usually, you will want to connect zones to each other by means of portals.  A portal overlapping with a zone 

@tsexample
// Example declaration of a Zone.  This creates a box-shaped zone.
new Zone( TestZone )
{
   position = "3.61793 -1.01945 14.7442";
   rotation = "1 0 0 0";
   scale = "10 10 10";
};
@endtsexample

@section Zone_zoneGroups Zone Groups

Normally, Zones will not connect to each other when they overlap.  This means that if viewing the scene from one zone, the contents of the other zone will not be visible except when there is a portal connecting the zones.  However, sometimes it is convenient to represent a single interior space through a combination of Zones so that when any of these zones is visible, all other zones that are part of the same interior space are visible.  This is possible by employing "zone groups".

@see Portal
@ingroup enviroMisc
 */
class  Zone : public SceneObject {
  public:
   /*! Get the unique numeric ID of the zone in its scene.

@return The ID of the zone. */
   virtual int getZoneId(()) {}
   /*! Dump a list of all objects assigned to the zone to the console as well as a list of all connected zone spaces.

@param updateFirst Whether to update the contents of the zone before dumping.  Since zoning states of objects are updated on demand, the zone contents can be outdated. */
   virtual void dumpZoneState(( bool updateFirst=true )) {}

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Ambient sound environment for the space.
   
    */
   SFXAmbience soundAmbience;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   For internal use only.
   
    */
   string plane;
   /*!
   For internal use only.
   
    */
   string point;
   /*!
   For internal use only.
   
    */
   string edge;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Whether to use #ambientLightColor for ambient lighting in this zone or the global ambient color.
   
    */
   bool useAmbientLightColor;
   /*!
   Color of ambient lighting in this zone.

Only used if #useAmbientLightColor is true.
   
    */
   ColorF ambientLightColor;
   /// @}


   /*! @name Zoning
   @{ */
   /*! */
   /*!
   ID of group the zone is part of.
   
    */
   int zoneGroup;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An object that provides a "window" into a zone, allowing a viewer to see what's rendered in the zone.

A portal is an object that connects zones such that the content of one zone becomes visible in the other when looking through the portal.

Each portal is a full zone which is divided into two sides by the portal plane that intersects it.  This intersection polygon is shown in red in the editor.  Either of the sides of a portal can be connected to one or more zones.

A connection from a specific portal side to a zone is made in either of two ways:

<ol>
<li>By moving a Zone object to intersect with the portal at the respective side.  While usually it makes sense for this overlap to be small, the connection is established correctly as long as the center of the Zone object that should connect is on the correct side of the portal plane.</li>
<li>By the respective side of the portal free of Zone objects that would connect to it.  In this case, given that the other side is connected to one or more Zones, the portal will automatically connect itself to the outdoor "zone" which implicitly is present in any level.</li>
</ol>

From this, it follows that there are two types of portals:

<dl>
<dt>Exterior Portals</dt><dd>An exterior portal is one that is connected to one or more Zone objects on one side and to the outdoor zone at the other side.  This kind of portal is most useful for covering transitions from outdoor spaces to indoor spaces.</dd><dt>Interior Portals</dt><dd>An interior portal is one that is connected to one or more Zone objects on both sides.  This kind of portal is most useful for covering transitions between indoor spaces./dd></dl>

Strictly speaking, there is a third type of portal called an "invalid portal".  This is a portal that is not connected to a Zone object on either side in which case the portal serves no use.

Portals in Torque are bidirectional meaning that they connect zones both ways and you can look through the portal's front side as well as through its back-side.

Like Zones, Portals can either be box-shaped or use custom convex polyhedral shapes.

Portals will usually be created in the editor but can, of course, also be created in script code as such:

@tsexample
// Example declaration of a Portal.  This will create a box-shaped portal.
new Portal( PortalToTestZone )
{
   position = "12.8467 -4.02246 14.8017";
^ rotation = "0 0 -1 97.5085";
^ scale = "1 0.25 1";
^ canSave = "1";
^ canSaveDynamicFields = "1";
};
@endtsexample

@note Keep in mind that zones and portals are more or less strictly a scene optimization mechanism meant to improve render times.

@see Zone
@ingroup enviroMisc
 */
class  Portal : public Zone {
  public:
   /*! Test whether the portal connects interior zones only.

@return True if the portal is an interior portal. */
   virtual bool isInteriorPortal(()) {}
   /*! Test whether the portal connects interior zones to the outdoor zone.

@return True if the portal is an exterior portal. */
   virtual bool isExteriorPortal(()) {}

   /*! @name Zoning
   @{ */
   /*! */
   /*!
   Whether one can view through the front-side of the portal.
   
    */
   bool frontSidePassable;
   /*!
   Whether one can view through the back-side of the portal.
   
    */
   bool backSidePassable;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Zoning
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A collection of arbitrary objects which can be allocated and manipulated as a group.

%Prefab always points to a (.prefab) file which defines its objects. In fact more than one %Prefab can reference this file and both will update if the file is modified.

%Prefab is a very simple object and only exists on the server. When it is created it allocates children objects by reading the (.prefab) file like a list of instructions.  It then sets their transform relative to the %Prefab and Torque networking handles the rest by ghosting the new objects to clients. %Prefab itself is not ghosted.

 */
class  Prefab : public SceneObject {
  public:
      /*! Called when the prefab file is loaded and children objects are created.
@param children SimGroup containing all children objects.
 */
      void onLoad( SimGroup  children );

   /*! Test whether the given simobject is a member of the prefab.
@param The simobject to test.
@return True if the Prefab contains the simobjct. */
   virtual bool isChild(( string obj )) {}

   /*! @name Prefab
   @{ */
   /*! */
   /*!
   (.prefab) File describing objects within this prefab.
   
    */
   filename fileName;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Stores common properties for a ProximityMine.

@see ProximityMine
@ingroup gameObjects
 */
class  ProximityMineData : public ItemData {
  public:
      /*! Callback invoked when an object triggers the ProximityMine.

@param obj The ProximityMine object
@param target The object that triggered the mine
@note This callback is only invoked on the server.
@see ProximityMine
 */
      void onTriggered( ProximityMine obj, SceneObject  target );

      /*! Callback invoked when a ProximityMine is about to explode.

@param obj The ProximityMine object
@param pos The position of the mine explosion
@note This callback is only invoked on the server.
@see ProximityMine
 */
      void onExplode( ProximityMine obj, Point3F pos );


   /*! @name Arming
   @{ */
   /*! */
   /*!
   Delay (in seconds) from when the mine is placed to when it becomes active.
   
    */
   float armingDelay;
   /*!
   Sound to play when the mine is armed (starts at the same time as the <i>armed</i> sequence if defined).
   
    */
   SFXTrack armingSound;
   /// @}


   /*! @name Triggering
   @{ */
   /*! */
   /*!
   @brief Delay (in seconds) from arming until the mine automatically triggers and explodes, even if no object has entered the trigger area.

Set to 0 to disable.
   
    */
   float autoTriggerDelay;
   /*!
   @brief Controls whether the mine can be triggered by the object that owns it.

For example, a player could deploy mines that are only dangerous to other players and not himself.
   
    */
   bool triggerOnOwner;
   /*!
   Distance at which an activated mine will detect other objects and explode.
   
    */
   float triggerRadius;
   /*!
   Speed above which moving objects within the trigger radius will trigger the mine
   
    */
   float triggerSpeed;
   /*!
   Delay (in seconds) from when the mine is triggered until it explodes.
   
    */
   float triggerDelay;
   /*!
   Sound to play when the mine is triggered (starts at the same time as the <i>triggered</i> sequence if defined).
   
    */
   SFXTrack triggerSound;
   /// @}


   /*! @name Explosion
   @{ */
   /*! */
   /*!
   @brief Offset from the mine's origin where the explosion emanates from.Sometimes a thrown mine may be slightly sunk into the ground.  This can be just enough to cause the explosion to occur under the ground, especially on flat ground, which can end up blocking the explosion.  This offset along the mine's 'up' normal allows you to raise the explosion origin to a better height.
   
    */
   float explosionOffset;
   /// @}


   /*! @name Shadows
   @{ */
   /*! */
   /// @}


   /*! @name Render
   @{ */
   /*! */
   /// @}


   /*! @name Destruction
   
   Parameters related to the destruction effects of this object.
   @{ */
   /*! */
   /// @}


   /*! @name Physics
   @{ */
   /*! */
   /// @}


   /*! @name Damage/Energy
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   
   The settings used by the shape when it is the camera.
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Reflection
   @{ */
   /*! */
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A simple proximity mine.

Proximity mines can be deployed using the world editor or thrown by an in-game object. Once armed, any Player or Vehicle object that moves within the mine's trigger area will cause it to explode.

Internally, the ProximityMine object transitions through the following states:
<ol>
  <li><b>Thrown</b>: Mine has been thrown, but has not yet attached to a surface</li>
  <li><b>Deployed</b>: Mine has attached to a surface but is not yet armed. Start playing the #armingSound and <i>armed</i> sequence.</li>
  <li><b>Armed</b>: Mine is armed and will trigger if a Vehicle or Player object moves within the trigger area.</li>
  <li><b>Triggered</b>: Mine has been triggered and will explode soon. Invoke the onTriggered callback, and start playing the #triggerSound and <i>triggered</i> sequence.</li>
  <li><b>Exploded</b>: Mine has exploded and will be deleted on the server shortly. Invoke the onExplode callback on the server and generate the explosion effects on the client.</li>
</ol>

@note Proximity mines with the #static field set to true will start in the <b>Armed</b> state. Use this for mines placed with the World Editor.

The shape used for the mine may optionally define the following sequences:
<dl>
  <dt>armed</dt><dd>Sequence to play when the mine is deployed, but before it becomes active and triggerable (#armingDelay should be set appropriately).</dd>
  <dt>triggered</dt><dd>Sequence to play when the mine is triggered, just before it explodes (#triggerDelay should be set appropriately).<dd>
</dl>

@tsexample
datablock ProximityMineData( SimpleMine )
{
   // ShapeBaseData fields
   category = "Weapon";
   shapeFile = "art/shapes/weapons/misc/proximityMine.dts";

   // ItemData fields
   sticky = true;

   // ProximityMineData fields
   armingDelay = 0.5;
   armingSound = MineArmedSound;

   autoTriggerDelay = 0;
   triggerOnOwner = true;
   triggerRadius = 5.0;
   triggerSpeed = 1.0;
   triggerDelay = 0.5;
   triggerSound = MineTriggeredSound;
   explosion = RocketLauncherExplosion;

   // dynamic fields
   pickUpName = "Proximity Mines";
   maxInventory = 20;

   damageType = "MineDamage"; // type of damage applied to objects in radius
   radiusDamage = 30;           // amount of damage to apply to objects in radius
   damageRadius = 8;            // search radius to damage objects when exploding
   areaImpulse = 2000;          // magnitude of impulse to apply to objects in radius
};

function ProximityMineData::onTriggered( %this, %obj, %target )
{
   echo( %this.name SPC "triggered by " @ %target.getClassName() );
}

function ProximityMineData::onExplode( %this, %obj, %position )
{
   // Damage objects within the mine's damage radius
   if ( %this.damageRadius > 0 )
      radiusDamage( %obj.sourceObject, %position, %this.damageRadius, %this.radiusDamage, %this.damageType, %this.areaImpulse );
}

function ProximityMineData::damage( %this, %obj, %position, %source, %amount, %damageType )
{
   // Explode if any damage is applied to the mine
   %obj.schedule(50 + getRandom(50), explode);
}

%obj = new ProximityMine()
{
   dataBlock = SimpleMine;
};
@endtsexample

@see ProximityMineData
@ingroup gameObjects
 */
class  ProximityMine : public Item {
  public:
   /*! @brief Manually cause the mine to explode.

 */
   virtual void explode(()) {}

   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Inventory
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The RigidShape class implements rigid-body physics for DTS objects in the world.

"Rigid body physics" refers to a system whereby objects are assumed to have a finite size,
equally distributed masses, and where deformations of the objects themselves are not accounted for.
Uses the RigidShape class to control its physics.

@tsexample
^datablock RigidShapeData( BouncingBoulder )
^{
^   category = "RigidShape";

^   shapeFile = "~/data/shapes/boulder/boulder.dts";
^   emap = true;

^   // Rigid Body
^   mass = 500;
^   massCenter = "0 0 0";    // Center of mass for rigid body
^   massBox = "0 0 0";         // Size of box used for moment of inertia,
^^^^^^^^  // if zero it defaults to object bounding box
^   drag = 0.2;                // Drag coefficient
^   bodyFriction = 0.2;
^   bodyRestitution = 0.1;
^   minImpactSpeed = 5;        // Impacts over this invoke the script callback
^   softImpactSpeed = 5;       // Play SoftImpact Sound
^   hardImpactSpeed = 15;      // Play HardImpact Sound
^   integration = 4;           // Physics integration: TickSec/Rate
^   collisionTol = 0.1;        // Collision distance tolerance
^   contactTol = 0.1;          // Contact velocity tolerance

^   minRollSpeed = 10;

^   maxDrag = 0.5;
^   minDrag = 0.01;

^   dustHeight = 10;

^   dragForce = 0.05;
^   vertFactor = 0.05;
^};

 new RigidShape()
^{
^^dataBlock = "BouncingBoulder";
^^parentGroup = EWCreatorWindow.objectGroup;
^};
@endtsexample

@see RigidShapeData
@see ShapeBase

@ingroup Platform
 */
class  RigidShape : public ShapeBase {
  public:
      /*! @brief Called whenever this RigidShape object enters liquid.

@param objId The ID of the rigidShape object.
@param waterCoverage Amount of water coverage the RigidShape has.
@param liquidType Type of liquid that was entered.

@tsexample
// The RigidShape object falls in a body of liquid, causing the callback to occur.
RigidShape::onEnterLiquid(%this,%objId,%waterCoverage,%liquidType)
^{
^^// Code to run whenever this callback occurs.
^}
@endtsexample

@see ShapeBase

 */
      void onEnterLiquid( string objId, string waterCoverage, string liquidType );

      /*! @brief Called whenever the RigidShape object exits liquid.

@param objId The ID of the RigidShape object.
@param liquidType Type if liquid that was exited.

@tsexample
// The RigidShape object exits in a body of liquid, causing the callback to occur.
RigidShape::onLeaveLiquid(%this,%objId,%liquidType)
^{
^^// Code to run whenever this callback occurs.
^}
@endtsexample

@see ShapeBase

 */
      void onLeaveLiquid( string objId, string liquidType );

   /*! @brief Clears physic forces from the shape and sets it at rest.

@tsexample
// Inform the RigidShape object to reset.
%thisRigidShape.reset();
@endtsexample

@see ShapeBaseData */
   virtual void reset(()) {}
   /*! @brief Enables or disables the physics simulation on the RigidShape object.

@param isFrozen Boolean frozen state to set the object.
@tsexample
// Define the frozen state.
%isFrozen = "true";

// Inform the object of the defined frozen state
%thisRigidShape.freezeSim(%isFrozen);
@endtsexample

@see ShapeBaseData */
   virtual void freezeSim(( bool isFrozen )) {}
   /*! @brief Forces the client to jump to the RigidShape's transform rather then warp to it.

 */
   virtual void forceClientTransform(()) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents geometry to be mounted to a ShapeBase object.

@ingroup gameObjects
 */
class  ShapeBaseImageData : public GameBaseData {
  public:
      /*! @brief Called when the Image is first mounted to the object.

@param obj object that this Image has been mounted to
@param slot Image mount slot on the object
@param dt time remaining in this Image update
 */
      void onMount( ShapeBase obj, int slot, float dt );

      /*! @brief Called when the Image is unmounted from the object.

@param obj object that this Image has been unmounted from
@param slot Image mount slot on the object
@param dt time remaining in this Image update
 */
      void onUnmount( ShapeBase obj, int slot, float dt );

   /*!
   @brief Whether to enable environment mapping on this Image.


   
    */
   bool emap;
   /*!
   @brief The DTS or DAE model to use for this Image.


   
    */
   filename shapeFile;
   /*!
   @brief The DTS or DAE model to use for this Image when in first person.

This is an optional parameter that also requires either eyeOffset or useEyeNode to be set.  If none of these conditions is met then shapeFile will be used for all cases.

Typically you set a first person image for a weapon that includes the player's arms attached to it for animating while firing, reloading, etc.  This is typical of many FPS games.@see eyeOffset
@see useEyeNode

   
    */
   filename shapeFileFP;
   /*!
   @brief Passed along to the mounting shape to modify animation sequences played in third person. [optional]


   
    */
   caseString imageAnimPrefix;
   /*!
   @brief Passed along to the mounting shape to modify animation sequences played in first person. [optional]


   
    */
   caseString imageAnimPrefixFP;
   /*!
   @brief Indicates that all shapes should be animated in sync.

When multiple shapes are defined for this image datablock, each of them are automatically animated in step with each other.  This allows for easy switching between between shapes when some other condition changes, such as going from first person to third person, and keeping their look consistent.  If you know that you'll never switch between shapes on the fly, such as players only being allowed in a first person view, then you could set this to false to save some calculations.

There are other circumstances internal to the engine that determine that only the current shape should be animated rather than all defined shapes.  In those cases, this property is ignored.

@note This property is only important if you have more than one shape defined, such as shapeFileFP.

@see shapeFileFP

   
    */
   bool animateAllShapes;
   /*!
   @brief Indicates that the image should be animated on the server.

In most cases you'll want this set if you're using useEyeNode.  You may also want to set this if the muzzlePoint is animated while it shoots.  You can set this to false even if these previous cases are true if the image's shape is set up in the correct position and orientation in the 'root' pose and none of the nodes are animated at key times, such as the muzzlePoint essentially remaining at the same position at the start of the fire state (it could animate just fine after the projectile is away as the muzzle vector is only calculated at the start of the state).

You'll also want to set this to true if you're animating the camera using the image's 'eye' node -- unless the movement is very subtle and doesn't need to be reflected on the server.

@note Setting this to true causes up to four animation threads to be advanced on the server for each instance in use, although for most images only one or two are actually defined.

@see useEyeNode

   
    */
   bool animateOnServer;
   /*!
   @brief The amount of time to transition between the previous sequence and new sequence when the script prefix has changed.

When setImageScriptAnimPrefix() is used on a ShapeBase that has this image mounted, the image will attempt to switch to the new animation sequence based on the given script prefix.  This is the amount of time it takes to transition from the previously playing animation sequence tothe new script prefix-based animation sequence.
@see ShapeBase::setImageScriptAnimPrefix()
   
    */
   float scriptAnimTransitionTime;
   /*!
   @brief The projectile fired by this Image


   
    */
   ProjectileData Projectile;
   /*!
   @brief Whether this Image can be cloaked.

Currently unused.
   
    */
   bool cloakable;
   /*!
   @brief Mount node # to mount this Image to.

This should correspond to a mount# node on the ShapeBase derived object we are mounting to.
   
    */
   int mountPoint;
   /*!
   @brief "X Y Z" translation offset from this Image's <i>mountPoint</i> node to attach to.

Defaults to "0 0 0". ie. attach this Image's <i>mountPoint</i> node to the ShapeBase model's mount# node without any offset.
@see rotation
   
    */
   MatrixPosition offset;
   /*!
   @brief "X Y Z ANGLE" rotation offset from this Image's <i>mountPoint</i> node to attach to.

Defaults to "0 0 0". ie. attach this Image's <i>mountPoint</i> node to the ShapeBase model's mount# node without any additional rotation.
@see offset
   
    */
   MatrixRotation rotation;
   /*!
   @brief "X Y Z" translation offset from the ShapeBase model's eye node.

When in first person view, this is the offset from the eye node to place the gun.  This gives the gun a fixed point in space, typical of a lot of FPS games.
@see eyeRotation
   
    */
   MatrixPosition eyeOffset;
   /*!
   @brief "X Y Z ANGLE" rotation offset from the ShapeBase model's eye node.

When in first person view, this is the rotation from the eye node to place the gun.
@see eyeOffset
   
    */
   MatrixRotation eyeRotation;
   /*!
   @brief Mount image using image's eyeMount node and place the camera at the image's eye node (or at the eyeMount node if the eye node is missing).

When in first person view, if an 'eyeMount' node is present in the image's shape, this indicates that the image should mount eyeMount node to Player eye node for image placement.  The Player's camera should also mount to the image's eye node to inherit any animation (or the eyeMount node if the image doesn't have an eye node).

@note Used instead of eyeOffset.

@note Read about the animateOnServer field as you may want to set it to true if you're using useEyeNode.

@see eyeOffset

@see animateOnServer


   
    */
   bool useEyeNode;
   /*!
   @brief Flag to adjust the aiming vector to the eye's LOS point when in 1st person view.

@see ShapeBase::getMuzzleVector()
   
    */
   bool correctMuzzleVector;
   /*!
   @brief Flag to adjust the aiming vector to the camera's LOS point when in 3rd person view.

@see ShapeBase::getMuzzleVector()
   
    */
   bool correctMuzzleVectorTP;
   /*!
   @brief Set to true to render the image in first person.
   
    */
   bool firstPerson;
   /*!
   @brief Mass of this Image.

This is added to the total mass of the ShapeBase object.
   
    */
   float mass;
   /*!
   @brief Flag indicating whether this Image uses energy instead of ammo.  The energy level comes from the ShapeBase object we're mounted to.

@see ShapeBase::setEnergyLevel()
   
    */
   bool usesEnergy;
   /*!
   @brief Minimum Image energy for it to be operable.

@see usesEnergy
   
    */
   float minEnergy;
   /*!
   @brief Flag to control whether the Image's aim is automatically converged with the crosshair.

Currently unused.
   
    */
   bool accuFire;
   /*!
   @brief The type of light this Image emits.

@see ShapeBaseImageLightType
   
    */
   ShapeBaseImageLightType lightType;
   /*!
   @brief The color of light this Image emits.

@see lightType
   
    */
   ColorF lightColor;
   /*!
   @brief Duration in SimTime of Pulsing and WeaponFire type lights.

@see lightType
   
    */
   int lightDuration;
   /*!
   @brief Radius of the light this Image emits.

@see lightType
   
    */
   float lightRadius;
   /*!
   @brief Brightness of the light this Image emits.

Only valid for WeaponFireLight.@see lightType
   
    */
   float lightBrightness;
   /*!
   @brief Flag indicating whether the camera should shake when this Image fires.

@note Camera shake only works properly if the player is in control of the one and only shapeBase object in the scene which fires an Image that uses camera shake.
   
    */
   bool shakeCamera;
   /*!
   @brief Frequency of the camera shaking effect.

@see shakeCamera
   
    */
   Point3F camShakeFreq;
   /*!
   @brief Amplitude of the camera shaking effect.

@see shakeCamera
   
    */
   Point3F camShakeAmp;
   /*!
   @brief DebrisData datablock to use for ejected casings.

@see stateEjectShell
   
    */
   DebrisData casing;
   /*!
   @brief Vector direction to eject shell casings.

@see casing
   
    */
   Point3F shellExitDir;
   /*!
   @brief Variance (in degrees) from the shellExitDir vector to eject casings.

@see shellExitDir
   
    */
   float shellExitVariance;
   /*!
   @brief Speed at which to eject casings.

@see casing
   
    */
   float shellVelocity;
   /*!
   Name of this state.
   
    */
   caseString stateName;
   /*!
   Name of the state to transition to when the loaded state of the Image changes to 'Loaded'.
   
    */
   string stateTransitionOnLoaded;
   /*!
   Name of the state to transition to when the loaded state of the Image changes to 'Empty'.
   
    */
   string stateTransitionOnNotLoaded;
   /*!
   Name of the state to transition to when the ammo state of the Image changes to true.
   
    */
   string stateTransitionOnAmmo;
   /*!
   Name of the state to transition to when the ammo state of the Image changes to false.
   
    */
   string stateTransitionOnNoAmmo;
   /*!
   Name of the state to transition to when the Image gains a target.
   
    */
   string stateTransitionOnTarget;
   /*!
   Name of the state to transition to when the Image loses a target.
   
    */
   string stateTransitionOnNoTarget;
   /*!
   Name of the state to transition to when the Image enters the water.
   
    */
   string stateTransitionOnWet;
   /*!
   Name of the state to transition to when the Image exits the water.
   
    */
   string stateTransitionOnNotWet;
   /*!
   Name of the state to transition to when the Player moves.
   
    */
   string stateTransitionOnMotion;
   /*!
   Name of the state to transition to when the Player stops moving.
   
    */
   string stateTransitionOnNoMotion;
   /*!
   Name of the state to transition to when the trigger state of the Image changes to true (fire button down).
   
    */
   string stateTransitionOnTriggerUp;
   /*!
   Name of the state to transition to when the trigger state of the Image changes to false (fire button released).
   
    */
   string stateTransitionOnTriggerDown;
   /*!
   Name of the state to transition to when the alt trigger state of the Image changes to true (alt fire button down).
   
    */
   string stateTransitionOnAltTriggerUp;
   /*!
   Name of the state to transition to when the alt trigger state of the Image changes to false (alt fire button up).
   
    */
   string stateTransitionOnAltTriggerDown;
   /*!
   Name of the state to transition to when we have been in this state for stateTimeoutValue seconds.
   
    */
   string stateTransitionOnTimeout;
   /*!
   Name of the state to transition to when the generic trigger 0 state changes to true.
   
    */
   string stateTransitionGeneric0In;
   /*!
   Name of the state to transition to when the generic trigger 0 state changes to false.
   
    */
   string stateTransitionGeneric0Out;
   /*!
   Name of the state to transition to when the generic trigger 1 state changes to true.
   
    */
   string stateTransitionGeneric1In;
   /*!
   Name of the state to transition to when the generic trigger 1 state changes to false.
   
    */
   string stateTransitionGeneric1Out;
   /*!
   Name of the state to transition to when the generic trigger 2 state changes to true.
   
    */
   string stateTransitionGeneric2In;
   /*!
   Name of the state to transition to when the generic trigger 2 state changes to false.
   
    */
   string stateTransitionGeneric2Out;
   /*!
   Name of the state to transition to when the generic trigger 3 state changes to true.
   
    */
   string stateTransitionGeneric3In;
   /*!
   Name of the state to transition to when the generic trigger 3 state changes to false.
   
    */
   string stateTransitionGeneric3Out;
   /*!
   Time in seconds to wait before transitioning to stateTransitionOnTimeout.
   
    */
   float stateTimeoutValue;
   /*!
   If false, this state ignores stateTimeoutValue and transitions immediately if other transition conditions are met.
   
    */
   bool stateWaitForTimeout;
   /*!
   The first state with this set to true is the state entered by the client when it receives the 'fire' event.
   
    */
   bool stateFire;
   /*!
   The first state with this set to true is the state entered by the client when it receives the 'altFire' event.
   
    */
   bool stateAlternateFire;
   /*!
   The first state with this set to true is the state entered by the client when it receives the 'reload' event.
   
    */
   bool stateReload;
   /*!
   If true, a shell casing will be ejected in this state.
   
    */
   bool stateEjectShell;
   /*!
   @brief Amount of energy to subtract from the Image in this state.

Energy is drained at stateEnergyDrain units/tick as long as we are in this state.
@see usesEnergy
   
    */
   float stateEnergyDrain;
   /*!
   @brief If false, other Images will temporarily be blocked from mounting while the state machine is executing the tasks in this state.

For instance, if we have a rocket launcher, the player shouldn't be able to switch out <i>while</i> firing. So, you'd set stateAllowImageChange to false in firing states, and true the rest of the time.
   
    */
   bool stateAllowImageChange;
   /*!
   @brief Direction of the animation to play in this state.

True is forward, false is backward.
   
    */
   bool stateDirection;
   /*!
   @brief Set the loaded state of the Image.

<ul><li>IgnoreLoaded: Don't change Image loaded state.</li><li>Loaded: Set Image loaded state to true.</li><li>NotLoaded: Set Image loaded state to false.</li></ul>
@see ShapeBaseImageLoadedState
   
    */
   ShapeBaseImageLoadedState stateLoadedFlag;
   /*!
   @brief Controls how fast the 'spin' animation sequence will be played in this state.

<ul><li>Ignore: No change to the spin sequence.</li><li>Stop: Stops the spin sequence at its current position.</li><li>SpinUp: Increase spin sequence timeScale from 0 (on state entry) to 1 (after stateTimeoutValue seconds).</li><li>SpinDown: Decrease spin sequence timeScale from 1 (on state entry) to 0 (after stateTimeoutValue seconds).</li><li>FullSpeed: Resume the spin sequence playback at its current position with timeScale=1.</li></ul>
@see ShapeBaseImageSpinState
   
    */
   ShapeBaseImageSpinState stateSpinThread;
   /*!
   @brief Type of recoil sequence to play on the ShapeBase object on entry to this state.

<ul><li>NoRecoil: Do not play a recoil sequence.</li><li>LightRecoil: Play the light_recoil sequence.</li><li>MediumRecoil: Play the medium_recoil sequence.</li><li>HeavyRecoil: Play the heavy_recoil sequence.</li></ul>
@see ShapeBaseImageRecoilState
   
    */
   ShapeBaseImageRecoilState stateRecoil;
   /*!
   Name of the sequence to play on entry to this state.
   
    */
   string stateSequence;
   /*!
   @brief If true, the muzzle flash sequence will be played while in this state.

The name of the muzzle flash sequence is the same as stateSequence, with "_vis" at the end.
   
    */
   bool stateSequenceRandomFlash;
   /*!
   If true, the timeScale of the stateSequence animation will be adjusted such that the sequence plays for stateTimeoutValue seconds. 
   
    */
   bool stateScaleAnimation;
   /*!
   If true, the timeScale of the first person stateSequence animation will be adjusted such that the sequence plays for stateTimeoutValue seconds. 
   
    */
   bool stateScaleAnimationFP;
   /*!
   Do we transition to the state's sequence when we enter the state?
   
    */
   bool stateSequenceTransitionIn;
   /*!
   Do we transition to the new state's sequence when we leave the state?
   
    */
   bool stateSequenceTransitionOut;
   /*!
   Never allow a transition to this sequence.  Often used for a fire sequence.
   
    */
   bool stateSequenceNeverTransition;
   /*!
   The time to transition in or out of a sequence.
   
    */
   float stateSequenceTransitionTime;
   /*!
   Name of the sequence that is played on the mounting shape.
   
    */
   string stateShapeSequence;
   /*!
   Indicates if the sequence to be played on the mounting shape should be scaled to the length of the state.
   
    */
   bool stateScaleShapeSequence;
   /*!
   Sound to play on entry to this state.
   
    */
   SFXTrack stateSound;
   /*!
   @brief Method to execute on entering this state.

Scoped to this image class name, then ShapeBaseImageData. The script callback function takes the same arguments as the onMount callback.
@see onMount() for the same arguments as this callback.
   
    */
   caseString stateScript;
   /*!
   @brief Emitter to generate particles in this state (from muzzle point or specified node).

@see stateEmitterNode
   
    */
   ParticleEmitterData stateEmitter;
   /*!
   How long (in seconds) to emit particles on entry to this state.
   
    */
   float stateEmitterTime;
   /*!
   @brief Name of the node to emit particles from.

@see stateEmitter
   
    */
   string stateEmitterNode;
   /*!
   @brief If set to true, and both ready and loaded transitions are true, the ready transition will be taken instead of the loaded transition.

A state is 'ready' if pressing the fire trigger in that state would transition to the fire state.
   
    */
   bool stateIgnoreLoadedForReady;
   /*!
   If true, verify that the CRC of the client's Image matches the server's CRC for the Image when loaded by the client.
   
    */
   bool computeCRC;
   /*!
   @brief Maximum number of sounds this Image can play at a time.

Any value <= 0 indicates that it can play an infinite number of sounds.
   
    */
   int maxConcurrentSounds;
   /*!
   @brief If true, allow multiple timeout transitions to occur within a single tick (useful if states have a very small timeout).


   
    */
   bool useRemainderDT;
   /*!
    */
   Point3F scale;

   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines shared properties for Trigger objects.

The primary focus of the TriggerData datablock is the callbacks it provides when an object is within or leaves the Trigger bounds.
@see Trigger.
@ingroup gameObjects
@ingroup Datablocks
 */
class  TriggerData : public GameBaseData {
  public:
      /*! @brief Called when an object enters the volume of the Trigger instance using this TriggerData.

@param trigger the Trigger instance whose volume the object entered
@param obj the object that entered the volume of the Trigger instance
 */
      void onEnterTrigger( Trigger trigger, GameBase obj );

      /*! @brief Called every tickPeriodMS number of milliseconds (as specified in the TriggerData) whenever one or more objects are inside the volume of the trigger.

The Trigger has methods to retrieve the objects that are within the Trigger's bounds if you want to do something with them in this callback.
@param trigger the Trigger instance whose volume the object is inside
@see tickPeriodMS
@see Trigger::getNumObjects()
@see Trigger::getObject()
 */
      void onTickTrigger( Trigger trigger );

      /*! @brief Called when an object leaves the volume of the Trigger instance using this TriggerData.

@param trigger the Trigger instance whose volume the object left
@param obj the object that left the volume of the Trigger instance
 */
      void onLeaveTrigger( Trigger trigger, GameBase obj );


   /*! @name Callbacks
   @{ */
   /*! */
   /*!
   @brief Time in milliseconds between calls to onTickTrigger() while at least one object is within a Trigger's bounds.

@see onTickTrigger()

   
    */
   int tickPeriodMS;
   /*!
   Forces Trigger callbacks to only be called on clients.
   
    */
   bool clientSide;
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A Trigger is a volume of space that initiates script callbacks when objects pass through the Trigger.

TriggerData provides the callbacks for the Trigger when an object enters, stays inside or leaves the Trigger's volume.

@see TriggerData
@ingroup gameObjects
 */
class  Trigger : public GameBase {
  public:
      /*! @brief Called when the Trigger is being created.

@param objectId the object id of the Trigger being created
 */
      void onAdd( int objectId );

      /*! @brief Called just before the Trigger is deleted.

@param objectId the object id of the Trigger being deleted
 */
      void onRemove( int objectId );

   /*! @brief Get the number of objects that are within the Trigger's bounds.

@see getObject()
 */
   virtual int getNumObjects(()) {}
   /*! @brief Retrieve the requested object that is within the Trigger's bounds.

@param index Index of the object to get (range is 0 to getNumObjects()-1)
@returns The SimObjectID of the object, or -1 if the requested index is invalid.
@see getNumObjects()
 */
   virtual int getObject(( int index )) {}
   /*!
   @brief Defines a non-rectangular area for the trigger.

Rather than the standard rectangular bounds, this optional parameter defines a quadrilateral trigger area.  The quadrilateral is defined as a corner point followed by three vectors representing the edges extending from the corner.

   
    */
   floatList polyhedron;
   /*!
   The command to execute when an object enters this trigger. Object id stored in %%obj. Maximum 1023 characters.
   
    */
   string enterCommand;
   /*!
   The command to execute when an object leaves this trigger. Object id stored in %%obj. Maximum 1023 characters.
   
    */
   string leaveCommand;
   /*!
   The command to execute while an object is inside this trigger. Maximum 1023 characters.
   
    */
   string tickCommand;

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A datablock describing an individual decal.

The textures defined by the decal Material can be divided into multiple rectangular sub-textures as shown below, with a different sub-texture selected by all decals using the same DecalData (via #frame) or each decal instance (via #randomize).
@image html images/decal_example.png "Example of a Decal imagemap"
@tsexample
datablock DecalData(BulletHoleDecal)
{
   material = "DECAL_BulletHole";
   size = "5.0";
   lifeSpan = "50000";
   randomize = "1";
   texRows = "2";
   texCols = "2";
   clippingAngle = "60";
};
@endtsexample

@see Decals
@ingroup Decals
@ingroup FX
 */
class  DecalData : public SimDataBlock {
  public:
   /*! Recompute the imagemap sub-texture rectangles for this DecalData.
@tsexample
// Inform the decal object to reload its imagemap and frame data.
%decalData.texRows = 4;
%decalData.postApply();
@endtsexample
 */
   virtual void postApply(()) {}

   /*! @name Decal
   @{ */
   /*! */
   /*!
   Width and height of the decal in meters before scale is applied.
   
    */
   float size;
   /*!
   Material to use for this decal.
   
    */
   string Material;
   /*!
   Time (in milliseconds) before this decal will be automatically deleted.
   
    */
   int lifeSpan;
   /*!
   @brief Time (in milliseconds) over which to fade out the decal before deleting it at the end of its lifetime.

@see lifeSpan
   
    */
   int fadeTime;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   @brief LOD value - size in pixels at which decals of this type begin to fade out.

This should be a larger value than #fadeEndPixelSize. However, you may also set this to a negative value to disable lod-based fading.
   
    */
   float fadeStartPixelSize;
   /*!
   @brief LOD value - size in pixels at which decals of this type are fully faded out.

This should be a smaller value than #fadeStartPixelSize.
   
    */
   float fadeEndPixelSize;
   /*!
   Default renderPriority for decals of this type (determines draw order when decals overlap).
   
    */
   char renderPriority;
   /*!
   The angle in degrees used to clip geometry that faces away from the decal projection direction.
   
    */
   float clippingAngle;
   /// @}


   /*! @name Texturing
   @{ */
   /*! */
   /*!
   Index of the texture rectangle within the imagemap to use for this decal.
   
    */
   int frame;
   /*!
   If true, a random frame from the imagemap is selected for each instance of the decal.
   
    */
   bool randomize;
   /*!
   Number of individual frames in the imagemap (maximum 16).
   
    */
   int textureCoordCount;
   /*!
   @brief Number of rows in the supplied imagemap.

Use #texRows and #texCols if the imagemap frames are arranged in a grid; use #textureCoords to manually specify UV coordinates for irregular sized frames.
   
    */
   int texRows;
   /*!
   @brief Number of columns in the supplied imagemap.

Use #texRows and #texCols if the imagemap frames are arranged in a grid; use #textureCoords to manually specify UV coordinates for irregular sized frames.
   
    */
   int texCols;
   /*!
   @brief An array of RectFs (topleft.x topleft.y extent.x extent.y) representing the UV coordinates for each frame in the imagemap.

@note This field should only be set if the imagemap frames are irregular in size. Otherwise use the #texRows and #texCols fields and the UV coordinates will be calculated automatically.
   
    */
   RectF textureCoords;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An example scene object which renders a mesh.

This class implements a basic SceneObject that can exist in the world at a 3D position and render itself. There are several valid ways to render an object in Torque. This class implements the preferred rendering method which is to submit a MeshRenderInst along with a Material, vertex buffer, primitive buffer, and transform and allow the RenderMeshMgr handle the actual setup and rendering for you.

See the C++ code for implementation details.

@ingroup Examples
 */
class  RenderMeshExample : public SceneObject {
  public:
   /*! A utility method for forcing a network update.
 */
   virtual void postApply(()) {}

   /*! @name Rendering
   @{ */
   /*! */
   /*!
   The name of the material used to render the mesh.
   
    */
   string Material;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Basic HUD clock. Displays the current simulation time offset from some base.
@tsexample

 new GuiClockHud(){
^fillColor = "0.0 1.0 0.0 1.0"; // Fills with a solid green color
^frameColor = "1.0 1.0 1.0 1.0"; // Solid white frame color
^textColor = "1.0 1.0 1.0 1.0"; // Solid white text Color
^showFill = "true";
^showFrame = "true";
};
@endtsexample

@ingroup GuiGame
 */
class  GuiClockHud : public GuiControl {
  public:
   /*! Sets the current base time for the clock.
@param timeInSeconds Time to set the clock, in seconds (IE: 00:02 would be 120)
@tsexample
// Define the time, in seconds
%timeInSeconds = 120;

// Change the time on the GuiClockHud control
%guiClockHud.setTime(%timeInSeconds);
@endtsexample
 */
   virtual void setTime(( float timeInSeconds=60 )) {}
   /*! @brief Sets a time for a countdown clock.

Setting the time like this will cause the clock to count backwards from the specified time.

@param timeInSeconds Time to set the clock, in seconds (IE: 00:02 would be 120)

@see setTime
 */
   virtual void setReverseTime(( float timeInSeconds=60 )) {}
   /*! Returns the current time, in seconds.
@return timeInseconds Current time, in seconds
@tsexample
// Get the current time from the GuiClockHud control
%timeInSeconds = %guiClockHud.getTime();
@endtsexample
 */
   virtual float getTime(()) {}

   /*! @name Misc
   @{ */
   /*! */
   /*!
   If true, draws a background color behind the control.
   
    */
   bool showFill;
   /*!
   If true, draws a frame around the control.
   
    */
   bool showFrame;
   /*!
   Standard color for the background of the control.
   
    */
   ColorF fillColor;
   /*!
   Color for the control's frame.
   
    */
   ColorF frameColor;
   /*!
   Color for the text on this control.
   
    */
   ColorF textColor;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An emitter for lightning bolts.

Lightning strike events are created on the server and transmitted to all clients to render the bolt. The strike may be followed by a random thunder sound. Player or Vehicle objects within the Lightning strike range can be hit and damaged by bolts.
@see LightningData
@ingroup FX
@ingroup Atmosphere
 */
class  Lightning : public GameBase {
  public:
      /*! Informs an object that it was hit by a lightning bolt and needs to take damage.
@param hitPosition World position hit by the lightning bolt.
@param hitNormal Surface normal at @a hitPosition.
@param hitObject Player or Vehicle object that was hit.
@tsexample
function Lightning::applyDamage( %this, %hitPosition, %hitNormal, %hitObject )
{
   // apply damage to the player
   %hitObject.applyDamage( 25 );
}
@endtsexample
 */
      void applyDamage( Point3F hitPosition, Point3F hitNormal, SceneObject hitObject );

   /*! @brief Creates a LightningStrikeEvent that triggers harmless lightning bolts on all clients.
No objects will be damaged by these bolts.
@tsexample
// Generate a harmless lightning strike effect on all clients
%lightning.warningFlashes();
@endtsexample */
   virtual void warningFlashes(()) {}
   /*! Creates a LightningStrikeEvent which attempts to strike and damage a random object in range of the Lightning object.
@tsexample
// Generate a damaging lightning strike effect on all clients
%lightning.strikeRandomPoint();
@endtsexample */
   virtual void strikeRandomPoint(()) {}
   /*! Creates a LightningStrikeEvent which strikes a specific object.
@note This method is currently unimplemented.
 */
   virtual void strikeObject(( int id=NULL )) {}

   /*! @name Strikes
   @{ */
   /*! */
   /*!
   @brief Number of lightning strikes to perform per minute.

Automatically invokes strikeRandomPoint() at regular intervals.
   
    */
   int strikesPerMinute;
   /*!
   Width of a lightning bolt.
   
    */
   float strikeWidth;
   /*!
   @brief Horizontal size (XY plane) of the search box used to find and damage Player or Vehicle objects within range of the strike.

Only the object at highest altitude with a clear line of sight to the bolt will be hit.
   
    */
   float strikeRadius;
   /// @}


   /*! @name Colors
   @{ */
   /*! */
   /*!
   Color to blend the strike texture with.
   
    */
   ColorF color;
   /*!
   @brief Color to blend the strike texture with when the bolt is fading away.

Bolts fade away automatically shortly after the strike occurs.
   
    */
   ColorF fadeColor;
   /// @}


   /*! @name Bolts
   @{ */
   /*! */
   /*!
   Percentage chance (0-1) that a given lightning bolt will hit something.
   
    */
   float chanceToHitTarget;
   /*!
   @brief Radial distance from the center of the Lightning object for the start point of the bolt.

The actual start point will be a random point within this radius.
   
    */
   float boltStartRadius;
   /*!
   Controls whether lightning bolts are affected by fog when they are rendered.
   
    */
   bool useFog;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  ParticleData {
  public:
   /*! Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue( %propertyField, %value );

// Reload it
%particle.reload();
@endtsexample
 */
   virtual void reload(()) {}
};

class  ParticleEmitterNode : public GameBase {
  public:
   /*! @brief Mount objB to this object at the desired slot with optional transform.

@param objB  Object to mount onto us
@param slot  Mount slot ID
@param txfm (optional) mount offset transform
@return true if successful, false if failed (objB is not valid) */
   virtual bool mountToNode(( SceneObject objB, StringTableEntry node, TransformF txfm=MatrixF::Identity )) {}
   /*! Turns the emitter on or off.
@param active New emitter state
 */
   virtual void setActive(( bool active )) {}
   /*! Assigns the datablock for this emitter node.
@param emitterDatablock ParticleEmitterData datablock to assign
@tsexample
// Assign a new emitter datablock
%emitter.setEmitterDatablock( %emitterDatablock );
@endtsexample
 */
   virtual void setEmitterDataBlock(( ParticleEmitterData emitterDatablock=0 )) {}
   virtual string getEmitter(()) {}
   virtual void addParticleBehaviour(( IParticleBehaviour bhv=NULL, bool overrideLast=false )) {}
   /*!
   Controls whether particles are emitted from this node.
   
    */
   bool active;
   /*!
   Velocity to use when emitting particles (in the direction of the ParticleEmitterNode object's up (Z) axis).
   
    */
   float velocity;
   /*!
   Datablock to use when emitting particles.
   
    */
   ParticleEmitterData emitter;

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines a precipitation based storm (rain, snow, etc).

The Precipitation effect works by creating many 'drops' within a fixed size box. This box can be configured to move around with the camera (to simulate level-wide precipitation), or to remain in a fixed position (to simulate localized precipitation). When #followCam is true, the box containing the droplets can be thought of as centered on the camera then pushed slightly forward in the direction the camera is facing so most of the box is in front of the camera (allowing more drops to be visible on screen at once).

The effect can also be configured to create a small 'splash' whenever a drop hits another world object.

@tsexample
// The following is added to a level file (.mis) by the World Editor
new Precipitation( TheRain )
{
   dropSize = "0.5";
   splashSize = "0.5";
   splashMS = "250";
   animateSplashes = "1";
   dropAnimateMS = "0";
   fadeDist = "0";
   fadeDistEnd = "0";
   useTrueBillboards = "0";
   useLighting = "0";
   glowIntensity = "0 0 0 0";
   reflect = "0";
   rotateWithCamVel = "1";
   doCollision = "1";
   hitPlayers = "0";
   hitVehicles = "0";
   followCam = "1";
   useWind = "0";
   minSpeed = "1.5";
   maxSpeed = "2";
   minMass = "0.75";
   maxMass = "0.85";
   useTurbulence = "0";
   maxTurbulence = "0.1";
   turbulenceSpeed = "0.2";
   numDrops = "1024";
   boxWidth = "200";
   boxHeight = "100";
   dataBlock = "HeavyRain";
};
@endtsexample
@ingroup FX
@ingroup Atmosphere
@see PrecipitationData
 */
class  Precipitation : public GameBase {
  public:
   /*! Sets the maximum number of drops in the effect, as a percentage of #numDrops.
The change occurs instantly (use modifyStorm() to change the number of drops over a period of time.
@param percentage New maximum number of drops value (as a percentage of #numDrops). Valid range is 0-1.
@tsexample
%percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
%precipitation.setPercentage( %percentage );
@endtsexample
@see modifyStorm
 */
   virtual void setPercentage(( float percentage=1.0f )) {}
   /*! Smoothly change the maximum number of drops in the effect (from current value to #numDrops * @a percentage).
This method can be used to simulate a storm building or fading in intensity as the number of drops in the Precipitation box changes.
@param percentage New maximum number of drops value (as a percentage of #numDrops). Valid range is 0-1.
@param seconds Length of time (in seconds) over which to increase the drops percentage value. Set to 0 to change instantly.
@tsexample
%percentage = 0.5;  // The percentage, from 0 to 1, of the maximum drops to display
%seconds = 5.0;     // The length of time over which to make the change.
%precipitation.modifyStorm( %percentage, %seconds );
@endtsexample
 */
   virtual void modifyStorm(( float percentage=1.0f, float seconds=5.0f )) {}
   /*! Smoothly change the turbulence parameters over a period of time.
@param max New #maxTurbulence value. Set to 0 to disable turbulence.
@param speed New #turbulenceSpeed value.
@param seconds Length of time (in seconds) over which to interpolate the turbulence settings. Set to 0 to change instantly.
@tsexample
%turbulence = 0.5;     // Set the new turbulence value. Set to 0 to disable turbulence.
%speed = 5.0;          // The new speed of the turbulance effect.
%seconds = 5.0;        // The length of time over which to make the change.
%precipitation.setTurbulence( %turbulence, %speed, %seconds );
@endtsexample
 */
   virtual void setTurbulence(( float max=1.0f, float speed=5.0f, float seconds=5.0 )) {}

   /*! @name Precipitation
   @{ */
   /*! */
   /*!
   @brief Maximum number of drops allowed to exist in the precipitation box at any one time.

The actual number of drops in the effect depends on the current percentage, which can change over time using modifyStorm().
   
    */
   int numDrops;
   /*!
   Width and depth (horizontal dimensions) of the precipitation box.
   
    */
   float boxWidth;
   /*!
   Height (vertical dimension) of the precipitation box.
   
    */
   float boxHeight;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   Size of each drop of precipitation. This will scale the texture.
   
    */
   float dropSize;
   /*!
   Size of each splash animation when a drop collides with another surface.
   
    */
   float splashSize;
   /*!
   Lifetime of splashes in milliseconds.
   
    */
   int splashMS;
   /*!
   Set to true to enable splash animations when drops collide with other surfaces.
   
    */
   bool animateSplashes;
   /*!
   @brief Length (in milliseconds) to display each drop frame.

If #dropAnimateMS <= 0, drops select a single random frame at creation that does not change throughout the drop's lifetime. If #dropAnimateMS > 0, each drop cycles through the the available frames in the drop texture at the given rate.
   
    */
   int dropAnimateMS;
   /*!
   The distance at which drops begin to fade out.
   
    */
   float fadeDist;
   /*!
   The distance at which drops are completely faded out.
   
    */
   float fadeDistEnd;
   /*!
   Set to true to make drops true (non axis-aligned) billboards.
   
    */
   bool useTrueBillboards;
   /*!
   Set to true to enable shading of the drops and splashes by the sun color.
   
    */
   bool useLighting;
   /*!
   Set to 0 to disable the glow or or use it to control the intensity of each channel.
   
    */
   ColorF glowIntensity;
   /*!
   @brief This enables precipitation rendering during reflection passes.

@note This is expensive.
   
    */
   bool reflect;
   /*!
   Set to true to include the camera velocity when calculating drop rotation speed.
   
    */
   bool rotateWithCamVel;
   /// @}


   /*! @name Collision
   @{ */
   /*! */
   /*!
   @brief Allow drops to collide with world objects.

If #animateSplashes is true, drops that collide with another object will produce a simple splash animation.
@note This can be expensive as each drop will perform a raycast when it is created to determine where it will hit.
   
    */
   bool doCollision;
   /*!
   Allow drops to collide with Player objects; only valid if #doCollision is true.
   
    */
   bool hitPlayers;
   /*!
   Allow drops to collide with Vehicle objects; only valid if #doCollision is true.
   
    */
   bool hitVehicles;
   /// @}


   /*! @name Movement
   @{ */
   /*! */
   /*!
   @brief Controls whether the Precipitation system follows the camera or remains where it is first placed in the scene.

Set to true to make it seem like it is raining everywhere in the level (ie. the Player will always be in the rain). Set to false to have a single area affected by rain (ie. the Player can move in and out of the rainy area).
   
    */
   bool followCam;
   /*!
   Controls whether drops are affected by wind.
@see ForestWindEmitter
   
    */
   bool useWind;
   /*!
   @brief Minimum speed at which a drop will fall.

On creation, the drop will be assigned a random speed between #minSpeed and #maxSpeed.
   
    */
   float minSpeed;
   /*!
   @brief Maximum speed at which a drop will fall.

On creation, the drop will be assigned a random speed between #minSpeed and #maxSpeed.
   
    */
   float maxSpeed;
   /*!
   @brief Minimum mass of a drop.

Drop mass determines how strongly the drop is affected by wind and turbulence. On creation, the drop will be assigned a random speed between #minMass and #minMass.
   
    */
   float minMass;
   /*!
   @brief Maximum mass of a drop.

Drop mass determines how strongly the drop is affected by wind and turbulence. On creation, the drop will be assigned a random speed between #minMass and #minMass.
   
    */
   float maxMass;
   /// @}


   /*! @name Turbulence
   @{ */
   /*! */
   /*!
   Check to enable turbulence. This causes precipitation drops to spiral while falling.
   
    */
   bool useTurbulence;
   /*!
   Radius at which precipitation drops spiral when turbulence is enabled.
   
    */
   float maxTurbulence;
   /*!
   Speed at which precipitation drops spiral when turbulence is enabled.
   
    */
   float turbulenceSpeed;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the properties of a PhysicsDebris object.

@see PhysicsDebris.
 */
class  PhysicsDebrisData : public GameBaseData {
  public:
   /*! @brief Loads some information to have readily available at simulation time.

Forces generation of shaders, materials, and other data used by the %PhysicsDebris object. This function should be used while a level is loading in order to shorten the amount of time to create a PhysicsDebris in game.

 */
   virtual void preload() {}

   /*! @name Display
   @{ */
   /*! */
   /*!
   @brief Path to the .DAE or .DTS file to use for this shape.

Compatable with Live-Asset Reloading.
   
    */
   filename shapeFile;
   /*!
   @brief Determines if the shape's shadow should be cast onto the environment.


   
    */
   bool castShadows;
   /// @}


   /*! @name Physical Properties
   @{ */
   /*! */
   /*!
   @brief Base time, in seconds, that debris persists after time of creation.

@note A %PhysicsDebris' lifetime multiplied by it's $pref::PhysicsDebris::lifetimeScale must be equal to or greater than 1.0.


   
    */
   float lifetime;
   /*!
   @brief Range of variation randomly applied to lifetime when debris is created.

Represents the maximum amount of seconds that will be added or subtracted to a shape's base lifetime. A value of 0 will apply the same lifetime to each shape created.


   
    */
   float lifetimeVariance;
   /*!
   @brief Value representing the mass of the shape.

A shape's mass influences the magnitude of any force applied to it. @note All PhysicsDebris objects are dynamic.
   
    */
   float mass;
   /*!
   @brief Coefficient of kinetic %friction to be applied to the shape.

Kinetic %friction reduces the velocity of a moving object while it is in contact with a surface. A larger coefficient will result in a larger reduction in velocity. A shape's friction should be smaller than it's staticFriction, but greater than 0.

@note This value is only applied while an object is in motion. For an object starting at rest, see PhysicsDebrisData::staticFriction
   
    */
   float friction;
   /*!
   @brief Coefficient of static %friction to be applied to the shape.

Static %friction determines the force needed to start moving an at-rest object in contact with a surface. If the force applied onto shape cannot overcome the force of static %friction, the shape will remain at rest. A higher coefficient will require a larger force to start motion. This value should be both greater than 0 and the PhysicsDebrisData::friction.

@note This value is only applied while an object is at rest. For an object in motion, see PhysicsDebrisData::friction
   
    */
   float staticFriction;
   /*!
   @brief Bounce coeffecient applied to the shape in response to a collision.

Restitution is a ratio of a shape's velocity before and after a collision. A value of 0 will zero out a shape's post-collision velocity, making it stop on contact. Larger values will remove less velocity after a collision, making it 'bounce' with greater force. Normal %restitution values range between 0 and 1.0.@note Values near or equaling 1.0 are likely to cause undesirable results in the physics simulation. Because of this, it is reccomended to avoid values close to 1.0
   
    */
   float restitution;
   /*!
   @brief Value that reduces an object's linear velocity over time.

Larger values will cause velocity to decay quicker.


   
    */
   float linearDamping;
   /*!
   @brief Value that reduces an object's rotational velocity over time.

Larger values will cause velocity to decay quicker.


   
    */
   float angularDamping;
   /*!
   @brief Minimum linear velocity before the shape can be put to sleep.

This should be a positive value. Shapes put to sleep will not be simulated in order to save system resources.

@note The shape must be dynamic.
   
    */
   float linearSleepThreshold;
   /*!
   @brief Minimum rotational velocity before the shape can be put to sleep.

This should be a positive value. Shapes put to sleep will not be simulated in order to save system resources.

@note The shape must be dynamic.
   
    */
   float angularSleepThreshold;
   /*!
   @brief Scale to apply to linear and angular dampening while underwater.

 @see angularDamping linearDamping
   
    */
   float waterDampingScale;
   /*!
   @brief The density of this shape for purposes of calculating buoyant forces.

The result of the calculated buoyancy is relative to the density of the WaterObject the PhysicsDebris is within.@see WaterObject::density
   
    */
   float buoyancyDensity;
   /// @}


   /*! @name Scripting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Creates a physics-based impulse effect from a defined central point and magnitude.

@see RadialImpulseEvent::send
@ingroup Physics
 */
class  RadialImpulseEvent {
  public:
   /*! @brief Applies a radial impulse to any SceneObjects within the area of effect.

This event is performed both server and client-side.

@param position Center point for this radial impulse.
@param radius Distance from the position for this radial impulse to affect.
@param magnitude The force applied to objects within the radius from the position of this radial impulse effect.

@tsexample
// Define the Position
%position = "10.0 15.0 10.0";

// Define the Radius
%radius = "25.0";

// Define the Magnitude
%magnitude = "30.0"

// Create a globalRadialImpulse physics effect.
RadialImpulseEvent::send(%position,%radius,%magnitude);
@endtsexample

 */
   virtual void send(( string inPosition="1.0 1.0 1.0", float radius=10.0f, float magnitude=20.0f )) {}
};

/*!
@brief Helper object for gameplay physical forces.

%PhysicsForces can be created and "attached" to other @link PhysicsBody PhysicsBodies@endlink to attract them to the position of the PhysicsForce.@ingroup Physics
 */
class  PhysicsForce : public SceneObject {
  public:
   /*! @brief Attempts to associate the PhysicsForce with a PhysicsBody.

Performs a physics ray cast of the provided length and direction. The %PhysicsForce will attach itself to the first dynamic PhysicsBody the ray collides with. On every tick, the attached body will be attracted towards the position of the %PhysicsForce.

A %PhysicsForce can only be attached to one body at a time.

@note To determine if an %attach was successful, check isAttached() immediately after calling this function.n
 */
   virtual void attach(( Point3F start, Point3F direction, float maxDist )) {}
   /*! @brief Disassociates the PhysicsForce from any attached PhysicsBody.

@param force Optional force to apply to the attached PhysicsBody before detaching.

@note Has no effect if the %PhysicsForce is not attached to anything.

 */
   virtual void detach(( Point3F force=Point3F::Zero )) {}
   /*! @brief Returns true if the %PhysicsForce is currently attached to an object.

@see PhysicsForce::attach() */
   virtual bool isAttached(()) {}

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents a destructible physical object simulated through the plugin system.

@see PhysicsShapeData.
 */
class  PhysicsShape : public GameBase {
  public:
   /*! @brief Returns if a PhysicsShape has been destroyed or not.

 */
   virtual bool isDestroyed(()) {}
   /*! @brief Disables rendering and physical simulation.

Calling destroy() will also spawn any explosions, debris, and/or destroyedShape defined for it, as well as remove it from the scene graph.

Destroyed objects are only created on the server. Ghosting will later update the client.

@note This does not actually delete the PhysicsShape. */
   virtual void destroy(()) {}
   /*! @brief Restores the shape to its state before being destroyed.

Re-enables rendering and physical simulation on the object and adds it to the client's scene graph. Has no effect if the shape is not destroyed.

 */
   virtual void restore(()) {}

   /*! @name PhysicsShape
   @{ */
   /*! */
   /*!
   @brief Enables or disables playing of an ambient animation upon loading the shape.

@note The ambient animation must be named "ambient".
   
    */
   bool playAmbient;
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An invisible 3D object that emits sound.

Sound emitters are used to place sounds in the level.  They are full 3D objects with their own position and orientation and when assigned 3D sounds, the transform and velocity of the sound emitter object will be applied to the 3D sound.

Sound emitters can be set up of in either of two ways:
<ul>
<li><p>By assigning an existing SFXTrack to the emitter's #track property.</p>
<p>In this case the general sound setup (3D, streaming, looping, etc.) will be taken from #track.  However, the emitter's own properties will still override their corresponding properties in the #track's SFXDescription.</p></li>
<li><p>By directly assigning a sound file to the emitter's #fileName property.</p>
<p>In this case, the sound file will be set up for playback according to the properties defined on the emitter.</p>
</ul>

Using #playOnAdd emitters can be configured to start playing immediately when they are added to the system (e.g. when the level objects are loaded from the mission file).

@note A sound emitter need not necessarily emit a 3D sound.  Instead, sound emitters may also be used to play non-positional sounds.  For placing background audio to a level, however, it is usually easier to use LevelInfo::soundAmbience.

@section SFXEmitter_networking Sound Emitters and Networking

It is important to be aware of the fact that sounds will only play client-side whereas SFXEmitter objects are server-side entities.  This means that a server-side object has no connection to the actual sound playing on the client.  It is thus not possible for the server-object to perform queries about playback status and other source-related properties as these may in fact differ from client to client.

@ingroup SFX
 */
class  SFXEmitter : public SceneObject {
  public:
   /*! Manually start playback of the emitter's sound.
If this is called on the server-side object, the play command will be related to all client-side ghosts.
 */
   virtual void play(()) {}
   /*! Manually stop playback of the emitter's sound.
If this is called on the server-side object, the stop command will be related to all client-side ghosts.
 */
   virtual void stop(()) {}
   /*! Get the sound source object from the emitter.

@return The sound source used by the emitter or null.@note This method will return null when called on the server-side SFXEmitter object.  Only client-side ghosts actually hold on to %SFXSources.

 */
   virtual string getSource(()) {}

   /*! @name Media
   @{ */
   /*! */
   /*!
   The track which the emitter should play.
@note If assigned, this field will take precedence over a #fileName that may also be assigned to the emitter.
   
    */
   SFXTrack track;
   /*!
   The sound file to play.
Use @b either this property @b or #track.  If both are assigned, #track takes precendence.  The primary purpose of this field is to avoid the need for the user to define SFXTrack datablocks for all sounds used in a level.
   
    */
   filename fileName;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /*!
   Whether playback of the emitter's sound should start as soon as the emitter object is added to the level.
If this is true, the emitter will immediately start to play when the level is loaded.
   
    */
   bool playOnAdd;
   /*!
   If this is true, all fields except for #playOnAdd and #track are ignored on the emitter object.
This is useful to prevent fields in the #track's description from being overridden by emitter fields.
   
    */
   bool useTrackDescriptionOnly;
   /*!
   Whether to play #fileName in an infinite loop.
If a #track is assigned, the value of this field is ignored.
@see SFXDescription::isLooping
   
    */
   bool isLooping;
   /*!
   Whether to use streamed playback for #fileName.
If a #track is assigned, the value of this field is ignored.
@see SFXDescription::isStreaming

@ref SFX_streaming
   
    */
   bool isStreaming;
   /*!
   The SFXSource to which to assign the sound of this emitter as a child.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::sourceGroup
   
    */
   SFXSource sourceGroup;
   /*!
   Volume level to apply to the sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::volume
   
    */
   float volume;
   /*!
   Pitch shift to apply to the sound.  Default is 1 = play at normal speed.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::pitch
   
    */
   float pitch;
   /*!
   Number of seconds to gradually fade in volume from zero when playback starts.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::fadeInTime
   
    */
   float fadeInTime;
   /*!
   Number of seconds to gradually fade out volume down to zero when playback is stopped or paused.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::fadeOutTime
   
    */
   float fadeOutTime;
   /// @}


   /*! @name 3D Sound
   @{ */
   /*! */
   /*!
   Whether to play #fileName as a positional (3D) sound or not.
If a #track is assigned, the value of this field is ignored.

@see SFXDescription::is3D
   
    */
   bool is3D;
   /*!
   Distance at which to start volume attenuation of the 3D sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::referenceDistance
   
    */
   float referenceDistance;
   /*!
   Distance at which to stop volume attenuation of the 3D sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::maxDistance
   
    */
   float maxDistance;
   /*!
   Bounds on random offset to apply to initial 3D sound position.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::scatterDistance
   
    */
   Point3F scatterDistance;
   /*!
   Angle of inner volume cone of 3D sound in degrees.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneInsideAngle
   
    */
   int coneInsideAngle;
   /*!
   Angle of outer volume cone of 3D sound in degrees
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneOutsideAngle
   
    */
   int coneOutsideAngle;
   /*!
   Volume scale factor of outside of outer volume 3D sound cone.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneOutsideVolume
   
    */
   float coneOutsideVolume;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@ingroup gameObjects
 */
class  TurretShape : public Item {
  public:
   /*! @brief Get if the turret is allowed to rotate through moves.

@return True if the turret is allowed to rotate through moves.
 */
   virtual bool getAllowManualRotation(()) {}
   /*! @brief Set if the turret is allowed to rotate through moves.

@param allow If true then the turret may be rotated through moves.
 */
   virtual void setAllowManualRotation(( bool allow )) {}
   /*! @brief Get if the turret is allowed to fire through moves.

@return True if the turret is allowed to fire through moves.
 */
   virtual bool getAllowManualFire(()) {}
   /*! @brief Set if the turret is allowed to fire through moves.

@param allow If true then the turret may be fired through moves.
 */
   virtual void setAllowManualFire(( bool allow )) {}
   /*! @brief Get the name of the turret's current state.

The state is one of the following:

<ul><li>Dead - The TurretShape is destroyed.</li><li>Mounted - The TurretShape is mounted to an object such as a vehicle.</li><li>Ready - The TurretShape is free to move.  The usual state.</li></ul>
@return The current state; one of: "Dead", "Mounted", "Ready"
 */
   virtual string getState(()) {}
   /*! @brief Get Euler rotation of this turret's heading and pitch nodes.

@return the orientation of the turret's heading and pitch nodes in the form of rotations around the X, Y and Z axes in degrees.
 */
   virtual string getTurretEulerRotation(()) {}
   /*! @brief Set Euler rotation of this turret's heading and pitch nodes in degrees.

@param rot The rotation in degrees.  The pitch is the X component and the heading is the Z component.  The Y component is ignored.
 */
   virtual void setTurretEulerRotation(( Point3F rot )) {}
   /*! @brief Does the turret respawn after it has been destroyed.

@returns True if the turret respawns.
 */
   virtual bool doRespawn(()) {}
   /*!
   @brief Respawn the turret after it has been destroyed.

If true, the turret will respawn after it is destroyed.

   
    */
   bool respawn;

   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Inventory
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@ingroup gameObjects
 */
class  AITurretShape : public TurretShape {
  public:
   /*! @brief Adds object to the turret's ignore list.

All objects in this list will be ignored by the turret's targeting.
@param obj The ShapeBase object to ignore.
 */
   virtual void addToIgnoreList(( ShapeBase obj )) {}
   /*! @brief Removes object from the turret's ignore list.

All objects in this list will be ignored by the turret's targeting.
@param obj The ShapeBase object to once again allow for targeting.
 */
   virtual void removeFromIgnoreList(( ShapeBase obj )) {}
   /*! @brief Set the turret's current state.

Normally the turret's state comes from updating the state machine but this method allows you to override this and jump to the requested state immediately.
@param newState The name of the new state.
@param force Is true then force the full processing of the new state even if it is the same as the current state.  If false then only the time out value is reset and the state's script method is called, if any.
 */
   virtual void setTurretState(( string newState, bool force=false )) {}
   /*! @brief Activate a turret from a deactive state.

 */
   virtual void activateTurret(()) {}
   /*! @brief Deactivate a turret from an active state.

 */
   virtual void deactivateTurret(()) {}
   /*! @brief Begin scanning for a target.

 */
   virtual void startScanForTargets(()) {}
   /*! @brief Stop scanning for targets.

@note Only impacts the scanning for new targets.  Does not effect a turret's current target lock.
 */
   virtual void stopScanForTargets(()) {}
   /*! @brief Have the turret track the current target.

 */
   virtual void startTrackingTarget(()) {}
   /*! @brief Stop the turret from tracking the current target.

 */
   virtual void stopTrackingTarget(()) {}
   /*! @brief Indicates if the turret has a target.

@returns True if the turret has a target.
 */
   virtual bool hasTarget(()) {}
   /*! @brief Get the turret's current target.

@returns The object that is the target's current target, or 0 if no target.
 */
   virtual string getTarget(()) {}
   /*! @brief Resets the turret's target tracking.

Only resets the internal target tracking.  Does not modify the turret's facing.
 */
   virtual void resetTarget(()) {}
   /*! @brief Set the turret's projectile velocity to help lead the target.

This value normally comes from AITurretShapeData::weaponLeadVelocity but this method allows you to override the datablock value.  This can be useful if the turret changes ammunition, uses a different weapon than the default, is damaged, etc.
@note Setting this to 0 will disable target leading.
 */
   virtual void setWeaponLeadVelocity(( float velocity )) {}
   /*! @brief Get the turret's defined projectile velocity that helps with target leading.

@returns The defined weapon projectile speed, or 0 if leading is disabled.
 */
   virtual float getWeaponLeadVelocity(()) {}
   /*! @brief Set the firing state of the turret's guns.

@param fire Set to true to activate all guns.  False to deactivate them.
 */
   virtual void setAllGunsFiring(( bool fire )) {}
   /*! @brief Set the firing state of the given gun slot.

@param slot The gun to modify.  Valid range is 0-3 that corresponds to the weapon mount point.
@param fire Set to true to activate the gun.  False to deactivate it.
 */
   virtual void setGunSlotFiring(( int slot, bool fire )) {}
   /*! @brief Recenter the turret's weapon.

 */
   virtual void recenterTurret(()) {}

   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Inventory
   @{ */
   /*! */
   /// @}


   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A flying vehicle.

@ingroup Vehicles
 */
class  FlyingVehicle : public Vehicle {
  public:
   /*! @brief Set whether the vehicle should temporarily use the createHoverHeight specified in the datablock.

This can help avoid problems with spawning.
@param enabled true to use the datablock createHoverHeight, false otherwise
 */
   virtual void useCreateHeight(( bool enabled )) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A wheeled vehicle.
@ingroup Vehicles
 */
class  WheeledVehicle : public Vehicle {
  public:
   /*! @brief Set how much the wheel is affected by steering.

The steering factor controls how much the wheel is rotated by the vehicle steering. For example, most cars would have their front wheels set to 1.0, and their rear wheels set to 0 since only the front wheels should turn.

Negative values will turn the wheel in the opposite direction to the steering angle.
@param wheel index of the wheel to set (hub node #)
@param steering steering factor from -1 (full inverse) to 1 (full)
@return true if successful, false if failed

 */
   virtual bool setWheelSteering(( int wheel, float steering )) {}
   /*! @brief Set whether the wheel is powered (has torque applied from the engine).

A rear wheel drive car for example would set the front wheels to false, and the rear wheels to true.
@param wheel index of the wheel to set (hub node #)
@param powered flag indicating whether to power the wheel or not
@return true if successful, false if failed

 */
   virtual bool setWheelPowered(( int wheel, bool powered )) {}
   /*! @brief Set the WheeledVehicleTire datablock for this wheel.
@param wheel index of the wheel to set (hub node #)
@param tire WheeledVehicleTire datablock
@return true if successful, false if failed

@tsexample
%obj.setWheelTire( 0, FrontTire );
@endtsexample
 */
   virtual bool setWheelTire(( int wheel, WheeledVehicleTire tire )) {}
   /*! @brief Set the WheeledVehicleSpring datablock for this wheel.
@param wheel index of the wheel to set (hub node #)
@param spring WheeledVehicleSpring datablock
@return true if successful, false if failed

@tsexample
%obj.setWheelSpring( 0, FrontSpring );
@endtsexample
 */
   virtual bool setWheelSpring(( int wheel, WheeledVehicleSpring spring )) {}
   /*! @brief Get the number of wheels on this vehicle.
@return the number of wheels (equal to the number of hub nodes defined in the model)

 */
   virtual int getWheelCount(()) {}

   /*! @name Game
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  BanList {
  public:
   /*! Ban a user until a given time.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@param banTime Time at which they will be allowed back in.@tsexample
// Kick someone off the server
// %client - This is the connection to the person we are kicking
function kick(%client)
{
^^// Let the server know what happened
^^messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

^^// If it is not an AI Player, execute the ban.
^^if (!%client.isAIControlled())
^^^BanList::addAbsolute(%client.guid, %client.getAddress(), $pref::Server::KickBanTime);

^^// Let the player know they messed up
^^%client.delete("You have been kicked from this server");
}
@endtsexample

 */
   virtual void addAbsolute(( int uniqueId, string transportAddress, int banTime )) {}
   /*! Ban a user for banLength seconds.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@param banLength Time period over which to ban the player.@tsexample
// Kick someone off the server
// %client - This is the connection to the person we are kicking
function kick(%client)
{
^^// Let the server know what happened
^^messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

^^// If it is not an AI Player, execute the ban.
^^if (!%client.isAIControlled())
^^^BanList::add(%client.guid, %client.getAddress(), $pref::Server::KickBanTime);

^^// Let the player know they messed up
^^%client.delete("You have been kicked from this server");
}
@endtsexample

 */
   virtual void add(( int uniqueId, string transportAddress, int banLength )) {}
   /*! Unban someone.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@tsexample
BanList::removeBan(%userID, %ipAddress);
@endtsexample

 */
   virtual void removeBan(( int uniqueId, string transportAddress )) {}
   /*! Is someone banned?

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.

@tsexample
//-----------------------------------------------------------------------------
// This script function is called before a client connection
// is accepted.  Returning  will accept the connection,
// anything else will be sent back as an error to the client.
// All the connect args are passed also to onConnectRequest
function GameConnection::onConnectRequest( %client, %netAddress, %name )
{
^  // Find out who is trying to connect
^  echo("Connect request from: " @ %netAddress);

^  // Are they allowed in?
^  if(BanList::isBanned(%client.guid, %netAddress))
^^  return "CR_YOUAREBANNED";

^  // Is there room for an unbanned player?
^  if($Server::PlayerCount >= $pref::Server::MaxPlayers)
^^  return "CR_SERVERFULL";
^  return ;
}
@endtsexample

 */
   virtual bool isBanned(( int uniqueId, string transportAddress )) {}
   /*! Dump the banlist to a file.

@param filename Path of the file to write the list to.

@tsexample
BanList::Export("./server/banlist.cs");
@endtsexample

 */
   virtual void export(( string filename )) {}
};

/*!
@brief A script-level OOP object which allows binding of a class, superClass and arguments along with declaration of methods.

ScriptObjects are extrodinarily powerful objects that allow defining of any type of data required. They can optionally have
a class and a superclass defined for added control of multiple ScriptObjects through a simple class definition.

@tsexample
new ScriptObject(Game)
{
   class = "DeathMatchGame";
   superClass = GameCore;
   genre = "Action FPS"; // Note the new, non-Torque variable
};
@endtsexample
@see SimObject
@ingroup Console
 */
class  ScriptObject : public SimObject {
  public:
      /*! Called when this ScriptObject is added to the system.
@param ID Unique object ID assigned when created (%this in script).
 */
      void onAdd( SimObjectId ID );

      /*! Called when this ScriptObject is removed from the system.
@param ID Unique object ID assigned when created (%this in script).
 */
      void onRemove( SimObjectId ID );


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Allows communications between the game and a server using TCP/IP protocols.

To use TCPObject you set up a connection to a server, send data to the server, and handle each line of the server's response using a callback.  Once you are done communicating with the server, you disconnect.

TCPObject is intended to be used with text based protocols which means you'll need to delineate the server's response with an end-of-line character. i.e. the newline character @\n.  You may optionally include the carriage return character @\r prior to the newline and TCPObject will strip it out before sending the line to the callback.  If a newline character is not included in the server's output, the received data will not be processed until you disconnect from the server (which flushes the internal buffer).

TCPObject may also be set up to listen to a specific port, making Torque into a TCP server.  When used in this manner, a callback is received when a client connection is made.  Following the outside connection, text may be sent and lines are processed in the usual manner.

If you want to work with HTTP you may wish to use HTTPObject instead as it handles all of the HTTP header setup and parsing.

@tsexample
// In this example we'll retrieve the new forum threads RSS
// feed from garagegames.com.  As we're using TCPObject, the
// raw text response will be received from the server, including
// the HTTP header.

// Define callbacks for our specific TCPObject using our instance's
// name (RSSFeed) as the namespace.

// Handle an issue with resolving the server's name
function RSSFeed::onDNSFailed(%this)
{
   // Store this state
   %this.lastState = "DNSFailed";

   // Handle DNS failure
}

function RSSFeed::onConnectFailed(%this)
{
   // Store this state
   %this.lastState = "ConnectFailed";

   // Handle connection failure
}

function RSSFeed::onDNSResolved(%this)
{
   // Store this state
   %this.lastState = "DNSResolved";

}

function RSSFeed::onConnected(%this)
{
   // Store this state
   %this.lastState = "Connected";

}

function RSSFeed::onDisconnect(%this)
{
   // Store this state
   %this.lastState = "Disconnected";

}

// Handle a line from the server
function RSSFeed::onLine(%this, %line)
{
   // Print the line to the console
   echo( %line );
}

// Create the TCPObject
%rss = new TCPObject(RSSFeed);

// Define a dynamic field to store the last connection state
%rss.lastState = "None";

// Connect to the server
%rss.connect("www.garagegames.com:80");

// Send the RSS feed request to the server.  Response will be
// handled in onLine() callback above
%rss.send("GET /feeds/rss/threads HTTP/1.1\r\nHost: www.garagegames.com\r\n\r\n");
@endtsexample

@see HTTPObject
@ingroup Networking
 */
class  TCPObject : public ScriptObject {
  public:
      /*! @brief Called whenever a connection request is made.

This callback is used when the TCPObject is listening to a port and a client is attempting to connect.
@param address Server address connecting from.
@param ID Connection ID
@see listen()
 */
      void onConnectionRequest( string address, string ID );

      /*! @brief Called whenever a line of data is sent to this TCPObject.

This callback is called when the received data contains a newline @\n character, or the connection has been disconnected and the TCPObject's buffer is flushed.
@param line Data sent from the server.
 */
      void onLine( string line );

      /*! Called whenever the DNS has been resolved.
 */
      void onDNSResolved();

      /*! Called whenever the DNS has failed to resolve.
 */
      void onDNSFailed();

      /*! Called whenever a connection is established with a server.
 */
      void onConnected();

      /*! Called whenever a connection has failed to be established with a server.
 */
      void onConnectFailed();

      /*! Called whenever the TCPObject disconnects from whatever it is currently connected to.
 */
      void onDisconnect();

   /*! @brief Transmits the data string to the connected computer.

This method is used to send text data to the connected computer regardless if we initiated the connection using connect(), or listening to a port using listen().
@param data The data string to send.
@tsexample
// Set the command data
%data = "GET " @ $RSSFeed::serverURL @ " HTTP/1.0\r\n";
%data = %data @ "Host: " @ $RSSFeed::serverName @ "\r\n";
%data = %data @ "User-Agent: " @ $RSSFeed::userAgent @ "\r\n\r\n"

// Send the command to the connected server.
%thisTCPObj.send(%data);
@endtsexample
 */
   virtual void send(( string data )) {}
   /*! @brief Start listening on the specified port for connections.

This method starts a listener which looks for incoming TCP connections to a port.  You must overload the onConnectionRequest callback to create a new TCPObject to read, write, or reject the new connection.

@param port Port for this TCPObject to start listening for connections on.
@tsexample
// Create a listener on port 8080.
new TCPObject( TCPListener );
TCPListener.listen( 8080 );

function TCPListener::onConnectionRequest( %this, %address, %id )
{
   // Create a new object to manage the connection.
   new TCPObject( TCPClient, %id );
}

function TCPClient::onLine( %this, %line )
{
   // Print the line of text from client.
   echo( %line );
}
@endtsexample
 */
   virtual void listen(( int port )) {}
   /*! @brief Connect to the given address.

@param address Server address (including port) to connect to.
@tsexample
// Set the address.
%address = "www.garagegames.com:80";

// Inform this TCPObject to connect to the specified address.
%thisTCPObj.connect(%address);
@endtsexample
 */
   virtual void connect(( string address )) {}
   /*! @brief Disconnect from whatever this TCPObject is currently connected to, if anything.

@tsexample
// Inform this TCPObject to disconnect from anything it is currently connected to.
%thisTCPObj.disconnect();
@endtsexample
 */
   virtual void disconnect(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Allows communications between the game and a server using HTTP.

HTTPObject is derrived from TCPObject and makes use of the same callbacks for dealing with connections and received data.  However, the way in which you use HTTPObject to connect with a server is different than TCPObject.  Rather than opening a connection, sending data, waiting to receive data, and then closing the connection, you issue a get() or post() and handle the response.  The connection is automatically created and destroyed for you.

@tsexample
// In this example we'll retrieve the weather in Las Vegas using
// Google's API.  The response is in XML which could be processed
// and used by the game using SimXMLDocument, but we'll just output
// the results to the console in this example.

// Define callbacks for our specific HTTPObject using our instance's
// name (WeatherFeed) as the namespace.

// Handle an issue with resolving the server's name
function WeatherFeed::onDNSFailed(%this)
{
   // Store this state
   %this.lastState = "DNSFailed";

   // Handle DNS failure
}

function WeatherFeed::onConnectFailed(%this)
{
   // Store this state
   %this.lastState = "ConnectFailed";

   // Handle connection failure
}

function WeatherFeed::onDNSResolved(%this)
{
   // Store this state
   %this.lastState = "DNSResolved";

}

function WeatherFeed::onConnected(%this)
{
   // Store this state
   %this.lastState = "Connected";

   // Clear our buffer
   %this.buffer = "";
}

function WeatherFeed::onDisconnect(%this)
{
   // Store this state
   %this.lastState = "Disconnected";

   // Output the buffer to the console
   echo("Google Weather Results:");
   echo(%this.buffer);
}

// Handle a line from the server
function WeatherFeed::onLine(%this, %line)
{
   // Store this line in out buffer
   %this.buffer = %this.buffer @ %line;
}

// Create the HTTPObject
%feed = new HTTPObject(WeatherFeed);

// Define a dynamic field to store the last connection state
%feed.lastState = "None";

// Send the GET command
%feed.get("www.google.com:80", "/ig/api", "weather=Las-Vegas,US");
@endtsexample

@see TCPObject
@ingroup Networking
 */
class  HTTPObject : public TCPObject {
  public:
   /*! @brief Send a GET command to a server to send or retrieve data.

@param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: "www.garagegames.com:80").
@param requirstURI Specific location on the server to access (IE: "index.php".)
@param query Optional. Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. If you were building the URL manually, this is the text that follows the question mark.  For example: http://www.google.com/ig/api?<b>weather=Las-Vegas,US</b>
@tsexample
// Create an HTTP object for communications
%httpObj = new HTTPObject();

// Specify a URL to transmit to
%url = "www.garagegames.com:80";

// Specify a URI to communicate with
%URI = "/index.php";

// Specify a query to send.
%query = "";

// Send the GET command to the server
%httpObj.get(%url,%URI,%query);
@endtsexample

 */
   virtual void get(( string Address, string requirstURI, string query="" )) {}
   /*! @brief Send POST command to a server to send or retrieve data.

@param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: "www.garagegames.com:80").
@param requirstURI Specific location on the server to access (IE: "index.php".)
@param query Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol. 
@param post Submission data to be processed.
@note The post() method is currently non-functional.
@tsexample
// Create an HTTP object for communications
%httpObj = new HTTPObject();

// Specify a URL to transmit to
%url = "www.garagegames.com:80";

// Specify a URI to communicate with
%URI = "/index.php";

// Specify a query to send.
%query = "";

// Specify the submission data.
%post = "";

// Send the POST command to the server
%httpObj.POST(%url,%URI,%query,%post);
@endtsexample

 */
   virtual void post(( string Address, string requirstURI, string query, string post )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A very simple example of a network event.

This object exists purely for instructional purposes. It is primarily geared toward developers that wish to understand the inner-working of Torque 3D's networking system. This is not intended for actual game development.

 @see NetEvent for the inner workings of network events

@ingroup Networking
 */
class  SimpleMessageEvent {
  public:
   /*! @brief Send a SimpleMessageEvent message to the specified connection.

The far end that receives the message will print the message out to the console.
@param con The unique ID of the connection to transmit to
@param message The string containing the message to transmit

@tsexample
// Send a message to the other end of the given NetConnection
SimpleMessageEvent::msg( %conn, "A message from me!");

// The far end will see the following in the console
// (Note: The number may be something other than 1796 as it is the SimObjectID
// of the received event)
// 
// RMSG 1796  A message from me!
@endtsexample

 */
   virtual void msg(( NetConnection con, string message )) {}
};

/*!
@brief A very simple example of a class derived from NetObject.

This object exists purely for instructional purposes. It is primarily geared toward developers that wish to understand the inner-working of Torque 3D's networking system. This is not intended for actual game development.

 @tsexample
// On the server, create a new SimpleNetObject.  This is a ghost always
// object so it will be immediately ghosted to all connected clients.
$s = new SimpleNetObject();

// All connected clients will see the following in their console:
// 
// Got message: Hello World!
@endtsexample

@see NetObject for a full breakdown of this example object
@ingroup Networking
 */
class  SimpleNetObject : public NetObject {
  public:
   /*! @brief Sets the internal message variable.

SimpleNetObject is set up to automatically transmit this new message to all connected clients.  It will appear in the clients' console.
@param msg The new message to send

@tsexample
// On the server, create a new SimpleNetObject.  This is a ghost always
// object so it will be immediately ghosted to all connected clients.
$s = new SimpleNetObject();

// All connected clients will see the following in their console:
// 
// Got message: Hello World!

// Now again on the server, change the message.  This will cause it to
// be sent to all connected clients.
$s.setMessage("A new message from me!");

// All connected clients will now see in their console:
// 
// Go message: A new message from me!
@endtsexample

 */
   virtual void setMessage(( string msg )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Console object used for calling methods defined in script, from within other classes.

Not intended for game development, for editors or internal use only.

 */
class  DynamicConsoleMethodComponent : public SimComponent {
  public:
   /*! Calls script defined method
@param methodName The method's name as a string
@param argi Any arguments to pass to the method
@return No return value@note %obj.callMethod( %methodName, %arg1, %arg2, ... );
 */
   virtual void callMethod((methodName, argi)) {}

   /*! @name Component
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Data structure for storing indexed sequences of key/value pairs.

This is a powerful array class providing PHP style arrays in TorqueScript.

The following features are supported:<ul>
<li>array pointers: this allows you to move forwards or backwards through the array as if it was a list, including jumping to the start or end.</li>
<li>sorting: the array can be sorted in either alphabetic or numeric mode, on the key or the value, and in ascending or descending order</li>
<li>add/remove elements: elements can be pushed/popped from the start or end of the array, or can be inserted/erased from anywhere in the middle</li>
<li>removal of duplicates: remove duplicate keys or duplicate values</li>
<li>searching: search the array and return the index of a particular key or value</li>
<li>counting: count the number of instaces of a particular value or key in the array, as well as the total number of elements</li>
<li>advanced features: array append, array crop and array duplicate</li>
</ul>

Array element keys and values can be strings or numbers

 */
class  ArrayObject : public SimObject {
  public:
   /*! Search the array from the current position for the element @param value Array value to search for
@return Index of the first element found, or -1 if none
 */
   virtual int getIndexFromValue(( string value )) {}
   /*! Search the array from the current position for the key @param value Array key to search for
@return Index of the first element found, or -1 if none
 */
   virtual int getIndexFromKey(( string key )) {}
   /*! Get the value of the array element at the submitted index.
@param index 0-based index of the array element to get
@return The value of the array element at the specified index, or "" if the index is out of range
 */
   virtual string getValue(( int index )) {}
   /*! Get the key of the array element at the submitted index.
@param index 0-based index of the array element to get
@return The key associated with the array element at the specified index, or "" if the index is out of range
 */
   virtual string getKey(( int index )) {}
   /*! Set the key at the given index.
@param key New key value
@param index 0-based index of the array element to update
 */
   virtual void setKey(( string key, int index )) {}
   /*! Set the value at the given index.
@param value New array element value
@param index 0-based index of the array element to update
 */
   virtual void setValue(( string value, int index )) {}
   /*! Get the number of elements in the array. */
   virtual int count(()) {}
   /*! Get the number of times a particular value is found in the array.
@param value Array element value to count
 */
   virtual int countValue(( string value )) {}
   /*! Get the number of times a particular key is found in the array.
@param key Key value to count
 */
   virtual int countKey(( string key )) {}
   /*! Adds a new element to the end of an array (same as push_back()).
@param key Key for the new element
@param value Value for the new element
 */
   virtual void add(( string key, string value="" )) {}
   /*! Adds a new element to the end of an array.
@param key Key for the new element
@param value Value for the new element
 */
   virtual void push_back(( string key, string value="" )) {}
   /*! Adds a new element to the front of an array */
   virtual void push_front(( string key, string value="" )) {}
   /*! Adds a new element to a specified position in the array.
- @a index = 0 will insert an element at the start of the array (same as push_front())
- @a index = %array.count() will insert an element at the end of the array (same as push_back())

@param key Key for the new element
@param value Value for the new element
@param index 0-based index at which to insert the new element */
   virtual void insert(( string key, string value, int index )) {}
   /*! Removes the last element from the array */
   virtual void pop_back(()) {}
   /*! Removes the first element from the array */
   virtual void pop_front(()) {}
   /*! Removes an element at a specific position from the array.
@param index 0-based index of the element to remove
 */
   virtual void erase(( int index )) {}
   /*! Emptys all elements from an array */
   virtual void empty(()) {}
   /*! Removes any elements that have duplicated values (leaving the first instance) */
   virtual void uniqueValue(()) {}
   /*! Removes any elements that have duplicated keys (leaving the first instance) */
   virtual void uniqueKey(()) {}
   /*! Alters array into an exact duplicate of the target array.
@param target ArrayObject to duplicate
 */
   virtual bool duplicate(( ArrayObject target )) {}
   /*! Removes elements with matching keys from array.
@param target ArrayObject containing keys to remove from this array
 */
   virtual bool crop(( ArrayObject target )) {}
   /*! Appends the target array to the array object.
@param target ArrayObject to append to the end of this array
 */
   virtual bool append(( ArrayObject target )) {}
   /*! Alpha sorts the array by value

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sort(( bool ascending=false )) {}
   /*! Alpha sorts the array by value in ascending order */
   virtual void sorta(()) {}
   /*! Alpha sorts the array by value in descending order */
   virtual void sortd(()) {}
   /*! Alpha sorts the array by key

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortk(( bool ascending=false )) {}
   /*! Alpha sorts the array by key in ascending order */
   virtual void sortka(()) {}
   /*! Alpha sorts the array by key in descending order */
   virtual void sortkd(()) {}
   /*! Numerically sorts the array by value

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortn(( bool ascending=false )) {}
   /*! Numerically sorts the array by value in ascending order */
   virtual void sortna(()) {}
   /*! Numerically sorts the array by value in descending order */
   virtual void sortnd(()) {}
   /*! Numerically sorts the array by key

@param ascending [optional] True for ascending sort, false for descending sort
 */
   virtual void sortnk(( bool ascending=false )) {}
   /*! Numerical sorts the array by key in ascending order */
   virtual void sortnka(()) {}
   /*! Numerical sorts the array by key in descending order */
   virtual void sortnkd(()) {}
   /*! Sorts the array by value in ascending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.

@tsexample
function mySortCallback(%a, %b)
{
   return strcmp( %a.name, %b.name );
}

%array.sortf( "mySortCallback" );
@endtsexample
 */
   virtual void sortf(( string functionName )) {}
   /*! Sorts the array by key in ascending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfk(( string functionName )) {}
   /*! Sorts the array by value in descending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfd(( string functionName )) {}
   /*! Sorts the array by key in descending order using the given callback function.
@param functionName Name of a function that takes two arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.@see sortf
 */
   virtual void sortfkd(( string functionName )) {}
   /*! Moves array pointer to start of array

@return Returns the new array pointer */
   virtual int moveFirst(()) {}
   /*! Moves array pointer to end of array

@return Returns the new array pointer */
   virtual int moveLast(()) {}
   /*! Moves array pointer to next position

@return Returns the new array pointer, or -1 if already at the end */
   virtual int moveNext(()) {}
   /*! Moves array pointer to prev position

@return Returns the new array pointer, or -1 if already at the start */
   virtual int movePrev(()) {}
   /*! Gets the current pointer index */
   virtual int getCurrent(()) {}
   /*! Sets the current pointer index.
@param index New 0-based pointer index
 */
   virtual void setCurrent(( int index )) {}
   /*! Echos the array contents to the console */
   virtual void echo(()) {}
   /*!
   Makes the keys and values case-sensitive.
By default, comparison of key and value strings will be case-insensitive.
   
    */
   bool caseSensitive;
   /*!
   Helper field which allows you to add new key['keyname'] = value pairs.
   
    */
   caseString key;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
A class designed to be used as a console consumer and log the data it receives to a file.

@see dumpConsoleFunctions
@see dumpConsoleClasses
@ingroup Logging
 */
class  ConsoleLogger : public SimObject {
  public:
   /*! Attaches the logger to the console and begins writing to file@tsexample
// Create the logger
// Will automatically start writing to testLogging.txt with normal priority
new ConsoleLogger(logger, "testLogging.txt", false);

// Send something to the console, with the logger consumes and writes to file
echo("This is logged to the file");

// Stop logging, but do not delete the logger
logger.detach();

echo("This is not logged to the file");

// Attach the logger to the console again
logger.attach();

// Logging has resumed
echo("Logging has resumed");@endtsexample

 */
   virtual bool attach(()) {}
   /*! Detaches the logger from the console and stops writing to file@tsexample
// Create the logger
// Will automatically start writing to testLogging.txt with normal priority
new ConsoleLogger(logger, "testLogging.txt", false);

// Send something to the console, with the logger consumes and writes to file
echo("This is logged to the file");

// Stop logging, but do not delete the logger
logger.detach();

echo("This is not logged to the file");

// Attach the logger to the console again
logger.attach();

// Logging has resumed
echo("Logging has resumed");@endtsexample

 */
   virtual bool detach(()) {}

   /*! @name Logging
   @{ */
   /*! */
   /*!
   Determines the priority level and attention the logged entry gets when recorded


   
    */
   LogLevel level;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief For static-field copying/pasting, editor use only

 */
class  FieldBrushObject : public SimObject {
  public:
   /*! Query available static-field groups for selected object./
@param simObject Object to query static-field groups on.
@return Space-seperated static-field group list. */
   virtual string queryGroups((simObject)) {}
   /*! Query available static-fields for selected object./
@param simObject Object to query static-fields on.
@param groupList groups to filter static-fields against.
@return Space-seperated static-field list. */
   virtual string queryFields((simObject, [groupList])) {}
   /*! Copy selected static-fields for selected object./
@param simObject Object to copy static-fields from.
@param fieldList fields to filter static-fields against.
@return No return value. */
   virtual void copyFields((simObject, [fieldList])) {}
   /*! Paste copied static-fields to selected object./
@param simObject Object to paste static-fields to.
@return No return value. */
   virtual void pasteFields((simObject)) {}
   /*!
   
   
    */
   caseString description;
   /*!
   
   
    */
   string sortName;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief this class manages updating SimObjects in the file they were created in non-destructively (mostly aimed at datablocks and materials).

Basic scripting interface:

^- Creation: new PersistenceManager(FooManager);
^- Flag objects as dirty: FooManager.setDirty(<object name or id>);
^- Remove objects from dirty list: FooManager.removeDirty(<object name or id>);
^- List all currently dirty objects: FooManager.listDirty();
^- Check to see if an object is dirty: FooManager.isDirty(<object name or id>);
^- Save dirty objects to their files: FooManager.saveDirty();

@note Dirty objects don't update their files until saveDirty() is called so you can change their properties after you flag them as dirty

@note Currently only used by editors, not intended for actual game development

@ingroup Console
@ingroup Editors
 */
class  PersistenceManager : public SimObject {
  public:
   /*! Delete all of the objects that are created from the given file. */
   virtual void deleteObjectsFromFile(( fileName )) {}
   /*! Mark an existing SimObject as dirty (will be written out when saveDirty() is called). */
   virtual void setDirty((SimObject object, [filename])) {}
   /*! Remove a SimObject from the dirty list. */
   virtual void removeDirty((SimObject object)) {}
   /*! Returns true if the SimObject is on the dirty list. */
   virtual bool isDirty((SimObject object)) {}
   /*! Returns true if the manager has dirty objects to save. */
   virtual bool hasDirty(()) {}
   /*! Returns the number of dirty objects. */
   virtual int getDirtyObjectCount(()) {}
   /*! Returns the ith dirty object. */
   virtual int getDirtyObject(( index )) {}
   /*! Prints the dirty list to the console. */
   virtual void listDirty(()) {}
   /*! Saves all of the SimObject's on the dirty list to their respective files. */
   virtual bool saveDirty(()) {}
   /*! Save a dirty SimObject to it's file. */
   virtual bool saveDirtyObject((SimObject object)) {}
   /*! Clears all the tracked objects without saving them. */
   virtual void clearAll(()) {}
   /*! Remove an existing SimObject from a file (can optionally specify a different file than                the one it was created in. */
   virtual void removeObjectFromFile((SimObject object, [filename])) {}
   /*! Remove a specific field from an object declaration. */
   virtual void removeField((SimObject object, string fieldName)) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A ScriptObject that responds to tick and frame events.

ScriptTickObject is a ScriptObject that adds callbacks for tick and frame events.  Use setProcessTicks() to enable or disable the onInterpolateTick() and onProcessTick() callbacks.  The callOnAdvanceTime property determines if the onAdvanceTime() callback is called.

@see ScriptObject
@ingroup Console
 */
class  ScriptTickObject : public ScriptObject {
  public:
      /*! This is called every frame, but only if the object is set to process ticks.
@param delta The time delta for this frame.
 */
      void onInterpolateTick( float delta );

      /*! Called once every 32ms if this object is set to process ticks.
 */
      void onProcessTick();

      /*! This is called every frame regardless if the object is set to process ticks, but only if the callOnAdvanceTime property is set to true.
@param timeDelta The time delta for this frame.
@see callOnAdvanceTime
 */
      void onAdvanceTime( float timeDelta );

   /*! @brief Sets this object as either tick processing or not.

@param tick This object's onInterpolateTick() and onProcessTick() callbacks are called if set to true.

 */
   virtual void setProcessTicks(( bool tick )) {}
   /*! @brief Is this object wanting to receive tick notifications.

If this object is set to receive tick notifications then its onInterpolateTick() and onProcessTick() callbacks are called.
@return True if object wants tick notifications

 */
   virtual bool isProcessingTicks(()) {}
   /*!
   Call the onAdvaceTime() callback.
   
    */
   bool callOnAdvanceTime;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Essentially a SimGroup, but with onAdd and onRemove script callbacks.

@tsexample
// First container, SimGroup containing a ScriptGroup
new SimGroup(Scenes)
{
^// Subcontainer, ScriptGroup containing variables
^// related to a cut scene and a starting WayPoint
^new ScriptGroup(WelcomeScene)
^{
^^class = "Scene";
^^pathName = "Pathx";
^^description = "A small orc village set in the Hardesty mountains. This town and its surroundings will be used to illustrate some the Torque Game Engine's features.";
^^pathTime = "0";
^^title = "Welcome to Orc Town";

^^new WayPoint(start)
^^{
^^^position = "163.873 -103.82 208.354";
^^^rotation = "0.136165 -0.0544916 0.989186 44.0527";
^^^scale = "1 1 1";
^^^dataBlock = "WayPointMarker";
^^^team = "0";
^^};
^};
};
@endtsexample

@see SimGroup
@ingroup Console
 */
class  ScriptGroup : public SimGroup {
  public:
      /*! Called when this ScriptGroup is added to the system.
@param ID Unique object ID assigned when created (%this in script).
 */
      void onAdd( SimObjectId ID );

      /*! Called when this ScriptObject is removed from the system.
@param ID Unique object ID assigned when created (%this in script).
 */
      void onRemove( SimObjectId ID );


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A SimSet that can be safely persisted.

Uses SimPersistIDs to reference objects in the set while persisted on disk.  This allows the set to resolve its references no matter whether they are loaded before or after the set is created.

Not intended for game development, for editors or internal use only.

 */
class  SimPersistSet : public SimSet {
  public:
   /*! Try to bind unresolved persistent IDs in the set. */
   virtual void resolvePersistentIds(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief File I/O object used for creating, reading, and writing XML documents.

A SimXMLDocument is a container of various XML nodes.  The Document level may contain a header (sometimes called a declaration), comments and child Elements.  Elements may contain attributes, data (or text) and child Elements.

You build new Elements using addNewElement().  This makes the new Element the current one you're working with.  You then use setAttribute() to add attributes to the Element.  You use addData() or addText() to write to the text area of an Element.@tsexample
// Thanks to Rex Hiebert for this example
// Given the following XML
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<DataTables>
^<table tableName="2DShapes">
^^<rec id="1">Triangle</rec>
^^<rec id="2">Square</rec>
^^<rec id="3">Circle</rec>
^</table>
^<table tableName="3DShapes">
^^<rec id="1">Pyramid</rec>
^^<rec id="2">Cube</rec>
^^<rec id="3">Sphere</rec>
^</table>
</DataTables>

// Using SimXMLDocument by itself
function readXmlExample(%filename)
{
   %xml = new SimXMLDocument() {};
   %xml.loadFile(%filename);

   %xml.pushChildElement("DataTables");
   %xml.pushFirstChildElement("table");
   while(true)
   {
^  echo("TABLE:" SPC %xml.attribute("tableName"));
^  %xml.pushFirstChildElement("rec");
^  while (true)
^  {
^^ %id = %xml.attribute("id");
^^ %desc = %xml.getData();
^^ echo("  Shape" SPC %id SPC %desc);
^^ if (!%xml.nextSiblingElement("rec")) break;
^  }
^  %xml.popElement();
^  if (!%xml.nextSiblingElement("table")) break;
   }
}

// Thanks to Scott Peal for this example
// Using FileObject in conjunction with SimXMLDocument
// This example uses an XML file with a format of:
// <Models>
//    <Model category="" name="" path="" />
// </Models>
function getModelsInCatagory()
{
   %file = "./Catalog.xml";
   %fo = new FileObject();
   %text = "";

   if(%fo.openForRead(%file))
   {
^  while(!%fo.isEOF())
^  {
^^ %text = %text @ %fo.readLine();
^^ if (!%fo.isEOF()) %text = %text @ "\n";
^  }
   }
   else
   {
^  echo("Unable to locate the file: " @ %file);
   }

   %fo.delete();

   %xml = new SimXMLDocument() {};
   %xml.parse(%text);
   // "Get" inside of the root element, "Models".
   %xml.pushChildElement(0);

   // "Get" into the first child element
   if (%xml.pushFirstChildElement("Model"))
   {
^  while (true)
^  {
^^ // 
^^ //  Here, i read the element's attributes.
^^ //  You might want to save these values in an array or call the %xml.getElementValue()
^^ //  if you have a different XML structure.

^^ %catagory = %xml.attribute("catagory");
^^ %name = %xml.attribute("name");
^^ %path = %xml.attribute("path");

^^ // now, read the next "Model"
^^ if (!%xml.nextSiblingElement("Model")) break;
^  }
   }
}
@endtsexample

@note SimXMLDocument is a wrapper around TinyXml, a standard XML library.  If you're familiar with its concepts, you'll find they also apply here.

@see FileObject

@ingroup FileSystem
 */
class  SimXMLDocument : public SimObject {
  public:
   /*! @brief Set this document to its default state.

Clears all Elements from the documents.  Equivalent to using clear()

@see clear() */
   virtual void reset(()) {}
   /*! @brief Load in given filename and prepare it for use.

@note Clears the current document's contents.

@param fileName Name and path of XML document
@return True if the file was loaded successfully. */
   virtual bool loadFile(( string fileName )) {}
   /*! @brief Save document to the given file name.

@param fileName Path and name of XML file to save to.
@return True if the file was successfully saved. */
   virtual bool saveFile(( string fileName )) {}
   /*! @brief Create a document from a XML string.

@note Clears the current document's contents.

@param xmlString Valid XML to parse and store as a document. */
   virtual void parse(( string xmlString )) {}
   /*! @brief Set this document to its default state.

Clears all Elements from the documents.  Equivalent to using reset()

@see reset() */
   virtual void clear(()) {}
   /*! @brief Get last error description.

@return A string of the last error message. */
   virtual string getErrorDesc(()) {}
   /*! @brief Clear the last error description.

 */
   virtual void clearError(()) {}
   /*! @brief Push the first child Element with the given name onto the stack, making it the current Element.

@param name String containing name of the child Element.
@return True if the Element was found and made the current one.
@tsexample
// Using the following test.xml file as an example:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement>Some text</NewElement>

// Load in the file
%x = new SimXMLDocument();
%x.loadFile("test.xml");

// Make the first Element the current one
%x.pushFirstChildElement("NewElement");

// Store the current Element's text ('Some text' in this example)
// into 'result'
%result = %x.getText();
echo( %result );
@endtsexample

 */
   virtual bool pushFirstChildElement(( string name )) {}
   /*! @brief Push the child Element at the given index onto the stack, making it the current one.

@param index Numerical index of Element being pushed.@return True if the Element was found and made the current one.
 */
   virtual bool pushChildElement(( int index )) {}
   /*! @brief Put the next sibling Element with the given name on the stack, making it the current one.

@param name String containing name of the next sibling.@return True if the Element was found and made the current one.
 */
   virtual bool nextSiblingElement(( string name )) {}
   /*! @brief Get the Element's value if it exists.

Usually returns the text from the Element.
@return The value from the Element, or an empty string if none is found. */
   virtual string elementValue(()) {}
   /*! @brief Pop the last Element off the stack.

 */
   virtual void popElement(()) {}
   /*! @brief Get a string attribute from the current Element on the stack.

@param attributeName Name of attribute to retrieve.
@return The attribute string if found.  Otherwise returns an empty string.
 */
   virtual string attribute(( string attributeName )) {}
   /*! @brief Get float attribute from the current Element on the stack.

@param attributeName Name of attribute to retrieve.
@return The value of the given attribute in the form of a float.
@deprecated Use attribute(). */
   virtual float attributeF32((string attributeName)) {}
   /*! @brief Get int attribute from the current Element on the stack.

@param attributeName Name of attribute to retrieve.
@return The value of the given attribute in the form of an integer.
@deprecated Use attribute(). */
   virtual int attributeS32((string attributeName)) {}
   /*! @brief Tests if the requested attribute exists.

@param attributeName Name of attribute being queried for.

@return True if the attribute exists. */
   virtual bool attributeExists(( string attributeName )) {}
   /*! @brief Obtain the name of the current Element's first attribute.

@return String containing the first attribute's name, or an empty string if none is found.

@see nextAttribute()
@see lastAttribute()
@see prevAttribute() */
   virtual string firstAttribute(()) {}
   /*! @brief Obtain the name of the current Element's last attribute.

@return String containing the last attribute's name, or an empty string if none is found.

@see prevAttribute()
@see firstAttribute()
@see lastAttribute()
 */
   virtual string lastAttribute(()) {}
   /*! @brief Get the name of the next attribute for the current Element after a call to firstAttribute().

@return String containing the next attribute's name, or an empty string if none is found.@see firstAttribute()
@see lastAttribute()
@see prevAttribute()
 */
   virtual string nextAttribute(()) {}
   /*! @brief Get the name of the previous attribute for the current Element after a call to lastAttribute().

@return String containing the previous attribute's name, or an empty string if none is found.@see lastAttribute()
@see firstAttribute()
@see nextAttribute()
 */
   virtual string prevAttribute(()) {}
   /*! @brief Set the attribute of the current Element on the stack to the given value.

@param attributeName Name of attribute being changed
@param value New value to assign to the attribute
 */
   virtual void setAttribute(( string attributeName, string value )) {}
   /*! @brief Add the given SimObject's fields as attributes of the current Element on the stack.

@param objectID ID of SimObject being copied. */
   virtual void setObjectAttributes(( string objectID )) {}
   /*! @brief Create a new element with the given name as child of current Element and push it onto the Element stack making it the current one.

@note This differs from addNewElement() in that it adds the new Element as a child of the current Element (or a child of the document if no Element exists).

@param name XML tag for the new Element.
@see addNewElement() */
   virtual void pushNewElement(( string name )) {}
   /*! @brief Create a new element with the given name as child of current Element's parent and push it onto the Element stack making it the current one.

@note This differs from pushNewElement() in that it adds the new Element to the current Element's parent (or document if there is no parent Element).  This makes the new Element a sibling of the current one.

@param name XML tag for the new Element.
@see pushNewElement() */
   virtual void addNewElement(( string name )) {}
   /*! @brief Add a XML header to a document.

Sometimes called a declaration, you typically add a standard header to the document before adding any elements.  SimXMLDocument always produces the following header:

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>

@tsexample
// Create a new XML document with just a header and single element.
%x = new SimXMLDocument();
%x.addHeader();
%x.addNewElement("NewElement");
%x.saveFile("test.xml");

// Produces the following file:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement />
@endtsexample

 */
   virtual void addHeader(()) {}
   /*! @brief Add the given comment as a child of the document.

@param comment String containing the comment.@tsexample
// Create a new XML document with a header, a comment and single element.
%x = new SimXMLDocument();
%x.addHeader();
%x.addComment("This is a test comment");
%x.addNewElement("NewElement");
%x.saveFile("test.xml");

// Produces the following file:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <!--This is a test comment-->
// <NewElement />
@endtsexample

@see readComment() */
   virtual void addComment(( string comment )) {}
   /*! Gives the comment at the specified index, if any.

Unlike addComment() that only works at the document level, readComment() may read comments from the document or any child Element.  The current Element (or document if no Elements have been pushed to the stack) is the parent for any comments, and the provided index is the number of comments in to read back.@param index Comment index number to query from the current Element stack

@return String containing the comment, or an empty string if no comment is found.

@see addComment() */
   virtual string readComment(( int index )) {}
   /*! @brief Add the given text as a child of current Element.

Use getText() to retrieve any text from the current Element and removeText() to clear any text.

addText() and addData() may be used interchangeably.@param text String containing the text.

@tsexample
// Create a new XML document with a header and single element
// with some added text.
%x = new SimXMLDocument();
%x.addHeader();
%x.addNewElement("NewElement");
%x.addText("Some text");
%x.saveFile("test.xml");

// Produces the following file:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement>Some text</NewElement>
@endtsexample

@see getText()
@see removeText()
@see addData()
@see getData() */
   virtual void addText(( string text )) {}
   /*! @brief Gets the text from the current Element.

Use addText() to add text to the current Element and removeText() to clear any text.

getText() and getData() may be used interchangeably.@return String containing the text in the current Element.@tsexample
// Using the following test.xml file as an example:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement>Some text</NewElement>

// Load in the file
%x = new SimXMLDocument();
%x.loadFile("test.xml");

// Make the first Element the current one
%x.pushFirstChildElement("NewElement");

// Store the current Element's text ('Some text' in this example)
// into 'result'
%result = %x.getText();
echo( %result );
@endtsexample

@see addText()
@see removeText()
@see addData()
@see getData()
 */
   virtual string getText(()) {}
   /*! @brief Remove any text on the current Element.

Use getText() to retrieve any text from the current Element and addText() to add text to the current Element.  As getData() and addData() are equivalent to getText() and addText(), removeText() will also remove any data from the current Element.

@see addText()
@see getText()
@see addData()
@see getData()
 */
   virtual void removeText(()) {}
   /*! @brief Add the given text as a child of current Element.

Use getData() to retrieve any text from the current Element.

addData() and addText() may be used interchangeably.  As there is no difference between data and text, you may also use removeText() to clear any data from the current Element.

@param text String containing the text.

@tsexample
// Create a new XML document with a header and single element
// with some added data.
%x = new SimXMLDocument();
%x.addHeader();
%x.addNewElement("NewElement");
%x.addData("Some text");
%x.saveFile("test.xml");

// Produces the following file:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement>Some text</NewElement>
@endtsexample

@see getData()@see addText()
@see getText()
@see removeText()
 */
   virtual void addData(( string text )) {}
   /*! @brief Gets the text from the current Element.

Use addData() to add text to the current Element.

getData() and getText() may be used interchangeably.  As there is no difference between data and text, you may also use removeText() to clear any data from the current Element.

@return String containing the text in the current Element.@tsexample
// Using the following test.xml file as an example:
// <?xml version="1.0" encoding="utf-8" standalone="yes" ?>
// <NewElement>Some data</NewElement>

// Load in the file
%x = new SimXMLDocument();
%x.loadFile("test.xml");

// Make the first Element the current one
%x.pushFirstChildElement("NewElement");

// Store the current Element's data ('Some data' in this example)
// into 'result'
%result = %x.getData();
echo( %result );
@endtsexample

@see addData()
@see addText()
@see getText()
@see removeText()
 */
   virtual string getData(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This class is responsible opening, reading, creating, and saving file contents.

FileObject acts as the interface with OS level files.  You create a new FileObject and pass into it a file's path and name.  The FileObject class supports three distinct operations for working with files:

<table border='1' cellpadding='1'><tr><th>Operation</th><th>%FileObject Method</th><th>Description</th></tr><tr><td>Read</td><td>openForRead()</td><td>Open the file for reading</td></tr><tr><td>Write</td><td>openForWrite()</td><td>Open the file for writing to and replace its contents (if any)</td></tr><tr><td>Append</td><td>openForAppend()</td><td>Open the file and start writing at its end</td></tr></table>

Before you may work with a file you need to use one of the three above methods on the FileObject.

@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
%result = %fileWrite.OpenForWrite("./test.txt");

if ( %result )
{
   // Write a line to the text files
   %fileWrite.writeLine("READ. READ CODE. CODE");
}

// Close the file when finished
%fileWrite.close();

// Cleanup the file object
%fileWrite.delete();


// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%result = %fileRead.OpenForRead("./test.txt");

if ( %result )
{
   // Read in the first line
   %line = %fileRead.readline();

   // Print the line we just read
   echo(%line);
}

// Close the file when finished
%fileRead.close();

// Cleanup the file object
%fileRead.delete();
@endtsexample

@ingroup FileSystem
 */
class  FileObject : public SimObject {
  public:
   /*! Write binary data to the file, if it was opened for writing. */
   virtual void writeBinary((size, buffer)) {}
   /*! Get file size */
   virtual int getSize() {}
   /*! @brief Open a specified file for reading

There is no limit as to what kind of file you can read. Any format and data contained within is accessible, not just text

@param filename Path, name, and extension of file to be read@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%result = %fileRead.OpenForRead("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise
 */
   virtual bool openForRead(( string filename )) {}
   /*! @brief Open a specified file for writing

There is no limit as to what kind of file you can write. Any format and data is allowable, not just text

@param filename Path, name, and extension of file to write to@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
%result = %fileWrite.OpenForWrite("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise
 */
   virtual bool openForWrite(( string filename )) {}
   /*! @brief Open a specified file for writing, adding data to the end of the file

There is no limit as to what kind of file you can write. Any format and data is allowable, not just text. Unlike openForWrite(), which will erase an existing file if it is opened, openForAppend() preserves data in an existing file and adds to it.

@param filename Path, name, and extension of file to append to@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
// If it does exist, whatever we write will be added to the end
%result = %fileWrite.OpenForAppend("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise
 */
   virtual bool openForAppend(( string filename )) {}
   /*! @brief Determines if the parser for this FileObject has reached the end of the file

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Keep reading until we reach the end of the file
while( !%fileRead.isEOF() )
{
   %line = %fileRead.readline();
   echo(%line);
}

// Made it to the end
echo("Finished reading file");
@endtsexample

@return True if the parser has reached the end of the file, false otherwise
 */
   virtual bool isEOF(()) {}
   /*! @brief Read a line from file.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  There is no limitation as to what kind of data you can read.

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Read in the first line
%line = %fileRead.readline();

// Print the line we just read
echo(%line);
@endtsexample

@return String containing the line of data that was just read
 */
   virtual string readLine(()) {}
   /*! @brief Read a line from the file without moving the stream position.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data.  There is no limitation as to what kind of data you can read. Unlike readLine, the parser does not move forward after reading.

@param filename Path, name, and extension of file to be read@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Peek the first line
%line = %fileRead.peekLine();

// Print the line we just peeked
echo(%line);
// If we peek again...
%line = %fileRead.peekLine();

// We will get the same output as the first time
// since the stream did not move forward
echo(%line);
@endtsexample

@return String containing the line of data that was just peeked
 */
   virtual string peekLine(()) {}
   /*! @brief Write a line to the file, if it was opened for writing.

There is no limit as to what kind of text you can write. Any format and data is allowable, not just text. Be careful of what you write, as whitespace, current values, and literals will be preserved.

@param text The data we are writing out to file.@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
%fileWrite.OpenForWrite("./test.txt");

// Write a line to the text files
%fileWrite.writeLine("READ. READ CODE. CODE");

@endtsexample

@return True if file was successfully opened, false otherwise
 */
   virtual void writeLine(( string text )) {}
   /*! @brief Close the file.

It is EXTREMELY important that you call this function when you are finished reading or writing to a file. Failing to do so is not only a bad programming practice, but could result in bad data or corrupt files. Remember: Open, Read/Write, Close, Delete...in that order!

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Peek the first line
%line = %fileRead.peekLine();

// Print the line we just peeked
echo(%line);
// If we peek again...
%line = %fileRead.peekLine();

// We will get the same output as the first time
// since the stream did not move forward
echo(%line);

// Close the file when finished
%fileWrite.close();

// Cleanup the file object
%fileWrite.delete();
@endtsexample

 */
   virtual void close(()) {}
   /*! FileObject.writeObject(SimObject, object prepend)@hide */
   virtual void writeObject() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Base class for working with streams.

You do not instantiate a StreamObject directly.  Instead, it is used as part of a FileStreamObject and ZipObject to support working with uncompressed and compressed files respectively.@tsexample
// You cannot actually declare a StreamObject
// Instead, use the derived class "FileStreamObject"
%fsObject = FileStreamObject();
@endtsexample

@see FileStreamObject for the derived class usable in script.
@see ZipObject where StreamObject is used to read and write to files within a zip archive.
@ingroup FileSystem

 */
class  StreamObject : public SimObject {
  public:
   /*! @brief Gets a printable string form of the stream's status

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Get the status and print it
%status = %fsObject.getStatus();
echo(%status);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return String containing status constant, one of the following:

^OK - Stream is active and no file errors

^IOError - Something went wrong during read or writing the stream

^EOS - End of Stream reached (mostly for reads)

^IllegalCall - An unsupported operation used.  Always w/ accompanied by AssertWarn

  Closed - Tried to operate on a closed stream (or detached filter)

^UnknownError - Catch all for an error of some kind

^Invalid - Entire stream is invalid

 */
   virtual string getStatus(()) {}
   /*! @brief Tests if the stream has reached the end of the file

This is an alternative name for isEOF. Both functions are interchangeable. This simply exists for those familiar with some C++ file I/O standards.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Keep reading until we reach the end of the file
while( !%fsObject.isEOS() )
{
   %line = %fsObject.readLine();
   echo(%line);
}
// Made it to the end
echo("Finished reading file");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the parser has reached the end of the file, false otherwise
@see isEOF() */
   virtual bool isEOS(()) {}
   /*! @brief Tests if the stream has reached the end of the file

This is an alternative name for isEOS. Both functions are interchangeable. This simply exists for those familiar with some C++ file I/O standards.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Keep reading until we reach the end of the file
while( !%fsObject.isEOF() )
{
   %line = %fsObject.readLine();
   echo(%line);
}
// Made it to the end
echo("Finished reading file");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the parser has reached the end of the file, false otherwise
@see isEOS() */
   virtual bool isEOF(()) {}
   /*! @brief Gets the position in the stream

The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. For StreamObject, when you read in the line the position is increased by the number of characters parsed, the null terminator, and a newline.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains two lines of text repeated:
// Hello World
// Hello World
%fsObject.open("./test.txt", "read");

// Read in the first line
%line = %fsObject.readLine();

// Get the position of the stream
%position = %fsObject.getPosition();

// Print the current position
// Should be 13, 10 for the words, 1 for the space, 1 for the null terminator, and 1 for the newline
echo(%position);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Number of bytes which stream has parsed so far, null terminators and newlines are included
@see setPosition() */
   virtual int getPosition(()) {}
   /*! @brief Gets the position in the stream

The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. For StreamObject, when you read in the line the position is increased by the number of characters parsed, the null terminator, and a newline. Using setPosition allows you to skip to specific points of the file.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains the following two lines:
// 11111111111
// Hello World
%fsObject.open("./test.txt", "read");

// Skip ahead by 12, which will bypass the first line entirely
%fsObject.setPosition(12);

// Read in the next line
%line = %fsObject.readLine();

// Print the line just read in, should be "Hello World"
echo(%line);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Number of bytes which stream has parsed so far, null terminators and newlines are included
@see getPosition() */
   virtual bool setPosition(( int newPosition )) {}
   /*! @brief Gets the size of the stream

The size is dependent on the type of stream being used. If it is a file stream, returned value will be the size of the file. If it is a memory stream, it will be the size of the allocated buffer.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains the following two lines:
// HelloWorld
// HelloWorld
%fsObject.open("./test.txt", "read");

// Found out how large the file stream is
// Then print it to the console
// Should be 22
%streamSize = %fsObject.getStreamSize();
echo(%streamSize);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Size of stream, in bytes
 */
   virtual int getStreamSize(()) {}
   /*! @brief Read a line from the stream.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data. There is no limitation as to what kind of data you can read.

@tsexample
// Create a file stream object for reading
// This file contains the following two lines:
// HelloWorld
// HelloWorld
%fsObject = new FileStreamObject();

%fsObject.open("./test.txt", "read");

// Read in the first line
%line = %fsObject.readLine();

// Print the line we just read
echo(%line);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return String containing the line of data that was just read
@see writeLine() */
   virtual string readLine(()) {}
   /*! @brief Write a line to the stream, if it was opened for writing.

There is no limit as to what kind of data you can write. Any format and data is allowable, not just text. Be careful of what you write, as whitespace, current values, and literals will be preserved.

@param line The data we are writing out to file.@tsexample
// Create a file stream
%fsObject = new FileStreamObject();

// Open the file for writing
// If it does not exist, it is created. If it does exist, the file is cleared
%fsObject.open("./test.txt", "write");

// Write a line to the file
%fsObject.writeLine("Hello World");

// Write another line to the file
%fsObject.writeLine("Documentation Rocks!");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@see readLine() */
   virtual void writeLine(( string line )) {}
   /*! @brief Read in a string and place it on the string table.

@param caseSensitive If false then case will not be taken into account when attempting to match the read in string with what is already in the string table.
@return The string that was read from the stream.
@see writeString()@note When working with these particular string reading and writing methods, the stream begins with the length of the string followed by the string itself, and does not include a NULL terminator. */
   virtual string readSTString(( bool caseSensitive=false )) {}
   /*! @brief Read a string up to a maximum of 256 characters@return The string that was read from the stream.
@see writeString()@note When working with these particular string reading and writing methods, the stream begins with the length of the string followed by the string itself, and does not include a NULL terminator. */
   virtual string readString(()) {}
   /*! @brief Read in a string up to the given maximum number of characters.

@param maxLength The maximum number of characters to read in.
@return The string that was read from the stream.
@see writeLongString()@note When working with these particular string reading and writing methods, the stream begins with the length of the string followed by the string itself, and does not include a NULL terminator. */
   virtual string readLongString(( int maxLength )) {}
   /*! @brief Write out a string up to the maximum number of characters.

@param maxLength The maximum number of characters that will be written.
@param string The string to write out to the stream.
@see readLongString()@note When working with these particular string reading and writing methods, the stream begins with the length of the string followed by the string itself, and does not include a NULL terminator. */
   virtual void writeLongString(( int maxLength, string string )) {}
   /*! @brief Write out a string with a default maximum length of 256 characters.

@param string The string to write out to the stream
@param maxLength The maximum string length to write out with a default of 256 characters.  This value should not be larger than 256 as it is written to the stream as a single byte.
@see readString()@note When working with these particular string reading and writing methods, the stream begins with the length of the string followed by the string itself, and does not include a NULL terminator. */
   virtual void writeString(( string string, int maxLength=256 )) {}
   /*! @brief Copy from another StreamObject into this StreamObject

@param other The StreamObject to copy from.
@return True if the copy was successful.
 */
   virtual bool copyFrom(( SimObject other )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A wrapper around StreamObject for parsing text and data from files.

FileStreamObject inherits from StreamObject and provides some unique methods for working with strings.  If you're looking for general file handling, you may want to use FileObject.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Get the status and print it
%status = %fsObject.getStatus();
echo(%status);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@see StreamObject for the list of inherited functions variables
@see FileObject for general file handling.
@ingroup FileSystem
 */
class  FileStreamObject : public StreamObject {
  public:
   /*! @brief Open a file for reading, writing, reading and writing, or appending

Using "Read" for the open mode allows you to parse the contents of file, but not making modifications. "Write" will create a new file if it does not exist, or erase the contents of an existing file when opened. Write also allows you to modify the contents of the file.

"ReadWrite" will provide the ability to parse data (read it in) and manipulate data (write it out) interchangeably. Keep in mind the stream can move during each operation. Finally, "WriteAppend" will open a file if it exists, but will not clear the contents. You can write new data starting  at the end of the files existing contents.

@param filename Name of file to open
@param openMode One of "Read", "Write", "ReadWrite" or "WriteAppend"

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Get the status and print it
%status = %fsObject.getStatus();
echo(%status);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the file was successfully opened, false if something went wrong@see close() */
   virtual bool open(( string filename, string openMode )) {}
   /*! @brief Close the file. You can no longer read or write to it unless you open it again.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@see open() */
   virtual void close(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Provides access to a zip file.

A ZipObject add, delete and extract files that are within a zip archive.  You may also read and write directly to the files within the archive by obtaining a StreamObject for the file.@tsexample
// Open a zip archive, creating it if it doesn't exist
%archive = new ZipObject();
%archive.openArchive("testArchive.zip", Write);

// Add a file to the archive with the given name
%archive.addFile("./water.png", "water.png");

// Close the archive to save the changes
%archive.closeArchive();
@endtsexample

@note Behind the scenes all of the work is being done with the ZipArchive and StreamObject classes.
@see StreamObject when using methods such as openFileForRead() and openFileForWrite()

@ingroup FileSystem
 */
class  ZipObject : public SimObject {
  public:
   /*! @brief Open a zip archive for manipulation.

Once a zip archive is opened use the various ZipObject methods for working with the files within the archive.  Be sure to close the archive when you are done with it.

@param filename The path and file name of the zip archive to open.
@param accessMode One of read, write or readwrite
@return True is the archive was successfully opened.
@note If you wish to make any changes to the archive, be sure to open it with a write or readwrite access mode.
@see closeArchive() */
   virtual bool openArchive(( string filename, string accessMode="read" )) {}
   /*! @brief Close an already opened zip archive.

@see openArchive() */
   virtual void closeArchive(()) {}
   /*! @brief Open a file within the zip archive for reading.

Be sure to close the file when you are done with it.
@param filename The path and name of the file to open within the zip archive.
@return A standard StreamObject is returned for working with the file.
@note You must first open the zip archive before working with files within it.
@see closeFile()
@see openArchive() */
   virtual string openFileForRead(( string filename )) {}
   /*! @brief Open a file within the zip archive for writing to.

Be sure to close the file when you are done with it.
@param filename The path and name of the file to open within the zip archive.
@return A standard StreamObject is returned for working with the file.
@note You must first open the zip archive before working with files within it.
@see closeFile()
@see openArchive() */
   virtual string openFileForWrite(( string filename )) {}
   /*! @brief Close a previously opened file within the zip archive.

@param stream The StreamObject of a previously opened file within the zip archive.
@see openFileForRead()
@see openFileForWrite() */
   virtual void closeFile(( SimObject stream )) {}
   /*! @brief Add a file to the zip archive

@param filename The path and name of the file to add to the zip archive.
@param pathInZip The path and name to be given to the file within the zip archive.
@param replace If a file already exists within the zip archive at the same location as this new file, this parameter indicates if it should be replaced.  By default, it will be replaced.
@return True if the file was successfully added to the zip archive. */
   virtual bool addFile(( string filename, string pathInZip, bool replace=true )) {}
   /*! @brief Extact a file from the zip archive and save it to the requested location.

@param pathInZip The path and name of the file to be extracted within the zip archive.
@param filename The path and name to give the extracted file.

@return True if the file was successfully extracted. */
   virtual bool extractFile(( string pathInZip, string filename )) {}
   /*! @brief Deleted the given file from the zip archive

@param pathInZip The path and name of the file to be deleted from the zip archive.
@return True of the file was successfully deleted.
@note Files that have been deleted from the archive will still show up with a getFileEntryCount() until you close the archive.  If you need to have the file count up to date with only valid files within the archive, you could close and then open the archive again.
@see getFileEntryCount()
@see closeArchive()
@see openArchive() */
   virtual bool deleteFile(( string pathInZip )) {}
   /*! @brief Get the number of files within the zip archive.

Use getFileEntry() to retrive information on each file within the archive.

@return The number of files within the zip archive.
@note The returned count will include any files that have been deleted from the archive using deleteFile().  To clear out all deleted files, you could close and then open the archive again.
@see getFileEntry()
@see closeArchive()
@see openArchive() */
   virtual int getFileEntryCount(()) {}
   /*! @brief Get information on the requested file within the zip archive.

This methods provides five different pieces of information for the requested file:
<ul><li>filename - The path and name of the file within the zip archive</li><li>uncompressed size</li><li>compressed size</li><li>compression method</li><li>CRC32</li></ul>
Use getFileEntryCount() to obtain the total number of files within the archive.
@param index The index of the file within the zip archive.  Use getFileEntryCount() to determine the number of files.
@return A tab delimited list of information on the requested file, or an empty string if the file could not be found.
@see getFileEntryCount() */
   virtual string getFileEntry(( int index )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A strip shaped decal defined by spine nodes which clips against Terrain objects.

DecalRoad is for representing a road or path ( or other inventive things ) across a TerrainBlock. It renders as a decal and is therefore only for features that do not need geometric depth.

The Material assigned to DecalRoad should tile vertically.

 */
class  DecalRoad : public SceneObject {
  public:
   /*! Intended as a helper to developers and editor scripts.
Force DecalRoad to update it's spline and reclip geometry. */
   virtual void regenerate(()) {}
   /*! Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit the material and other fields ( not including nodes ) to client objects. */
   virtual void postApply(()) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNode(( int idx, Point3F pos )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeWidth(( int idx, float meters )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void addNode(( Point3F pos, float width )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void insertNode(( Point3F pos, float width, int idx )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void deleteNode(( int idx )) {}

   /*! @name DecalRoad
   @{ */
   /*! */
   /*!
   Material used for rendering.
   
    */
   string Material;
   /*!
   The length in meters of textures mapped to the DecalRoad
   
    */
   float textureLength;
   /*!
   Angle in degrees - DecalRoad will subdivided the spline if its curve is greater than this threshold.
   
    */
   float breakAngle;
   /*!
   DecalRoad(s) are rendered in descending renderPriority order.
   
    */
   int renderPriority;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   Do not modify, for internal use.
   
    */
   string Node;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A strip of rectangular mesh segments defined by a 3D spline for prototyping road-shaped objects in your scene.

User may control width and depth per node, overall spline shape in three dimensions, and seperate Materials for rendering the top, bottom, and side surfaces.

MeshRoad is not capable of handling intersections, branches, curbs, or other desirable features in a final 'road' asset and is therefore intended for prototyping and experimentation.

Materials assigned to MeshRoad should tile vertically.

 */
class  MeshRoad : public SceneObject {
  public:
   /*! Intended as a helper to developers and editor scripts.
Sets the depth in meters of a particular node. */
   virtual void setNodeDepth(( int idx, float meters )) {}
   /*! Intended as a helper to developers and editor scripts.
Force MeshRoad to recreate its geometry. */
   virtual void regenerate(()) {}
   /*! Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit material and other fields ( not including nodes ) to client objects. */
   virtual void postApply(()) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNode(( Point3F pos, float width, float depth, VectorF normal, int idx )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeWidth(( int idx, float meters )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void addNode(( Point3F pos, float width, float depth, VectorF normal )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void insertNode(( Point3F pos, float width, float depth, VectorF normal, int idx )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeNormal(( int idx, VectorF normal )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void deleteNode(( int idx )) {}

   /*! @name MeshRoad
   @{ */
   /*! */
   /*!
   Material for the upper surface of the road.
   
    */
   string topMaterial;
   /*!
   Material for the bottom surface of the road.
   
    */
   string bottomMaterial;
   /*!
   Material for the left, right, front, and back surfaces of the road.
   
    */
   string sideMaterial;
   /*!
   The length in meters of textures mapped to the MeshRoad.
   
    */
   float textureLength;
   /*!
   Angle in degrees - MeshRoad will subdivide the spline if its curve is greater than this threshold.
   
    */
   float breakAngle;
   /*!
   Subdivide segments widthwise this many times when generating vertices.
   
    */
   int widthSubdivisions;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   Do not modify, for internal use.
   
    */
   string Node;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A water volume defined by a 3D spline.

User may control width and depth per node and overall spline shape in three dimensions.

%River supports dynamic planar reflections (fullReflect) like all WaterObject classes, but keep in mind it is not necessarily a planar surface. For best visual quality a %River should be less reflective the more it twists and bends. This caution only applies to %Rivers with fullReflect on.

@see WaterObject for inherited functionality.

 */
class  River : public WaterObject {
  public:
   /*! Intended as a helper to developers and editor scripts.
Force River to recreate its geometry. */
   virtual void regenerate(()) {}
   /*! Intended as a helper to developers and editor scripts.
@see SegmentLength field. */
   virtual void setMetersPerSegment(( float meters )) {}
   /*! Intended as a helper to developers and editor scripts.
BatchSize is not currently used. */
   virtual void setBatchSize(( float meters )) {}
   /*! Intended as a helper to developers and editor scripts.
Sets the depth in meters of a particular node. */
   virtual void setNodeDepth(( int idx, float meters )) {}
   /*! Intended as a helper to developers and editor scripts.
@see SubdivideLength field. */
   virtual void setMaxDivisionSize(( float meters )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNode(( Point3F pos, float width, float depth, VectorF normal, int idx )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeWidth(( int idx, float meters )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeHeigth(( int idx, float height )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void addNode(( Point3F pos, float width, float depth, VectorF normal )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void insertNode(( Point3F pos, float width, float depth, VectorF normal, int idx )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void setNodeNormal(( int idx, VectorF normal )) {}
   /*! Set node position
@see SubdivideLength field. */
   virtual void deleteNode(( int idx )) {}

   /*! @name River
   @{ */
   /*! */
   /*!
   Divide the River lengthwise into segments of this length in meters. These geometric volumes are used for spacial queries like determining containment.
   
    */
   float SegmentLength;
   /*!
   For purposes of generating the renderable geometry River segments are further subdivided such that no quad is of greater width or length than this distance in meters.
   
    */
   float SubdivideLength;
   /*!
   Magnitude of the force vector applied to dynamic objects within the River.
   
    */
   float FlowMagnitude;
   /*!
   Segments of the river at this distance in meters or greater will render as a single unsubdivided without undulation effects.
   
    */
   float LowLODDistance;
   /// @}


   /*! @name Internal
   @{ */
   /*! */
   /*!
   For internal use, do not modify.
   
    */
   string Node;
   /// @}


   /*! @name WaterObject
   @{ */
   /*! */
   /// @}


   /*! @name Reflect
   @{ */
   /*! */
   /// @}


   /*! @name Underwater Fogging
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Distortion
   @{ */
   /*! */
   /// @}


   /*! @name Basic Lighting
   @{ */
   /*! */
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents both the sun and sky for scenes with a dynamic time of day.

%ScatterSky renders as a dome shaped mesh which is camera relative and always overhead. It is intended to be part of the background of your scene and renders before all other objects types.

%ScatterSky is designed for outdoor scenes which need to transition fluidly between radically different times of day. It will respond to time changes originating from a TimeOfDay object or the elevation field can be directly adjusted.

During day, %ScatterSky uses atmosphereic sunlight scattering aproximations to generate a sky gradient and sun corona. It also calculates the fog color, ambient color, and sun color, which are used for scene lighting. This is user controlled by fields within the ScatterSky group.

During night, %ScatterSky supports can transition to a night sky cubemap and moon sprite. The user can control this and night time colors used for scene lighting with fields within the Night group.

A scene with a ScatterSky should not have any other sky or sun objects as it already fulfills both roles.

%ScatterSky is intended to be used with CloudLayer and TimeOfDay as part of a scene with dynamic lighting. Having a %ScatterSky without a changing time of day would unnecessarily give up artistic control compared and fillrate compared to a SkyBox + Sun setup.

 */
class  ScatterSky : public SceneObject {
  public:
   /*! Apply a full network update of all fields to all clients. */
   virtual void applyChanges(()) {}

   /*! @name ScatterSky
   
   Only azimuth and elevation are networked fields. To trigger a full update of all other fields use the applyChanges ConsoleMethod.
   @{ */
   /*! */
   /*!
   Global brightness and intensity applied to the sky and objects in the level.
   
    */
   float skyBrightness;
   /*!
   Affects the size of the sun's disk.
   
    */
   float sunSize;
   /*!
   Controls how much the the alpha component of colorize brigthens the sky. Setting to 0 returns default behavior.
   
    */
   float colorizeAmount;
   /*!
   Tints the sky the color specified, the alpha controls the brigthness. The brightness is multipled by the value of colorizeAmt.
   
    */
   ColorF colorize;
   /*!
   Controls how blue the atmosphere is during the day.
   
    */
   float rayleighScattering;
   /*!
   Modulates the directional color of sunlight.
   
    */
   ColorF sunScale;
   /*!
   Modulates the ambient color of sunlight.
   
    */
   ColorF ambientScale;
   /*!
   Modulates the fog color. Note that this overrides the LevelInfo.fogColor property, so you should not use LevelInfo.fogColor if the level contains a ScatterSky object.
   
    */
   ColorF fogScale;
   /*!
   Controls the contrast of the sky and sun during daytime.
   
    */
   float exposure;
   /*!
   Offsets the scatterSky to hide canvas near the horizon.
   
    */
   float zoffset;
   /// @}


   /*! @name Orbit
   @{ */
   /*! */
   /*!
   The horizontal angle of the sun measured clockwise from the positive Y world axis. This field is networked.
   
    */
   float azimuth;
   /*!
   The elevation angle of the sun above or below the horizon. This field is networked.
   
    */
   float elevation;
   /*!
   The horizontal angle of the moon measured clockwise from the positive Y world axis. This is not animated by time or networked.
   
    */
   float moonAzimuth;
   /*!
   The elevation angle of the moon above or below the horizon. This is not animated by time or networked.
   
    */
   float moonElevation;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Enables/disables shadows cast by objects due to ScatterSky light.
   
    */
   bool castShadows;
   /*!
   The brightness of the ScatterSky's light object.
   
    */
   float brightness;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Datablock for the flare produced by the ScatterSky.
   
    */
   LightFlareData flareType;
   /*!
   Changes the size and intensity of the flare.
   
    */
   float flareScale;
   /// @}


   /*! @name Night
   @{ */
   /*! */
   /*!
   The ambient color during night. Also used for the sky color if useNightCubemap is false.
   
    */
   ColorF nightColor;
   /*!
   The fog color during night.
   
    */
   ColorF nightFogColor;
   /*!
   Enable or disable rendering of the moon sprite during night.
   
    */
   bool moonEnabled;
   /*!
   Material for the moon sprite.
   
    */
   string moonMat;
   /*!
   Controls size the moon sprite renders, specified as a fractional amount of the screen height.
   
    */
   float moonScale;
   /*!
   Color of light cast by the directional light during night.
   
    */
   ColorF moonLightColor;
   /*!
   Transition to the nightCubemap during night. If false we use nightColor.
   
    */
   bool useNightCubemap;
   /*!
   Cubemap visible during night.
   
    */
   string nightCubemap;
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /*!
   The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.
   
    */
   Point3F attenuationRatio;
   /*!
   The type of shadow to use on this light.
   
    */
   ShadowType shadowType;
   /*!
   A custom pattern texture which is projected from the light.
   
    */
   filename cookie;
   /*!
   The texture size of the shadow map.
   
    */
   int texSize;
   /*!
   The ESM shadow darkening factor
   
    */
   Point4F overDarkFactor;
   /*!
   The distance from the camera to extend the PSSM shadow.
   
    */
   float shadowDistance;
   /*!
   
   
    */
   float shadowSoftness;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   int numSplits;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   float logWeight;
   /*!
   Start fading shadows out at this distance.  0 = auto calculate this distance.
   
    */
   float fadeStartDistance;
   /*!
   This toggles only terrain being rendered to the last split of a PSSM shadow map.
   
    */
   bool lastSplitTerrainOnly;
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /*!
   This light is represented in lightmaps (static light, default: false)
   
    */
   bool representedInLightmap;
   /*!
   The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)
   
    */
   ColorF shadowDarkenColor;
   /*!
   This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)
   
    */
   bool includeLightmappedGeometryInShadow;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represents the sky with an artist-created cubemap.

SkyBox is not a directional light and should be used in conjunction with a Sun object.

 */
class  SkyBox : public SceneObject {
  public:
   virtual void postApply() {}

   /*! @name Sky Box
   @{ */
   /*! */
   /*!
   The name of a cubemap material for the sky box.
   
    */
   string Material;
   /*!
   If false the bottom of the skybox is not rendered.
   
    */
   bool drawBottom;
   /*!
   The height (0-1) of the fog band from the horizon to the top of the SkyBox.
   
    */
   float fogBandHeight;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A global light affecting your entire scene and optionally renders a corona effect.

Sun is both the directional and ambient light for your entire scene.

 */
class  Sun : public SceneObject {
  public:
   virtual void apply() {}
   /*! animate( F32 duration, F32 startAzimuth, F32 endAzimuth, F32 startElevation, F32 endElevation ) */
   virtual void animate() {}

   /*! @name Orbit
   @{ */
   /*! */
   /*!
   The horizontal angle of the sun measured clockwise from the positive Y world axis.
   
    */
   float azimuth;
   /*!
   The elevation angle of the sun above or below the horizon.
   
    */
   float elevation;
   /// @}


   /*! @name Lighting
   @{ */
   /*! */
   /*!
   Color shading applied to surfaces in direct contact with light source.
   
    */
   ColorF color;
   /*!
   Color shading applied to surfaces not in direct contact with light source, such as in the shadows or interiors.
   
    */
   ColorF ambient;
   /*!
   Adjust the Sun's global contrast/intensity
   
    */
   float brightness;
   /*!
   Enables/disables shadows cast by objects due to Sun light
   
    */
   bool castShadows;
   /// @}


   /*! @name Corona
   @{ */
   /*! */
   /*!
   Enable or disable rendering of the corona sprite.
   
    */
   bool coronaEnabled;
   /*!
   Texture for the corona sprite.
   
    */
   string coronaMaterial;
   /*!
   Controls size the corona sprite renders, specified as a fractional amount of the screen height.
   
    */
   float coronaScale;
   /*!
   Modulates the corona sprite color ( if coronaUseLightColor is false ).
   
    */
   ColorF coronaTint;
   /*!
   Modulate the corona sprite color by the color of the light ( overrides coronaTint ).
   
    */
   bool coronaUseLightColor;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Datablock for the flare produced by the Sun
   
    */
   LightFlareData flareType;
   /*!
   Changes the size and intensity of the flare.
   
    */
   float flareScale;
   /// @}


   /*! @name Advanced Lighting
   @{ */
   /*! */
   /*!
   The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.
   
    */
   Point3F attenuationRatio;
   /*!
   The type of shadow to use on this light.
   
    */
   ShadowType shadowType;
   /*!
   A custom pattern texture which is projected from the light.
   
    */
   filename cookie;
   /*!
   The texture size of the shadow map.
   
    */
   int texSize;
   /*!
   The ESM shadow darkening factor
   
    */
   Point4F overDarkFactor;
   /*!
   The distance from the camera to extend the PSSM shadow.
   
    */
   float shadowDistance;
   /*!
   
   
    */
   float shadowSoftness;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   int numSplits;
   /*!
   The logrithmic PSSM split distance factor.
   
    */
   float logWeight;
   /*!
   Start fading shadows out at this distance.  0 = auto calculate this distance.
   
    */
   float fadeStartDistance;
   /*!
   This toggles only terrain being rendered to the last split of a PSSM shadow map.
   
    */
   bool lastSplitTerrainOnly;
   /// @}


   /*! @name Advanced Lighting Lightmap
   @{ */
   /*! */
   /*!
   This light is represented in lightmaps (static light, default: false)
   
    */
   bool representedInLightmap;
   /*!
   The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)
   
    */
   ColorF shadowDarkenColor;
   /*!
   This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)
   
    */
   bool includeLightmappedGeometryInShadow;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Environmental object that triggers a day/night cycle in level.

@note TimeOfDay only works in Advanced Lighting with a Sub object or ScatterSky

@tsexample
new TimeOfDay(tod)
{
   axisTilt = "23.44";
   dayLength = "120";
   startTime = "0.15";
   time = "0.15";
   play = "0";
   azimuthOverride = "572.958";
   dayScale = "1";
   nightScale = "1.5";
   position = "598.399 550.652 196.297";
   rotation = "1 0 0 0";
   scale = "1 1 1";
   canSave = "1";
   canSaveDynamicFields = "1";
};
@endtsexample

 */
class  TimeOfDay : public SceneObject {
  public:
   virtual void addTimeOfDayEvent(( float elevation, string identifier )) {}
   virtual void setTimeOfDay(( float time )) {}
   virtual void setPlay(( bool enabled )) {}
   virtual void setDayLength(( float seconds )) {}
   virtual void animate(( float elevation, float degreesPerSecond )) {}
   virtual void ReSynchClocks(()) {}

   /*! @name TimeOfDay
   @{ */
   /*! */
   /*!
   The angle in degrees between global equator and tropic.
   
    */
   float axisTilt;
   /*!
   The length of a virtual day in real world seconds.
   
    */
   float dayLength;
   /*!
   
   
    */
   float startTime;
   /*!
   Current time of day.
   
    */
   float time;
   /*!
   True when the TimeOfDay object is operating.
   
    */
   bool play;
   /*!
   
   
    */
   float azimuthOverride;
   /*!
   Scalar applied to time that elapses while the sun is up.
   
    */
   float dayScale;
   /*!
   Scalar applied to time that elapses while the sun is down.
   
    */
   float nightScale;
   /*!
   Automatically initialize based on the curent time as set on the servers clock.
   
    */
   bool UseServerTime;
   /*!
   Time the sun should rise in seconds past midnight in the server timezone.
   
    */
   float SunriseTime;
   /*!
   Time the sun should set in seconds past midnight in the server timezone.
   
    */
   float SunsetTime;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief 3D view control used specifically by Torque 3D's editors.

For Torque 3D editors only, not for actual game development

@ingroup Editors
 */
class  EditTSCtrl : public GuiTSCtrl {
  public:
   virtual int getDisplayType(()) {}
   virtual void setDisplayType(( int displayType )) {}
   /*! Return the FOV for orthographic views. */
   virtual float getOrthoFOV(()) {}
   /*! Set the FOV for to use for orthographic views. */
   virtual void setOrthoFOV(( float fov )) {}
   virtual void renderBox(( Point3F pos, Point3F size )) {}
   virtual void renderSphere(( Point3F pos, float radius, int sphereLevel=0 )) {}
   virtual void renderCircle(( Point3F pos, Point3F normal, float radius, int segments=0 )) {}
   virtual void renderTriangle(( Point3F a, Point3F b, Point3F c )) {}
   virtual void renderLine(( Point3F start, Point3F end, float lineWidth=0 )) {}
   virtual int getGizmo(()) {}
   virtual bool isMiddleMouseDown(()) {}

   /*! @name Grid
   @{ */
   /*! */
   /*!
    */
   float gridSize;
   /*!
    */
   ColorI gridColor;
   /*!
    */
   ColorI gridOriginColor;
   /*!
    */
   ColorI gridMinorTickColor;
   /*!
   Whether to render the grid in orthographic axial projections.
   
    */
   bool renderOrthoGrid;
   /*!
   Grid patch pixel size below which to switch to coarser grid resolutions.
   
    */
   float renderOrthoGridPixelBias;
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /*!
    */
   bool renderMissionArea;
   /*!
    */
   ColorI missionAreaFillColor;
   /*!
    */
   ColorI missionAreaFrameColor;
   /*!
   How high above and below the terrain to render the mission area bounds.
   
    */
   float missionAreaHeightAdjust;
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /*!
    */
   bool allowBorderMove;
   /*!
    */
   int borderMovePixelSize;
   /*!
    */
   float borderMoveSpeed;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
    */
   ColorI consoleFrameColor;
   /*!
    */
   ColorI consoleFillColor;
   /*!
    */
   int consoleSphereLevel;
   /*!
    */
   int consoleCircleSegments;
   /*!
    */
   int consoleLineWidth;
   /*!
    */
   GizmoProfile GizmoProfile;
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI tool that makes up the Mesh Road Editor

Editor use only.

 */
class  GuiMeshRoadEditorCtrl : public EditTSCtrl {
  public:
   /*! deleteNode() */
   virtual void deleteNode() {}
   /*! deleteNode() */
   virtual void deleteLocalNode() {}
   virtual string getMode() {}
   /*! setMode( String mode ) */
   virtual void setMode() {}
   virtual float getNodeWidth() {}
   virtual void setNodeWidth() {}
   virtual float getNodeDepth() {}
   virtual void setNodeDepth() {}
   virtual string getNodePosition() {}
   virtual void setNodePosition() {}
   virtual string getNodeNormal() {}
   virtual void setNodeNormal() {}
   virtual void setSelectedRoad() {}
   virtual string getSelectedRoad() {}
   virtual void regenerate() {}
   virtual void matchTerrainToRoad() {}
   virtual bool setSelectedMeshRoadNode() {}
   /*!
    */
   float DefaultWidth;
   /*!
    */
   float DefaultDepth;
   /*!
    */
   Point3F DefaultNormal;
   /*!
    */
   ColorI HoverSplineColor;
   /*!
    */
   ColorI SelectedSplineColor;
   /*!
    */
   ColorI HoverNodeColor;
   /*!
    */
   bool isDirty;
   /*!
   Default Material used by the Mesh Road Editor on upper surface road creation.
   
    */
   string topMaterialName;
   /*!
   Default Material used by the Mesh Road Editor on bottom surface road creation.
   
    */
   string bottomMaterialName;
   /*!
   Default Material used by the Mesh Road Editor on side surface road creation.
   
    */
   string sideMaterialName;

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI tool that makes up the River Editor

Editor use only.

 */
class  GuiRiverEditorCtrl : public EditTSCtrl {
  public:
   /*! deleteNode() */
   virtual void deleteNode() {}
   /*! deleteNode() */
   virtual void deleteLocalNode() {}
   virtual string getMode() {}
   /*! setMode( String mode ) */
   virtual void setMode() {}
   virtual float getNodeWidth() {}
   virtual void setNodeWidth() {}
   virtual float getNodeDepth() {}
   virtual void setNodeDepth() {}
   virtual string getNodePosition() {}
   virtual void setNodePosition() {}
   virtual string getNodeNormal() {}
   virtual void setNodeNormal() {}
   virtual void setSelectedRiver() {}
   virtual bool setSelectedRiverNode() {}
   virtual string getSelectedRiver() {}
   virtual void regenerate() {}
   /*!
    */
   float DefaultWidth;
   /*!
    */
   float DefaultDepth;
   /*!
    */
   Point3F DefaultNormal;
   /*!
    */
   ColorI HoverSplineColor;
   /*!
    */
   ColorI SelectedSplineColor;
   /*!
    */
   ColorI HoverNodeColor;
   /*!
    */
   bool isDirty;

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI tool that makes up the Decal Road Editor

Editor use only.

 */
class  GuiRoadEditorCtrl : public EditTSCtrl {
  public:
   /*! deleteNode() */
   virtual void deleteNode() {}
   /*! deleteLocalNode() */
   virtual void deleteLocalNode() {}
   virtual string getMode() {}
   /*! setMode( String mode ) */
   virtual void setMode() {}
   virtual float getNodeWidth() {}
   virtual void setNodeWidth() {}
   virtual string getNodePosition() {}
   virtual void setNodePosition() {}
   virtual void setSelectedRoad() {}
   virtual string getSelectedRoad() {}
   virtual int getSelectedNode() {}
   virtual void deleteRoad() {}
   virtual bool setSelectedDecalRoadNode() {}
   /*!
    */
   float DefaultWidth;
   /*!
    */
   ColorI HoverSplineColor;
   /*!
    */
   ColorI SelectedSplineColor;
   /*!
    */
   ColorI HoverNodeColor;
   /*!
    */
   bool isDirty;
   /*!
   Default Material used by the Road Editor on road creation.
   
    */
   string materialName;

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief %Forest is a global-bounds scene object provides collision and rendering for a (.forest) data file.

%Forest is designed to efficiently render a large number of static meshes: trees, rocks plants, etc. These cannot be moved at game-time or play animations but do support wind effects using vertex shader transformations guided by vertex color in the asset and user placed wind emitters ( or weapon explosions ).

Script level manipulation of forest data is not possible through %Forest, it is only the rendering/collision. All editing is done through the world editor.

@see TSForestItemData Defines a tree type.
@see GuiForestEditorCtrl Used by the world editor to provide manipulation of forest data.
 */
class  Forest : public SceneObject {
  public:
   /*! saveDataFile( [path] ) */
   virtual bool saveDataFile() {}
   virtual bool isDirty(()) {}
   virtual void regenCells(()) {}
   virtual void clear(()) {}

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

   /*!
   The source forest data file.
   
    */
   filename dataFile;

   /*! @name Lod
   @{ */
   /*! */
   /*!
   Scalar applied to the farclip distance when Forest renders into a reflection.
   
    */
   float lodReflectScalar;
   /// @}

};

/*!
@brief Object responsible for simulating wind in a level.

When placed in the level, a ForestWindEmitter will cause tree branches to bend and sway, leaves to flutter, and create vertical bending on the tree's trunk.

@tsexample
// The following is a full declaration of a wind emitter
new ForestWindEmitter()
{
   position = "497.739 765.821 102.395";
   windEnabled = "1";
   radialEmitter = "1";
   strength = "1";
   radius = "3";
   gustStrength = "0.5";
   gustFrequency = "1";
   gustYawAngle = "10";
   gustYawFrequency = "4";
   gustWobbleStrength = "2";
   turbulenceStrength = "1";
   turbulenceFrequency = "2";
   hasMount = "0";
   scale = "3 3 3";
   canSave = "1";
   canSaveDynamicFields = "1";
   rotation = "1 0 0 0";
};
@endtsexample

@ingroup FX
@ingroup Forest
@ingroup Atmosphere
 */
class  ForestWindEmitter : public SceneObject {
  public:
   /*! @brief Mounts the wind emitter to another scene object

@param objectID Unique ID of the object wind emitter should attach to@tsexample
// Wind emitter previously created and named %windEmitter
// Going to attach it to the player, making him a walking wind storm
%windEmitter.attachToObject(%player);
@endtsexample

 */
   virtual void attachToObject(( int objectID )) {}

   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}


   /*! @name ForestWind
   @{ */
   /*! */
   /*!
   Determines if the emitter will be counted in wind calculations.
   
    */
   bool windEnabled;
   /*!
   Determines if the emitter is a global direction or local radial emitter.
   
    */
   bool radialEmitter;
   /*!
   The strength of the wind force.
   
    */
   float strength;
   /*!
   The radius of the emitter for local radial emitters.
   
    */
   float radius;
   /*!
   The maximum strength of a gust.
   
    */
   float gustStrength;
   /*!
   The frequency of gusting in seconds.
   
    */
   float gustFrequency;
   /*!
   The amount of degrees the wind direction can drift (both positive and negative).
   
    */
   float gustYawAngle;
   /*!
   The frequency of wind yaw drift, in seconds.
   
    */
   float gustYawFrequency;
   /*!
   The amount of random wobble added to gust and turbulence vectors.
   
    */
   float gustWobbleStrength;
   /*!
   The strength of gust turbulence.
   
    */
   float turbulenceStrength;
   /*!
   The frequency of gust turbulence, in seconds.
   
    */
   float turbulenceFrequency;
   /*!
   Determines if the emitter is mounted to another object.
   
    */
   bool hasMount;
   /// @}

};

/*!
@brief Container class for ForestBrushElements

Editor use only.

 */
class  ForestBrush : public SimGroup {
  public:
   virtual bool containsItemData(( ForestItemData obj )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Defines the brush properties when painting trees in Forest Editor

Editor use only.

 */
class  ForestBrushTool : public ForestTool {
  public:
   virtual void collectElements() {}

   /*! @name ForestBrushTool
   @{ */
   /*! */
   /*!
    */
   ForestBrushMode mode;
   /*!
   Brush Size
   
    */
   float size;
   /*!
   Brush Pressure
   
    */
   float pressure;
   /*!
   Brush Hardness
   
    */
   float hardness;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The actual Forest Editor control

Editor use only, should not be modified.

 */
class  ForestEditorCtrl : public EditTSCtrl {
  public:
   virtual void updateActiveForest(()) {}
   virtual void setActiveTool(( ForestTool tool )) {}
   virtual int getActiveTool(()) {}
   virtual void deleteMeshSafe(( ForestItemData obj )) {}
   virtual bool isDirty() {}

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Specialized selection tool for picking individual trees in a forest.

Editor use only.

 */
class  ForestSelectionTool : public ForestTool {
  public:
   virtual int getSelectionCount() {}
   virtual void deleteSelection() {}
   virtual void clearSelection() {}
   virtual void cutSelection() {}
   virtual void copySelection() {}
   virtual void pasteSelection() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  GFXCardProfilerAPI {
  public:
   /*! Returns the driver version string. */
   virtual string getVersion(()) {}
   /*! Returns the card name. */
   virtual string getCard(()) {}
   /*! Returns the card vendor name. */
   virtual string getVendor(()) {}
   /*! Returns the renderer name.  For example D3D9 or OpenGL. */
   virtual string getRenderer(()) {}
   /*! Returns the amount of video memory in megabytes. */
   virtual int getVideoMemoryMB(()) {}
   /*! Used to set the value for a specific card capability.
@param name The name of the capability being set.
@param value The value to set for that capability. */
   virtual void setCapability(( string name, int value )) {}
   /*! Used to query the value of a specific card capability.
@param name The name of the capability being queried.
@param defaultValue The value to return if the capability is not defined. */
   virtual int queryProfile(( string name, int defaultValue )) {}
};

class  GFXInit {
  public:
   /*! Return the number of graphics adapters available. @ingroup GFX */
   virtual int getAdapterCount(()) {}
   /*! Returns the name of the graphics adapter.
@param index The index of the adapter. */
   virtual string getAdapterName(( int index )) {}
   /*! Returns the name of the graphics adapter's output display device.
@param index The index of the adapter. */
   virtual string getAdapterOutputName(( int index )) {}
   /*! Returns the type (D3D9, D3D8, GL, Null) of a graphics adapter.
@param index The index of the adapter. */
   virtual string getAdapterType(( int index )) {}
   /*! Returns the supported shader model of the graphics adapter or -1 if the index is bad.
@param index The index of the adapter. */
   virtual float getAdapterShaderModel(( int index )) {}
   /*! Returns the index of the default graphics adapter.  This is the graphics device which will be used to initialize the engine. */
   virtual int getDefaultAdapterIndex(()) {}
   /*! Gets the number of modes available on the specified adapter.

@param index Index of the adapter to get modes from.
@return The number of video modes supported by the adapter or -1 if the given adapter was not found. */
   virtual int getAdapterModeCount(( int index )) {}
   /*! Gets the details of the specified adapter mode.

@param index Index of the adapter to query.
@param modeIndex Index of the mode to get data from.
@return A video mode string in the format 'width height fullscreen bitDepth refreshRate aaLevel'.
@see GuiCanvas::getVideoMode() */
   virtual string getAdapterMode(( int index, int modeIndex )) {}
   /*! Create the NULL graphics device used for testing or headless operation. */
   virtual void createNullDevice(()) {}
};

/*!
@brief Used to create static or dynamic cubemaps.

This object is used with Material, WaterObject, and other objects for cubemap reflections.

A simple declaration of a static cubemap:
@tsexample
singleton CubemapData( SkyboxCubemap )
{
   cubeFace[0] = "./skybox_1";
   cubeFace[1] = "./skybox_2";
   cubeFace[2] = "./skybox_3";
   cubeFace[3] = "./skybox_4";
   cubeFace[4] = "./skybox_5";
   cubeFace[5] = "./skybox_6";
};
@endtsexample
@note The dynamic cubemap functionality in CubemapData has been depreciated in favor of ReflectorDesc.
@see ReflectorDesc
@ingroup GFX
 */
class  CubemapData : public SimObject {
  public:
   /*! Update the assigned cubemaps faces. */
   virtual void updateFaces(()) {}
   /*! Returns the script filename of where the CubemapData object was defined.  This is used by the material editor. */
   virtual string getFilename(()) {}
   /*!
   @brief The 6 cubemap face textures for a static cubemap.

They are in the following order:
  - cubeFace[0] is -X
  - cubeFace[1] is +X
  - cubeFace[2] is -Z
  - cubeFace[3] is +Z
  - cubeFace[4] is -Y
  - cubeFace[5] is +Y

   
    */
   filename cubeFace;
   /*!
   Set to true if this is a dynamic cubemap.  The default is false.
   
    */
   bool dynamic;
   /*!
   The size of each dynamic cubemap face in pixels.
   
    */
   int dynamicSize;
   /*!
   The near clip distance used when rendering to the dynamic cubemap.
   
    */
   float dynamicNearDist;
   /*!
   The far clip distance used when rendering to the dynamic cubemap.
   
    */
   float dynamicFarDist;
   /*!
   The typemask used to filter the objects rendered to the dynamic cubemap.
   
    */
   int dynamicObjectTypeMask;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Definition of a named texture target playing a Theora video.

TheoraTextureObject defines a named texture target that may play back a Theora video.  This texture target can, for example, be used by materials to texture objects with videos.

@tsexample
// The object that provides the video texture and controls its playback.
singleton TheoraTextureObject( TheVideo )
{
   // Unique name for the texture target for referencing in materials.
   texTargetName = "video";

   // Path to the video file.
   theoraFile = "./MyVideo.ogv";
};

// Material that uses the video texture.
singleton Material( TheVideoMaterial )
{
   // This has to reference the named texture target defined by the
   // TheoraTextureObject's 'texTargetName' property.  Prefix with '#' to
   // identify as texture target reference.
   diffuseMap[ 0 ] = "#video";
};
@endtsexample

 */
class  TheoraTextureObject : public SimObject {
  public:
   /*! Start playback of the video. */
   virtual void play(()) {}
   /*! Stop playback of the video. */
   virtual void stop(()) {}
   /*! Pause playback of the video. */
   virtual void pause(()) {}

   /*! @name Theora
   @{ */
   /*! */
   /*!
   Theora video file to play.
   
    */
   filename theoraFile;
   /*!
   Name of the texture target by which the texture can be referenced in materials.
   
    */
   string texTargetName;
   /*!
   Sound description to use for the video's audio channel.

If not set, will use a default one.
   
    */
   SFXDescription SFXDescription;
   /*!
   Should the video loop.
   
    */
   bool Loop;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Draws the bitmap within a special button control.  Only a single bitmap is used and the
button will be drawn in a highlighted mode when the mouse hovers over it or when it
has been clicked.

@tsexample
new GuiIconButtonCtrl(TestIconButton)
{
^buttonMargin = "4 4";
^iconBitmap = "art/gui/lagIcon.png";
^iconLocation = "Center";
^sizeIconToButton = "0";
^makeIconSquare = "1";
^textLocation = "Bottom";
^textMargin = "-2";
^autoSize = "0";
^text = "Lag Icon";
^textID = ""STR_LAG"";
^buttonType = "PushButton";
^profile = "GuiIconButtonProfile";
};
@endtsexample

@see GuiControl
@see GuiButtonCtrl

@ingroup GuiCore
 */
class  GuiIconButtonCtrl : public GuiButtonCtrl {
  public:
   /*! @brief Set the bitmap to use for the button portion of this control.

@param buttonFilename Filename for the image
@tsexample
// Define the button filename
%buttonFilename = "pearlButton";

// Inform the GuiIconButtonCtrl control to update its main button graphic to the defined bitmap
%thisGuiIconButtonCtrl.setBitmap(%buttonFilename);
@endtsexample

@see GuiControl
@see GuiButtonCtrl

 */
   virtual void setBitmap(( string buttonFilename )) {}
   /*!
   Margin area around the button.

   
    */
   Point2I buttonMargin;
   /*!
   Bitmap file for the icon to display on the button.

   
    */
   filename iconBitmap;
   /*!
   Where to place the icon on the control. Options are 0 (None), 1 (Left), 2 (Right), 3 (Center).

   
    */
   GuiIconButtonIconLocation iconLocation;
   /*!
   If true, the icon will be scaled to be the same size as the button.

   
    */
   bool sizeIconToButton;
   /*!
   If true, will make sure the icon is square.

   
    */
   bool makeIconSquare;
   /*!
   Where to place the text on the control.
Options are 0 (None), 1 (Bottom), 2 (Right), 3 (Top), 4 (Left), 5 (Center).

   
    */
   GuiIconButtonTextLocation textLocation;
   /*!
   Margin between the icon and the text.

   
    */
   int textMargin;
   /*!
   If true, the text and icon will be automatically sized to the size of the control.

   
    */
   bool autoSize;

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A button that is used to represent color; often used in correlation with a color picker.

A swatch button is a push button that uses its color field to designate the color drawn over an image, on top of a button.

The color itself is a float value stored inside the GuiSwatchButtonCtrl::color field. The texture path that represents
the image underlying the color is stored inside the GuiSwatchButtonCtrl::gridBitmap field.
The default value assigned toGuiSwatchButtonCtrl::color is "1 1 1 1"( White ). The default/fallback image assigned to 
GuiSwatchButtonCtrl::gridBitmap is "tools/gui/images/transp_grid".

@tsexample
// Create a GuiSwatchButtonCtrl that calls randomFunction with its current color when clicked
%swatchButton = new GuiSwatchButtonCtrl()
{
   profile = "GuiInspectorSwatchButtonProfile";
   command = "randomFunction( $ThisControl.color );";
};
@endtsexample

 */
class  GuiSwatchButtonCtrl : public GuiButtonBaseCtrl {
  public:
   /*! Set the color of the swatch control.
@param newColor The new color string given to the swatch control in float format "r g b a".
@note It's also important to note that when setColor is called causes
the control's altCommand field to be executed. */
   virtual void setColor(( string newColor )) {}
   /*!
   The foreground color of GuiSwatchButtonCtrl
   
    */
   ColorF color;
   /*!
   The bitmap used for the transparent grid
   
    */
   string gridBitmap;

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Unimplemented GUI control meant to interact with Toolbox.

For Torque 3D editors only, soon to be deprecated

 */
class  GuiToolboxButtonCtrl : public GuiButtonCtrl {
  public:
   /*! sets the bitmap that shows when the button is active */
   virtual void setNormalBitmap(( filepath name )) {}
   /*! sets the bitmap that shows when the button is disabled */
   virtual void setLoweredBitmap(( filepath name )) {}
   /*! sets the bitmap that shows when the button is disabled */
   virtual void setHoverBitmap(( filepath name )) {}
   /*!
    */
   filename normalBitmap;
   /*!
    */
   filename loweredBitmap;
   /*!
    */
   filename hoverBitmap;

   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Brief Description.

This Gui Control is designed to be subclassed to let people create controls which want to receive update ticks at a constant interval. This class was created to be the Parent class of a control which used a DynamicTexture along with a VectorField to create warping effects much like the ones found in visualization displays for iTunes or Winamp. Those displays are updated at the framerate frequency. This works fine for those effects, however for an application of the same type of effects for things like Gui transitions the framerate-driven update frequency is not desirable because it does not allow the developer to be able to have any idea of a consistent user-experience.

Enter the ITickable interface. This lets the Gui control, in this case, update the dynamic texture at a constant rate of once per tick, even though it gets rendered every frame, thus creating a framerate-independent update frequency so that the effects are at a consistent speed regardless of the specifics of the system the user is on. This means that the screen-transitions will occur in the same time on a machine getting 300fps in the Gui shell as a machine which gets 150fps in the Gui shell.

@ingroup GuiUtil
 */
class  GuiTickCtrl : public GuiControl {
  public:
   /*! This will set this object to either be processing ticks or not */
   virtual void setProcessTicks(( [tick = true] )) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that scrolls its child control up over time.

This container can be used to scroll a single child control in either of the four directions.

@tsexample
// Create a GuiAutoScrollCtrl that scrolls a long text of credits.
new GuiAutoScrollCtrl( CreditsScroller )
{
   position = "0 0";
   extent = Canvas.extent.x SPC Canvas.extent.y;

   scrollDirection = "Up"; // Scroll upwards.
   startDelay = 4; // Wait 4 seconds before starting to scroll.
   isLooping = false; // Don't loop the credits.
   scrollOutOfSight = true; // Scroll up fully.

   new GuiMLTextCtrl()
   {
      text = $CREDITS;
   };
};

function CreditsScroller::onComplete( %this )
{
   // Switch back to main menu after credits have rolled.
   Canvas.setContent( MainMenu );
}

// Start rolling credits.
Canvas.setContent( CreditsScroller );
@endtsexample

@note Only the first child will be scrolled.

 */
class  GuiAutoScrollCtrl : public GuiTickCtrl {
  public:
      /*! Called every 32ms on the control. */
      void onTick();

      /*! Called when the control starts to scroll. */
      void onStart();

      /*! Called when the child control has been scrolled in entirety. */
      void onComplete();

      /*! Called when the child control is reset to its initial position and the cycle starts again. */
      void onReset();

   /*! Reset scrolling. */
   virtual void reset(()) {}

   /*! @name Scrolling
   @{ */
   /*! */
   /*!
   Direction in which the child control is moved.
   
    */
   GuiAutoScrollDirection scrollDirection;
   /*!
   Seconds to wait before starting to scroll.
   
    */
   float startDelay;
   /*!
   Seconds to wait after scrolling completes before resetting and starting over.

@note Only takes effect if #isLooping is true.
   
    */
   float resetDelay;
   /*!
   Padding to put around child control (in pixels).
   
    */
   int childBorder;
   /*!
   Scrolling speed in pixels per second.
   
    */
   float scrollSpeed;
   /*!
   If true, the scrolling will reset to the beginning once completing a cycle.
   
    */
   bool isLooping;
   /*!
   If true, the child control will be completely scrolled out of sight; otherwise it will only scroll until the other end becomes visible.
   
    */
   bool scrollOutOfSight;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container control that can be used to implement drag&drop behavior.

GuiDragAndDropControl is a special control that can be used to allow drag&drop behavior to be implemented where GuiControls may be dragged across the canvas and the dropped on other GuiControls.

To start a drag operation, construct a GuiDragAndDropControl and add the control that should be drag&dropped as a child to it.  Note that this must be a single child control.  To drag multiple controls, wrap them in a new GuiControl object as a temporary container.

Then, to initiate the drag, add the GuiDragAndDropControl to the canvas and call startDragging().  You can optionally supply an offset to better position the GuiDragAndDropControl on the mouse cursor.

As the GuiDragAndDropControl is then moved across the canvas, it will call the onControlDragEnter(), onControlDragExit(), onControlDragged(), and finally onControlDropped() callbacks on the visible topmost controls that it moves across.  onControlDropped() is called when the mouse button is released and the drag operation thus finished.

@tsexample
// The following example implements drag&drop behavior for GuiSwatchButtonCtrl so that
// one color swatch may be dragged over the other to quickly copy its color.
//
// This code is taken from the stock scripts.

//---------------------------------------------------------------------------------------------

// With this method, we start the operation when the mouse is click-dragged away from a color swatch.
function GuiSwatchButtonCtrl::onMouseDragged( %this )
{
   // First we construct a new temporary swatch button that becomes the payload for our
   // drag operation and give it the properties of the swatch button we want to copy.

   %payload = new GuiSwatchButtonCtrl();
   %payload.assignFieldsFrom( %this );
   %payload.position = "0 0";
   %payload.dragSourceControl = %this; // Remember where the drag originated from so that we don't copy a color swatch onto itself.

   // Calculate the offset of the GuiDragAndDropControl from the mouse cursor.  Here we center
   // it on the cursor.

   %xOffset = getWord( %payload.extent, 0 ) / 2;
   %yOffset = getWord( %payload.extent, 1 ) / 2;

   // Compute the initial position of the GuiDragAndDrop control on the cavas based on the current
   // mouse cursor position.

   %cursorpos = Canvas.getCursorPos();
   %xPos = getWord( %cursorpos, 0 ) - %xOffset;
   %yPos = getWord( %cursorpos, 1 ) - %yOffset;

   // Create the drag control.

   %ctrl = new GuiDragAndDropControl()
   {
      canSaveDynamicFields    = "0";
      Profile                 = "GuiSolidDefaultProfile";
      HorizSizing             = "right";
      VertSizing              = "bottom";
      Position                = %xPos SPC %yPos;
      extent                  = %payload.extent;
      MinExtent               = "4 4";
      canSave                 = "1";
      Visible                 = "1";
      hovertime               = "1000";

      // Let the GuiDragAndDropControl delete itself on mouse-up.  When the drag is aborted,
      // this not only deletes the drag control but also our payload.
      deleteOnMouseUp         = true;

      // To differentiate drags, use the namespace hierarchy to classify them.
      // This will allow a color swatch drag to tell itself apart from a file drag, for example.
      class                   = "GuiDragAndDropControlType_ColorSwatch";
   };

   // Add the temporary color swatch to the drag control as the payload.
   %ctrl.add( %payload );

   // Start drag by adding the drag control to the canvas and then calling startDragging().

   Canvas.getContent().add( %ctrl );
   %ctrl.startDragging( %xOffset, %yOffset );
}

//---------------------------------------------------------------------------------------------

// This method receives the drop when the mouse button is released over a color swatch control
// during a drag operation.
function GuiSwatchButtonCtrl::onControlDropped( %this, %payload, %position )
{
   // Make sure this is a color swatch drag operation.
   if( !%payload.parentGroup.isInNamespaceHierarchy( "GuiDragAndDropControlType_ColorSwatch" ) )
      return;

   // If dropped on same button whence we came from,
   // do nothing.

   if( %payload.dragSourceControl == %this )
      return;

   // If a swatch button control is dropped onto this control,
   // copy it's color.

   if( %payload.isMemberOfClass( "GuiSwatchButtonCtrl" ) )
   {
      // If the swatch button is part of a color-type inspector field,
      // remember the inspector field so we can later set the color
      // through it.

      if( %this.parentGroup.isMemberOfClass( "GuiInspectorTypeColorI" ) )
         %this.parentGroup.apply( ColorFloatToInt( %payload.color ) );
      else if( %this.parentGroup.isMemberOfClass( "GuiInspectorTypeColorF" ) )
         %this.parentGroup.apply( %payload.color );
      else
         %this.setColor( %payload.color );
   }
}
@endtsexample

@see GuiControl::onControlDragEnter
@see GuiControl::onControlDragExit
@see GuiControl::onControlDragged
@see GuiControl::onControlDropped

 */
class  GuiDragAndDropControl : public GuiControl {
  public:
   /*! Start the drag operation.

@param x X coordinate for the mouse pointer offset which the drag control should position itself.
@param y Y coordinate for the mouse pointer offset which the drag control should position itself. */
   virtual void startDragging(( int x=0, int y=0 )) {}
   /*!
   If true, the control deletes itself when the left mouse button is released.

If at this point, the drag&drop control still contains its payload, it will be deleted along with the control.
   
    */
   bool deleteOnMouseUp;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that arranges children into a grid.

This container maintains a 2D grid of GUI controls. If one is added, deleted, or resized, then the grid is updated. The insertion order into the grid is determined by the internal order of the children (ie. the order of addition).<br>Children are added to the grid by row or column until they fill the assocated GuiDynamicCtrlArrayControl extent (width or height). For example, a GuiDynamicCtrlArrayControl with 15 children, and <i>fillRowFirst</i> set to true may be arranged as follows:

<pre>
1  2  3  4  5  6
7  8  9  10 11 12
13 14 15
</pre>
If <i>dynamicSize</i> were set to true in this case, the GuiDynamicCtrlArrayControl height would be calculated to fit the 3 rows of child controls.

@tsexample
new GuiDynamicCtrlArrayControl()
{
   colSize = "128";
   rowSize = "18";
   colSpacing = "2";
   rowSpacing = "2";
   frozen = "0";
   autoCellSize = "1";
   fillRowFirst = "1";
   dynamicSize = "1";
   padding = "0 0 0 0";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiDynamicCtrlArrayControl : public GuiControl {
  public:
   /*! Recalculates the position and size of this control and all its children. */
   virtual void refresh(()) {}
   /*!
   Number of columns the child controls have been arranged into. This value is calculated automatically when children are added, removed or resized; writing it directly has no effect.
   
    */
   int colCount;
   /*!
   Width of each column. If <i>autoCellSize</i> is set, this will be calculated automatically from the widest child control
   
    */
   int colSize;
   /*!
   Number of rows the child controls have been arranged into. This value is calculated automatically when children are added, removed or resized; writing it directly has no effect.
   
    */
   int rowCount;
   /*!
   Height of each row. If <i>autoCellSize</i> is set, this will be calculated automatically from the tallest child control
   
    */
   int rowSize;
   /*!
   Spacing between rows
   
    */
   int rowSpacing;
   /*!
   Spacing between columns
   
    */
   int colSpacing;
   /*!
   When true, the array will not update when new children are added or in response to child resize events. This is useful to prevent unnecessary resizing when adding, removing or resizing a number of child controls.
   
    */
   bool frozen;
   /*!
   When true, the cell size is set to the widest/tallest child control.
   
    */
   bool autoCellSize;
   /*!
   Controls whether rows or columns are filled first.

If true, controls are added to the grid left-to-right (to fill a row); then rows are added top-to-bottom as shown below:
<pre>1 2 3 4
5 6 7 8</pre>
If false, controls are added to the grid top-to-bottom (to fill a column); then columns are added left-to-right as shown below:
<pre>1 3 5 7
2 4 6 8</pre>
   
    */
   bool fillRowFirst;
   /*!
   If true, the width or height of this control will be automatically calculated based on the number of child controls (width if <i>fillRowFirst</i> is false, height if <i>fillRowFirst</i> is true).
   
    */
   bool dynamicSize;
   /*!
   Padding around the top, bottom, left, and right of this control. This reduces the area available for child controls.
   
    */
   RectSpacingI padding;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A generic form control.

Currently editor use only.

 */
class  GuiFormCtrl : public GuiPanel {
  public:
      /*! Called when the control is resized. */
      void onResize();

   /*! Get the ID of this form's menu.

@return The ID of the form menu
 */
   virtual int getMenuID(()) {}
   /*! Sets the title of the form.

@param caption Form caption
 */
   virtual void setCaption(( string caption )) {}
   /*!
    */
   string caption;
   /*!
    */
   string contentLibrary;
   /*!
    */
   string content;
   /*!
    */
   bool movable;
   /*!
   
   
    */
   bool hasMenu;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A gui control allowing a window to be subdivided into panes, each of which displays a gui control child of the GuiFrameSetCtrl.

Each gui control child will have an associated FrameDetail through which frame-specific details can be assigned. Frame-specific values override the values specified for the entire frameset.

Note that it is possible to have more children than frames, or more frames than children. In the former case, the extra children will not be visible (they are moved beyond the visible extent of the frameset). In the latter case, frames will be empty. For example, if a frameset had two columns and two rows but only three gui control children they would be assigned to frames as follows:
<pre>
                 1 | 2
                 -----
                 3 |
</pre>
The last frame would be blank.

@tsexample
new GuiFrameSetCtrl()
{
   columns = "3";
   rows = "2";
   borderWidth = "1";
   borderColor = "128 128 128";
   borderEnable = "dynamic";
   borderMovable = "dynamic";
   autoBalance = "1";
   fudgeFactor = "0";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiFrameSetCtrl : public GuiContainer {
  public:
   /*! Override the <i>borderEnable</i> setting for this frame.

@param index  Index of the frame to modify
@param state  New borderEnable state: "on", "off" or "dynamic"
 */
   virtual void frameBorder(( int index, string state="dynamic" )) {}
   /*! Override the <i>borderMovable</i> setting for this frame.

@param index  Index of the frame to modify
@param state  New borderEnable state: "on", "off" or "dynamic"
 */
   virtual void frameMovable(( int index, string state="dynamic" )) {}
   /*! Set the minimum width and height for the frame. It will not be possible for the user to resize the frame smaller than this.

@param index  Index of the frame to modify
@param width  Minimum width in pixels
@param height Minimum height in pixels
 */
   virtual void frameMinExtent(( int index, int width, int height )) {}
   /*! Set the padding for this frame. Padding introduces blank space on the inside edge of the frame.

@param index     Index of the frame to modify
@param padding   Frame top, bottom, left, and right padding
 */
   virtual void framePadding(( int index, RectSpacingI padding )) {}
   /*! Get the padding for this frame.

@param index     Index of the frame to query
 */
   virtual string getFramePadding(( int index )) {}
   /*! Add a new column.

 */
   virtual void addColumn(()) {}
   /*! Add a new row.

 */
   virtual void addRow(()) {}
   /*! Remove the last (rightmost) column.

 */
   virtual void removeColumn(()) {}
   /*! Remove the last (bottom) row.

 */
   virtual void removeRow(()) {}
   /*! Get the number of columns.

@return The number of columns
 */
   virtual int getColumnCount(()) {}
   /*! Get the number of rows.

@return The number of rows
 */
   virtual int getRowCount(()) {}
   /*! Get the horizontal offset of a column.

@param index Index of the column to query
@return Column offset in pixels
 */
   virtual int getColumnOffset(( int index )) {}
   /*! Get the vertical offset of a row.

@param index Index of the row to query
@return Row offset in pixels
 */
   virtual int getRowOffset(( int index )) {}
   /*! Set the horizontal offset of a column.

Note that column offsets must always be in increasing order, and therefore this offset must be between the offsets of the colunns either side.
@param index  Index of the column to modify
@param offset New column offset
 */
   virtual void setColumnOffset(( int index, int offset )) {}
   /*! Set the vertical offset of a row.

Note that row offsets must always be in increasing order, and therefore this offset must be between the offsets of the rows either side.
@param index  Index of the row to modify
@param offset New row offset
 */
   virtual void setRowOffset(( int index, int offset )) {}
   /*! Recalculates child control sizes. */
   virtual void updateSizes(()) {}
   /*!
   A vector of column offsets (determines the width of each column).
   
    */
   intList columns;
   /*!
   A vector of row offsets (determines the height of each row).
   
    */
   intList rows;
   /*!
   Width of interior borders between cells in pixels.
   
    */
   int borderWidth;
   /*!
   Color of interior borders between cells.
   
    */
   ColorI borderColor;
   /*!
   Controls whether frame borders are enabled.

Frames use this value unless overridden for that frame using <i>%ctrl.frameBorder(index)</i>
   
    */
   GuiFrameState borderEnable;
   /*!
   Controls whether borders can be dynamically repositioned with the mouse by the user.

Frames use this value unless overridden for that frame using <i>%ctrl.frameMovable(index)</i>
   
    */
   GuiFrameState borderMovable;
   /*!
   If true, row and column offsets are automatically scaled to match the new extents when the control is resized.
   
    */
   bool autoBalance;
   /*!
   Offset for row and column dividers in pixels
   
    */
   int fudgeFactor;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A collapsable pane control.

This class wraps a single child control and displays a header with caption above it. If you click the header it will collapse or expand (if <i>collapsable</i> is enabled). The control resizes itself based on its collapsed/expanded size.<br>In the GUI editor, if you just want the header you can make <i>collapsable</i> false. The caption field lets you set the caption; it expects a bitmap (from the GuiControlProfile) that contains two images - the first is displayed when the control is expanded and the second is displayed when it is collapsed. The header is sized based on the first image.

@tsexample
new GuiPaneControl()
{
   caption = "Example Pane";
   collapsable = "1";
   barBehindText = "1";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiPaneControl : public GuiControl {
  public:
   /*! Collapse or un-collapse the control.

@param collapse True to collapse the control, false to un-collapse it
 */
   virtual void setCollapsed(( bool collapse )) {}

   /*! @name Pane
   @{ */
   /*! */
   /*!
   Text label to display as the pane header.
   
    */
   string caption;
   /*!
   String table text ID to use as caption string (overrides 'caption').
   
    */
   string captionID;
   /*!
   Whether the pane can be collapsed by clicking its header.
   
    */
   bool collapsable;
   /*!
   Whether to draw the bitmapped pane bar behind the header text, too.
   
    */
   bool barBehindText;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that allows to view one or more possibly larger controls inside its area by providing horizontal and/or vertical scroll bars.

 */
class  GuiScrollCtrl : public GuiContainer {
  public:
      /*! Called each time the child controls are scrolled by some amount. */
      void onScroll();

   /*! Scroll all the way to the top of the vertical and left of the horizontal scrollbar. */
   virtual void scrollToTop(()) {}
   /*! Scroll all the way to the bottom of the vertical scrollbar and the left of the horizontal bar. */
   virtual void scrollToBottom(()) {}
   /*! Set the position of the scrolled content.

@param x Position on X axis.
@param y Position on y axis.
 */
   virtual void setScrollPosition(( int x, int y )) {}
   /*! Scroll the control so that the given child @a control is visible.

@param control A child control. */
   virtual void scrollToObject(( GuiControl control )) {}
   /*! Get the current coordinates of the scrolled content.

@return The current position of the scrolled content. */
   virtual string getScrollPosition(()) {}
   /*! Get the current X coordinate of the scrolled content.

@return The current X coordinate of the scrolled content. */
   virtual int getScrollPositionX(()) {}
   /*! Get the current Y coordinate of the scrolled content.@return The current Y coordinate of the scrolled content. */
   virtual int getScrollPositionY(()) {}
   /*! Refresh sizing and positioning of child controls. */
   virtual void computeSizes(()) {}

   /*! @name Scrolling
   @{ */
   /*! */
   /*!
    */
   bool willFirstRespond;
   /*!
   When to display the horizontal scrollbar.
   
    */
   GuiScrollBarBehavior hScrollBar;
   /*!
   When to display the vertical scrollbar.
   
    */
   GuiScrollBarBehavior vScrollBar;
   /*!
   Horizontal scrolling not allowed if set.
   
    */
   bool lockHorizScroll;
   /*!
   Vertical scrolling not allowed if set.
   
    */
   bool lockVertScroll;
   /*!
    */
   bool constantThumbHeight;
   /*!
   Padding region to put around child contents.
   
    */
   Point2I childMargin;
   /*!
   Pixels/Tick - if not positive then mousewheel scrolling occurs instantly (like other scrolling).
   
    */
   int mouseWheelScrollSpeed;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container that stacks its children horizontally or vertically.

This container maintains a horizontal or vertical stack of GUI controls. If one is added, deleted, or resized, then the stack is resized to fit. The order of the stack is determined by the internal order of the children (ie. the order of addition).<br>@tsexample
new GuiStackControl()
{
   stackingType = "Dynamic";
   horizStacking = "Left to Right";
   vertStacking = "Top to Bottom";
   padding = "4";
   dynamicSize = "1";
   dynamicNonStackExtent = "0";
   dynamicPos = "0";
   changeChildSizeToFit = "1";
   changeChildPosition = "1";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiStackControl : public GuiControl {
  public:
   /*! Return whether or not this control is frozen */
   virtual bool isFrozen(()) {}
   /*! Prevents control from restacking - useful when adding or removing child controls
@param freeze True to freeze the control, false to unfreeze it

@tsexample
%stackCtrl.freeze(true);
// add controls to stack
%stackCtrl.freeze(false);
@endtsexample
 */
   virtual void freeze(( bool freeze )) {}
   /*! Restack the child controls.
 */
   virtual void updateStack(()) {}

   /*! @name Stacking
   @{ */
   /*! */
   /*!
   Determines the method used to position the child controls.


   
    */
   GuiStackingType stackingType;
   /*!
   Controls the type of horizontal stacking to use (<i>Left to Right</i> or <i>Right to Left</i>)
   
    */
   GuiHorizontalStackingType horizStacking;
   /*!
   Controls the type of vertical stacking to use (<i>Top to Bottom</i> or <i>Bottom to Top</i>)
   
    */
   GuiVerticalStackingType vertStacking;
   /*!
   Distance (in pixels) between stacked child controls.
   
    */
   int padding;
   /*!
   Determines whether to resize the stack control along the stack axis (change width for horizontal stacking, change height for vertical stacking).

If true, the stack width/height will be resized to the sum of the child control widths/heights. If false, the stack will not be resized.
   
    */
   bool dynamicSize;
   /*!
   Determines whether to resize the stack control along the non-stack axis (change height for horizontal stacking, change width for vertical stacking). No effect if dynamicSize is false.

If true, the stack will be resized to the maximum of the child control widths/heights. If false, the stack will not be resized.
   
    */
   bool dynamicNonStackExtent;
   /*!
   Determines whether to reposition the stack along the stack axis when it is auto-resized. No effect if dynamicSize is false.

If true, the stack will grow left for horizontal stacking, and grow up for vertical stacking.
If false, the stack will grow right for horizontal stacking, and grow down for vertical stacking.

   
    */
   bool dynamicPos;
   /*!
   Determines whether to resize child controls.

If true, horizontally stacked children keep their width, but have their height set to the stack control height. Vertically stacked children keep their height, but have their width set to the stack control width. If false, child controls are not resized.
   
    */
   bool changeChildSizeToFit;
   /*!
   Determines whether to reposition child controls.

If true, horizontally stacked children are aligned along the top edge of the stack control. Vertically stacked children are aligned along the left edge of the stack control. If false, horizontally stacked children retain their Y position, and vertically stacked children retain their X position.
   
    */
   bool changeChildPosition;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A container 

@tsexample
// Create 
@endtsexample

@note Only GuiTabPageCtrls must be added to GuiTabBookCtrls.  If an object of a different class is added to the control, it will be reassigned to either the active page or the tab book's parent.

@see GuiTabPageCtrl
 */
class  GuiTabBookCtrl : public GuiContainer {
  public:
      /*! Called when a new tab page is selected.

@param text Text of the page header for the tab that is being selected.
@param index Index of the tab page being selected. */
      void onTabSelected( String text, int index );

      /*! Called when the user right-clicks on a tab page header.

@param text Text of the page header for the tab that is being selected.
@param index Index of the tab page being selected. */
      void onTabRightClick( String text, int index );

   /*! Add a new tab page to the control.

@param title Title text for the tab page header. */
   virtual void addPage(( string title="" )) {}
   /*! Set the selected tab page.

@param index Index of the tab page. */
   virtual void selectPage(( int index )) {}
   /*! Get the index of the currently selected tab page.

@return Index of the selected tab page or -1 if no tab page is selected. */
   virtual int getSelectedPage(()) {}

   /*! @name TabBook
   @{ */
   /*! */
   /*!
   Where to place the tab page headers.
   
    */
   GuiTabPosition tabPosition;
   /*!
   Spacing to put between individual tab page headers.
   
    */
   int tabMargin;
   /*!
   Minimum width allocated to a tab page header.
   
    */
   int minTabWidth;
   /*!
   Height of tab page headers.
   
    */
   int tabHeight;
   /*!
   Whether reordering tabs with the mouse is allowed.
   
    */
   bool allowReorder;
   /*!
   Index of page to select on first onWake() call (-1 to disable).
   
    */
   int defaultPage;
   /*!
   Index of currently selected page.
   
    */
   int selectedPage;
   /*!
   X offset of first tab page header.
   
    */
   int frontTabPadding;
   /*!
   Notification bitmaps will be rendered for pages that have them turned on.
   
    */
   bool useNotifyBmps;
   /*!
   Texture file to display for notifications.
   
    */
   filename notifyBitmap;
   /*!
    */
   Point2I notifyOffset;
   /*!
    */
   Point2I notifyExtent;
   /*!
   Notification bitmaps will be rendered of the right of the tab if this is true.
   
    */
   bool notifyRight;
   /*!
   Flash the notification bitmaps when turned on.
   
    */
   bool flashNotify;
   /*!
   Fade the notification bitmaps in and out when turned on.
   
    */
   bool fadeNotify;
   /*!
   Time in ms for a full cycle if the bitmap is flashing or fading.
   
    */
   int notifyCycleTime;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Editor GUI used for picking a ColorF from a palette.

@note Editor use only.

 */
class  GuiColorPickerCtrl : public GuiControl {
  public:
   /*! Gets the current position of the selector */
   virtual string getSelectorPos() {}
   /*! Sets the current position of the selector */
   virtual void setSelectorPos() {}
   /*! Forces update of pick color */
   virtual void updateColor() {}

   /*! @name ColorPicker
   @{ */
   /*! */
   /*!
    */
   ColorF baseColor;
   /*!
    */
   ColorF pickColor;
   /*!
    */
   int selectorGap;
   /*!
    */
   GuiColorPickMode displayMode;
   /*!
    */
   bool actionOnMove;
   /*!
    */
   bool showReticle;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The on-screen, in-game console. Calls getLog() to get the on-screen console entries, then renders them as needed.

@tsexample
^new GuiConsole()
^^{
^^^//Properties not specific to this control have been omitted from this example.
^^};
@endtsexample

@see GuiControl

 */
class  GuiConsole : public GuiArrayCtrl {
  public:
      /*! Called when a message in the log is clicked.

@param level Diagnostic level of the message.
@param message Message text.
 */
      void onMessageSelected( ConsoleLogEntry::Level level, string message );


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A list of text items.

A list of text items where each individual entry can have its own text value, text color and associated SimObject.

@tsexample
new GuiListBoxCtrl(GuiMusicPlayerMusicList)
{
   allowMultipleSelections = "true";
   fitParentWidth = "true";
   mirrorSet = "AnotherGuiListBoxCtrl";
   makeNameCallback = "";
   colorBullet = "1";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiControl

@ingroup GuiCore
 */
class  GuiListBoxCtrl : public GuiControl {
  public:
      /*! @brief Called whenever the mouse is dragged across the control.

@tsexample
// Mouse is dragged across the control, causing the callback to occur.
GuiListBoxCtrl::onMouseDragged(%this)
^{
^^// Code to run whenever the mouse is dragged across the control
^}
@endtsexample

@see GuiControl

 */
      void onMouseDragged();

      /*! @brief Called whenever a selected item in the list is cleared.

@tsexample
// A selected item is cleared, causing the callback to occur.
GuiListBoxCtrl::onClearSelection(%this)
^{
^^// Code to run whenever a selected item is cleared
^}
@endtsexample

@see GuiControl

 */
      void onClearSelection();

      /*! @brief Called whenever a selected item in the list has been unselected.

@param index Index id of the item that was unselected
@param itemText Text for the list entry at the index id that was unselected

@tsexample
// A selected item is unselected, causing the callback to occur
GuiListBoxCtrl::onUnSelect(%this, %indexId, %itemText)
^{
^^// Code to run whenever a selected list item is unselected
^}
@endtsexample

@see GuiControl

 */
      void onUnselect( string index, string itemText );

      /*! @brief Called whenever an item in the list is selected.

@param index Index id for the item in the list that was selected.
@param itemText Text for the list item at the index that was selected.

@tsexample
// An item in the list is selected, causing the callback to occur
GuiListBoxCtrl::onSelect(%this, %index, %itemText)
^{
^^// Code to run whenever an item in the list is selected
^}
@endtsexample

@see GuiControl

 */
      void onSelect( string index, string itemText );

      /*! @brief Called whenever an item in the list has been double clicked.

@tsexample
// An item in the list is double clicked, causing the callback to occur.
GuiListBoxCtrl::onDoubleClick(%this)
^{
^^// Code to run whenever an item in the control has been double clicked
^}
@endtsexample

@see GuiControl

 */
      void onDoubleClick();

      /*! @brief Called whenever the mouse has previously been clicked down (onMouseDown) and has now been raised on the control.
If an item in the list was hit during the click cycle, then the index id of the clicked object along with how many clicks occured are passed
into the callback.

Detailed description

@param itemHit Index id for the list item that was hit
@param mouseClickCount How many mouse clicks occured on this list item

@tsexample
// Mouse was previously clicked down, and now has been released, causing the callback to occur.
GuiListBoxCtrl::onMouseUp(%this, %itemHit, %mouseClickCount)
^{
^^// Code to call whenever the mouse has been clicked and released on the control
^}
@endtsexample

@see GuiControl

 */
      void onMouseUp( string itemHit, string mouseClickCount );

      /*! @brief Called whenever the Delete key on the keyboard has been pressed while in this control.

@tsexample
// The delete key on the keyboard has been pressed while this control is in focus, causing the callback to occur.
GuiListBoxCtrl::onDeleteKey(%this)
^{
^^// Code to call whenever the delete key is pressed
^}
@endtsexample

@see GuiControl

 */
      void onDeleteKey();

      /*! @brief Checks if a list item at a defined index id is mirrored, and returns the result.

@param indexIdString Index id of the list to check.
@tsexample
// Engine has requested of the script level to determine if a list entry is mirrored or not.
GuiListBoxCtrl::isObjectMirrored(%this, %indexIdString)
^{
^^// Perform code required to check and see if the list item at the index id is mirrored or not.
^^return %isMirrored;
^}
@endtsexample

@return A boolean value on if the list item is mirrored or not.

@see GuiControl

 */
      bool isObjectMirrored( string indexIdString );

   /*! @brief Enable or disable multiple selections for this GuiListBoxCtrl object.

@param allowMultSelections Boolean variable to set the use of multiple selections or not.
@tsexample
// Define the multiple selection use state.
%allowMultSelections = "true";

// Set the allow  multiple selection state on the GuiListBoxCtrl object.
%thisGuiListBoxCtrl.setMultipleSelection(%allowMultSelections);
@endtsexample

@see GuiControl
 */
   virtual void setMultipleSelection(( bool allowMultSelections )) {}
   /*! @brief Clears all the items in the listbox.

@tsexample
// Inform the GuiListBoxCtrl object to clear all items from its list.
%thisGuiListBoxCtrl.clearItems();
@endtsexample

@see GuiControl */
   virtual void clearItems(()) {}
   /*! @brief Sets all currently selected items to unselected.

Detailed description

@tsexample
// Inform the GuiListBoxCtrl object to set all of its items to unselected./n%thisGuiListBoxCtrl.clearSelection();
@endtsexample

@see GuiControl */
   virtual void clearSelection(()) {}
   /*! @brief Sets the item at the index specified to selected or not.

Detailed description

@param index Item index to set selected or unselected.
@param setSelected Boolean selection state to set the requested item index.
@tsexample
// Define the index
%index = "5";

// Define the selection state
%selected = "true"

// Inform the GuiListBoxCtrl object of the new selection state for the requested index entry.
%thisGuiListBoxCtrl.setSelected(%index,%selected);
@endtsexample

@see GuiControl */
   virtual void setSelected(( int index, bool setSelected=true )) {}
   /*! @brief Returns the number of items in the list.

@tsexample
// Request the number of items in the list of the GuiListBoxCtrl object.
%listItemCount = %thisGuiListBoxCtrl.getItemCount();
@endtsexample

@return The number of items in the list.

@see GuiControl */
   virtual int getItemCount(()) {}
   /*! @brief Returns the number of items currently selected.

@tsexample
// Request the number of currently selected items
%selectedItemCount = %thisGuiListBoxCtrl.getSelCount();
@endtsexample

@return Number of currently selected items.

@see GuiControl */
   virtual int getSelCount(()) {}
   /*! @brief Returns the selected items index or -1 if none selected. If multiple selections exist it returns the first selected item. 

@tsexample
// Request the index id of the currently selected item
%selectedItemId = %thisGuiListBoxCtrl.getSelectedItem();
@endtsexample

@return The selected items index or -1 if none selected.

@see GuiControl */
   virtual int getSelectedItem(()) {}
   /*! @brief Returns a space delimited list of the selected items indexes in the list.

@tsexample
// Request a space delimited list of the items in the GuiListBoxCtrl object.
%selectionList = %thisGuiListBoxCtrl.getSelectedItems();
@endtsexample

@return Space delimited list of the selected items indexes in the list

@see GuiControl */
   virtual string getSelectedItems(()) {}
   /*! @brief Returns index of item with matching text or -1 if none found.

@param findText Text in the list to find.
@param isCaseSensitive If true, the search will be case sensitive.
@tsexample
// Define the text we wish to find in the list.
%findText = "Hickory Smoked Gideon"/n/n// Define if this is a case sensitive search or not.
%isCaseSensitive = "false";

// Ask the GuiListBoxCtrl object what item id in the list matches the requested text.
%matchingId = %thisGuiListBoxCtrl.findItemText(%findText,%isCaseSensitive);
@endtsexample

@return Index id of item with matching text or -1 if none found.

@see GuiControl */
   virtual int findItemText(( string findText, bool bCaseSensitive=false )) {}
   /*! @brief Sets the currently selected item at the specified index.

@param indexId Index Id to set selected.
@tsexample
// Define the index id that we wish to select.
%selectId = "4";

// Inform the GuiListBoxCtrl object to set the requested index as selected.
%thisGuiListBoxCtrl.setCurSel(%selectId);
@endtsexample

@see GuiControl */
   virtual void setCurSel(( int indexId )) {}
   /*! @brief Sets the current selection range from index start to stop. If no stop is specified it sets from start index to the end of the list

@param indexStart Index Id to start selection.
@param indexStop Index Id to end selection.
@tsexample
// Set start id
%indexStart = "3";

// Set end id
%indexEnd = "6";

// Request the GuiListBoxCtrl object to select the defined range.
%thisGuiListBoxCtrl.setCurSelRange(%indexStart,%indexEnd);
@endtsexample

@see GuiControl */
   virtual void setCurSelRange(( int indexStart, int indexStop=999999 )) {}
   /*! @brief Adds an item to the end of the list with an optional color.

@param newItem New item to add to the list.
@param color Optional color parameter to add to the new item.
@tsexample
// Define the item to add to the list.
%newItem = "Gideon's Blue Coat";

// Define the optional color for the new list item.
%color = "0.0 0.0 1.0";

// Inform the GuiListBoxCtrl object to add the item to the end of the list with the defined color.
%thisGuiListBoxCtrl.addItem(%newItem,%color);
@endtsexample

@return If not void, return value and description

@see GuiControl
@hide */
   virtual int addItem(( string newItem, string color="" )) {}
   /*! @brief Sets the color of a single list entry at the specified index id.

@param index Index id to modify the color of in the list.
@param color Color value to set the list entry to.
@tsexample
// Define the index id value
%index = "5";

// Define the color value
%color = "1.0 0.0 0.0";

// Inform the GuiListBoxCtrl object to change the color of the requested index
%thisGuiListBoxCtrl.setItemColor(%index,%color);
@endtsexample

@see GuiControl */
   virtual void setItemColor(( int index, ColorF color )) {}
   /*! @brief Removes any custom coloring from an item at the defined index id in the list.

@param index Index id for the item to clear any custom color from.
@tsexample
// Define the index id
%index = "4";

// Request the GuiListBoxCtrl object to remove any custom coloring from the defined index entry
%thisGuiListBoxCtrl.clearItemColor(%index);
@endtsexample

@see GuiControl */
   virtual void clearItemColor(( int index )) {}
   /*! @brief Inserts an item into the list at the specified index and returns the index assigned or -1 on error.

@param text Text item to add.
@param index Index id to insert the list item text at.
@tsexample
// Define the text to insert
%text = "Secret Agent Gideon";

// Define the index entry to insert the text at
%index = "14";

// In form the GuiListBoxCtrl object to insert the text at the defined index.
%assignedId = %thisGuiListBoxCtrl.insertItem(%text,%index);
@endtsexample

@return If successful will return the index id assigned. If unsuccessful, will return -1.

@see GuiControl */
   virtual void insertItem(( string text, int index )) {}
   /*! @brief Removes the list entry at the requested index id from the control and clears the memory associated with it.

@param itemIndex Index id location to remove the item from.
@tsexample
// Define the index id we want to remove from the list
%itemIndex = "8";

// Inform the GuiListBoxCtrl object to remove the item at the defined index id.
%thisGuiListBoxCtrl.deleteItem(%itemIndex);
@endtsexample

@see References */
   virtual void deleteItem(( int itemIndex )) {}
   /*! @brief Returns the text of the item at the specified index.

@param index Index id to return the item text from.
@tsexample
// Define the index id entry to request the text from
%index = "12";

// Request the item id text from the GuiListBoxCtrl object.
%text = %thisGuiListBoxCtrl.getItemText(%index);
@endtsexample

@return The text of the requested index id.

@see GuiControl */
   virtual string getItemText(( int index )) {}
   /*! @brief Returns the object associated with an item. This only makes sense if you are mirroring a simset.

@param index Index id to request the associated item from.
@tsexample
// Define the index id
%index = "12";

// Request the item from the GuiListBoxCtrl object
%object = %thisGuiListBoxCtrl.getItemObject(%index);
@endtsexample

@return The object associated with the item in the list.

@see References */
   virtual string getItemObject(( int index )) {}
   /*! @brief Sets the items text at the specified index.

@param index Index id to set the item text at.
@param newtext Text to change the list item at index id to.
@tsexample
// Define the index id/n%index = "12";

// Define the text to set the list item to
%newtext = "Gideon's Fancy Goggles";

// Inform the GuiListBoxCtrl object to change the text at the requested index
%thisGuiListBoxCtrl.setItemText(%index,%newText);
@endtsexample

@see GuiControl */
   virtual void setItemText(( int index, string newtext )) {}
   /*! @brief Set the tooltip text to display for the given list item.

@param index Index id to change the tooltip text
@param text Text for the tooltip.
@tsexample
// Define the index id
%index = "12";

// Define the tooltip text
%tooltip = "Gideon's goggles can see through space and time."

// Inform the GuiListBoxCtrl object to set the tooltop for the item at the defined index id
%thisGuiListBoxCtrl.setItemToolTip(%index,%tooltip);
@endtsexample

@see GuiControl */
   virtual void setItemTooltip(( int index, string text )) {}
   /*! @brief Request the item index for the item that was last clicked.

@tsexample
// Request the item index for the last clicked item in the list
%lastClickedIndex = %thisGuiListBoxCtrl.getLastClickItem();
@endtsexample

@return Index id for the last clicked item in the list.

@see GuiControl */
   virtual int getLastClickItem(()) {}
   /*! @brief Informs the GuiListBoxCtrl object to mirror the contents of the GuiListBoxCtrl stored in the mirrorSet field.

@tsexample
\ Inform the object to mirror the object located at %thisGuiListBox.mirrorSet
%thisGuiListBox.doMirror();
@endtsexample

@see GuiCore */
   virtual void doMirror(()) {}
   /*! @brief Checks if there is an item with the exact text of what is passed in, and if so
the item is removed from the list and adds that item's data to the filtered list.

@param itemName Name of the item that we wish to add to the filtered item list of the GuiListBoxCtrl.
@tsexample
// Define the itemName that we wish to add to the filtered item list.
%itemName = "This Item Name";

// Add the item name to the filtered item list.
%thisGuiListBoxCtrl.addFilteredItem(%filteredItemName);
@endtsexample

@see GuiControl */
   virtual void addFilteredItem(( string newItem )) {}
   /*! @brief Removes an item of the entered name from the filtered items list.

@param itemName Name of the item to remove from the filtered list.
@tsexample
// Define the itemName that you wish to remove.
%itemName = "This Item Name";

// Remove the itemName from the GuiListBoxCtrl
%thisGuiListBoxCtrl.removeFilteredItem(%itemName);
@endtsexample

@see GuiControl */
   virtual void removeFilteredItem(( string itemName )) {}
   /*!
   If true, will allow the selection of multiple items in the listbox.

   
    */
   bool allowMultipleSelections;
   /*!
   If true, the width of the listbox will match the width of its parent control.

   
    */
   bool fitParentWidth;
   /*!
   If true, colored items will render a colored rectangular bullet next to the item text.

   
    */
   bool colorBullet;
   /*!
   If populated with the name of another GuiListBoxCtrl, then this list box will mirror the contents of the mirrorSet listbox.

   
    */
   string mirrorSet;
   /*!
   A script snippet to control what is displayed in the list for a SimObject. Within this snippet, $ThisControl is bound to the guiListBoxCtrl and $ThisObject to the contained object in question.

   
    */
   string makeNameCallback;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that displays a list of files from within a single directory in the game file system.

@tsexample

new GuiDirectoryFileListCtrl()
{
   filePath = "art/shapes";
   fileFilter = "*.dts" TAB "*.dae";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@ingroup GuiControls
 */
class  GuiDirectoryFileListCtrl : public GuiListBoxCtrl {
  public:
   /*! Set the file filter.

@param filter Tab-delimited list of file name patterns. Only matched files will be displayed.
 */
   virtual void setFilter(( string filter )) {}
   /*! Update the file list. */
   virtual void reload(()) {}
   /*! Set the search path and file filter.

@param path   Path in game directory from which to list files.
@param filter Tab-delimited list of file name patterns. Only matched files will be displayed.
 */
   virtual bool setPath(( string path, string filter )) {}
   /*! Get the list of selected files.

@return A space separated list of selected files */
   virtual string getSelectedFiles(()) {}
   /*! Get the currently selected filename.

@return The filename of the currently selected file
 */
   virtual string getSelectedFile(()) {}
   /*!
   Path in game directory from which to list files.
   
    */
   string filePath;
   /*!
   Tab-delimited list of file name patterns. Only matched files will be displayed.
   
    */
   string fileFilter;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Hierarchical list of text items with optional icons.

Can also be used to inspect SimObject hierarchies, primarily within editors.

GuiTreeViewCtrls can either display arbitrary user-defined trees or can be used to display SimObject hierarchies where each parent node in the tree is a SimSet or SimGroup and each leaf node is a SimObject.

Each item in the tree has a text and a value.  For trees that display SimObject hierarchies, the text for each item is automatically derived from objects while the value for each item is the ID of the respective SimObject.  For trees that are not tied to SimObjects, both text and value of each item are set by the user.

Additionally, items in the tree can have icons.

Each item in the tree has a distinct numeric ID that is unique within its tree.  The ID of the root item, which is always present on a tree, is 0.

@tsexample
new GuiTreeViewCtrl(DatablockEditorTree)
{
^tabSize = "16";
^textOffset = "2";
^fullRowSelect = "0";
^itemHeight = "21";
^destroyTreeOnSleep = "0";
^MouseDragging = "0";
^MultipleSelections = "1";
^DeleteObjectAllowed = "1";
^DragToItemAllowed = "0";
^ClearAllOnSingleSelection = "1";
^showRoot = "1";
^internalNamesOnly = "0";
^objectNamesOnly = "0";
^compareToObjectID = "0";
^Profile = "GuiTreeViewProfile";
^tooltipprofile = "GuiToolTipProfile";
^hovertime = "1000";
};
@endtsexample

@ingroup GuiContainers
 */
class  GuiTreeViewCtrl : public GuiArrayCtrl {
  public:
      /*!  */
      bool onDeleteObject( SimObject object );

      /*!  */
      bool isValidDragTarget( int id, string value );

      /*!  */
      void onDefineIcons();

      /*!  */
      void onAddGroupSelected( SimGroup group );

      /*!  */
      void onAddSelection( int itemOrObjectId, bool isLastSelection );

      /*!  */
      void onSelect( int itemOrObjectId );

      /*!  */
      void onInspect( int itemOrObjectId );

      /*!  */
      void onRemoveSelection( int itemOrObjectId );

      /*!  */
      void onUnselect( int itemOrObjectId );

      /*!  */
      void onDeleteSelection();

      /*!  */
      void onObjectDeleteCompleted();

      /*!  */
      void onKeyDown( int modifier, int keyCode );

      /*!  */
      void onMouseUp( int hitItemId, int mouseClickCount );

      /*!  */
      void onMouseDragged();

      /*!  */
      void onRightMouseDown( int itemId, Point2I mousePos, SimObject object );

      /*!  */
      void onRightMouseUp( int itemId, Point2I mousePos, SimObject object );

      /*!  */
      void onBeginReparenting();

      /*!  */
      void onEndReparenting();

      /*!  */
      void onReparent( int itemOrObjectId, int oldParentItemOrObjectId, int newParentItemOrObjectId );

      /*!  */
      void onDragDropped();

      /*!  */
      void onAddMultipleSelectionBegin();

      /*!  */
      void onAddMultipleSelectionEnd();

      /*!  */
      bool canRenameObject( SimObject object );

      /*!  */
      bool handleRenameObject( string newName, SimObject object );

      /*!  */
      void onClearSelection();

   /*! Get the ID of the item whose text matches the given @a text.

@param text Item text to match.
@return ID of the item or -1 if no item matches the given text. */
   virtual int findItemByName(( string text )) {}
   /*! Get the ID of the item whose value matches @a value.

@param value Value text to match.
@return ID of the item or -1 if no item has the given value. */
   virtual int findItemByValue(( string value )) {}
   /*! Get the child item of the given parent item whose text matches @a childName.

@param parentId Item ID of the parent in which to look for the child.
@param childName Text of the child item to find.
@return ID of the child item or -1 if no child in @a parentId has the given text @a childName.

@note This method does not recurse, i.e. it only looks for direct children. */
   virtual int findChildItemByName(( int parentId, string childName )) {}
   /*! Add a new item to the tree.

@param parentId Item ID of parent to which to add the item as a child.  0 is root item.
@param text Text to display on the item in the tree.
@param value Behind-the-scenes value of the item.
@param icon
@param normalImage
@param expandedImage
@return The ID of the newly added item. */
   virtual int insertItem(( int parentId, string text, string value="", string icon="", int normalImage=0, int expandedImage=0 )) {}
   /*! Set whether the current selection can be changed by the user or not.

@param lock If true, the current selection is frozen and cannot be changed.  If false, the selection may be modified. */
   virtual void lockSelection(( bool lock=true )) {}
   /*! Call SimObject::setHidden( @a state ) on all objects in the current selection.

@param state Visibility state to set objects in selection to. */
   virtual void hideSelection(( bool state=true )) {}
   /*! Toggle the locked state of all objects in the current selection. */
   virtual void toggleLockSelection(()) {}
   /*! Toggle the hidden state of all objects in the current selection. */
   virtual void toggleHideSelection(()) {}
   /*! Unselect all currently selected items. */
   virtual void clearSelection(()) {}
   /*! Delete all items/objects in the current selection. */
   virtual void deleteSelection(()) {}
   /*! Add an item/object to the current selection.

@param id ID of item/object to add to the selection.
@param isLastSelection Whether there are more pending items/objects to be added to the selection.  If false, the control will defer refreshing the tree and wait until addSelection() is called with this parameter set to true. */
   virtual void addSelection(( int id, bool isLastSelection=true )) {}
   /*! addChildSelectionByValue(TreeItemId parent, value) */
   virtual void addChildSelectionByValue() {}
   virtual void removeSelection((deselects an item)) {}
   /*! removeChildSelectionByValue(TreeItemId parent, value) */
   virtual void removeChildSelectionByValue() {}
   virtual bool selectItem((TreeItemId item, bool select=true)) {}
   virtual bool expandItem((TreeItemId item, bool expand=true)) {}
   virtual bool markItem((TreeItemId item, bool mark=true)) {}
   virtual void scrollVisible((TreeItemId item)) {}
   virtual bool buildIconTable((builds an icon table)) {}
   /*! Set the root of the tree view to the specified object, or to the root set. */
   virtual void open((SimSet obj, bool okToEdit=true)) {}
   /*! Set the tooltip to show for the given item. */
   virtual void setItemTooltip(( int id, string text )) {}
   /*! Sets the normal and expanded images to show for the given item. */
   virtual void setItemImages(( int id, int normalImage, int expandedImage )) {}
   /*! Returns true if the given item contains child items. */
   virtual bool isParentItem(( int id )) {}
   virtual string getItemText((TreeItemId item)) {}
   virtual string getItemValue((TreeItemId item)) {}
   virtual bool editItem((TreeItemId item, string newText, string newValue)) {}
   virtual bool removeItem((TreeItemId item)) {}
   /*! removeAllChildren(TreeItemId parent) */
   virtual void removeAllChildren() {}
   /*! empty tree */
   virtual void clear(()) {}
   /*! Get id for root item. */
   virtual int getFirstRootItem() {}
   virtual int getChild((TreeItemId item)) {}
   /*! Build the visible tree */
   virtual void buildVisibleTree() {}
   virtual int getParent((TreeItemId item)) {}
   virtual int getNextSibling((TreeItemId item)) {}
   virtual int getPrevSibling((TreeItemId item)) {}
   virtual int getItemCount() {}
   /*! Return the selected item at the given index. */
   virtual int getSelectedItem(( int index=0 )) {}
   /*! Return the currently selected SimObject at the given index in inspector mode or -1 */
   virtual int getSelectedObject(( int index=0 )) {}
   /*! Returns a space sperated list of all selected object ids. */
   virtual string getSelectedObjectList() {}
   virtual void moveItemUp((TreeItemId item)) {}
   virtual int getSelectedItemsCount() {}
   virtual void moveItemDown((TreeItemId item)) {}
   /*! gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally */
   virtual string getTextToRoot((TreeItemId item,Delimiter=none)) {}
   /*! returns a space seperated list of mulitple item ids */
   virtual string getSelectedItemList() {}
   virtual int findItemByObjectId((find item by object id and returns the mId)) {}
   virtual int scrollVisibleByObjectId((show item by object id. returns true if sucessful.)) {}
   /*! Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy. */
   virtual void sort(( int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true )) {}
   /*! For internal use. */
   virtual void cancelRename() {}
   /*! For internal use. */
   virtual void onRenameValidate() {}
   /*! Show the rename text field for the given item (only one at a time). */
   virtual void showItemRenameCtrl(( TreeItemId id )) {}
   /*! Enable/disable debug output. */
   virtual void setDebug(( bool value=true )) {}
   /*! Check whether the given item is currently selected in the tree.

@param id Item/object ID.
@return True if the given item/object is currently selected in the tree. */
   virtual bool isItemSelected(( int id )) {}
   /*! Get the current filter expression.  Only tree items whose text matches this expression are displayed.  By default, the expression is empty and all items are shown.

@return The current filter pattern or an empty string if no filter pattern is currently active.

@see setFilterText
@see clearFilterText */
   virtual string getFilterText(()) {}
   /*! Set the pattern by which to filter items in the tree.  Only items in the tree whose text matches this pattern are displayed.

@param pattern New pattern based on which visible items in the tree should be filtered.  If empty, all items become visible.

@see getFilterText
@see clearFilterText */
   virtual void setFilterText(( string pattern )) {}
   /*! Clear the current item filtering pattern.

@see setFilterText
@see getFilterText */
   virtual void clearFilterText(()) {}

   /*! @name TreeView
   @{ */
   /*! */
   /*!
    */
   int tabSize;
   /*!
    */
   int textOffset;
   /*!
    */
   bool fullRowSelect;
   /*!
    */
   int itemHeight;
   /*!
   If true, the entire tree item hierarchy is deleted when the control goes to sleep.
   
    */
   bool destroyTreeOnSleep;
   /*!
    */
   bool mouseDragging;
   /*!
   If true, multiple items can be selected concurrently.
   
    */
   bool multipleSelections;
   /*!
    */
   bool deleteObjectAllowed;
   /*!
    */
   bool dragToItemAllowed;
   /*!
    */
   bool clearAllOnSingleSelection;
   /*!
   If true, the root item is shown in the tree.
   
    */
   bool showRoot;
   /*!
    */
   bool useInspectorTooltips;
   /*!
    */
   bool tooltipOnWidthOnly;
   /// @}


   /*! @name Inspector Trees
   @{ */
   /*! */
   /*!
   If true, item text labels for objects will include object IDs.
   
    */
   bool showObjectIds;
   /*!
   If true, item text labels for objects will include class names.
   
    */
   bool showClassNames;
   /*!
   If true, item text labels for objects will include object names.
   
    */
   bool showObjectNames;
   /*!
   If true, item text labels for obje ts will include internal names.
   
    */
   bool showInternalNames;
   /*!
   If true, class names will be used as object names for unnamed objects.
   
    */
   bool showClassNameForUnnamedObjects;
   /*!
    */
   bool compareToObjectID;
   /*!
   If true clicking on a selected item ( that is an object and not the root ) will allow you to rename it.
   
    */
   bool canRenameObjects;
   /*!
   If true then object renaming operates on the internalName rather than the object name.
   
    */
   bool renameInternal;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that displays a hierarchical tree view of a path in the game file system.

@note Currently not used, most likely existed for editors. Possibly deprecated.

 */
class  GuiFileTreeCtrl : public GuiTreeViewCtrl {
  public:
   /*! getSelectedPath() - returns the currently selected path in the tree */
   virtual string getSelectedPath() {}
   /*! setSelectedPath(path) - expands the tree to the specified path */
   virtual bool setSelectedPath() {}
   /*! Reread the directory tree hierarchy. */
   virtual void reload(()) {}

   /*! @name File Tree
   @{ */
   /*! */
   /*!
   Path in game directory that should be displayed in the control.
   
    */
   string rootPath;
   /*!
   Vector of file patterns.  If not empty, only files matching the pattern will be shown in the control.
   
    */
   string fileFilter;
   /// @}


   /*! @name TreeView
   @{ */
   /*! */
   /// @}


   /*! @name Inspector Trees
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A base class for cross platform menu controls that are gamepad friendly.

This class is used to build row-based menu GUIs that can be easily navigated using the keyboard, mouse or gamepad. The desired row can be selected using the mouse, or by navigating using the Up and Down buttons.

@tsexample

new GuiGameListMenuCtrl()
{
   debugRender = "0";
   callbackOnA = "applyOptions();";
   callbackOnB = "Canvas.setContent(MainMenuGui);";
   callbackOnX = "";
   callbackOnY = "revertOptions();";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiGameListMenuProfile

 */
class  GuiGameListMenuCtrl : public GuiControl {
  public:
      /*! Called when the selected row changes. */
      void onChange();

   /*! Add a row to the list control.

@param label The text to display on the row as a label.
@param callback Name of a script function to use as a callback when this row is activated.
@param icon [optional] Index of the icon to use as a marker.
@param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
@param useHighlightIcon [optional] Does this row use the highlight icon?.
@param enabled [optional] If this row is initially enabled. */
   virtual void addRow(( string label, string callback, int icon=-1, int yPad=0, bool useHighlightIcon=true, bool enabled=true )) {}
   /*! Determines if the specified row is enabled or disabled.

@param row The row to set the enabled status of.
@return True if the specified row is enabled. False if the row is not enabled or the given index was not valid. */
   virtual bool isRowEnabled(( int row )) {}
   /*! Sets a row's enabled status according to the given parameters.

@param row The index to check for validity.
@param enabled Indicate true to enable the row or false to disable it. */
   virtual void setRowEnabled(( int row, bool enabled )) {}
   /*! Activates the current row. The script callback of  the current row will be called (if it has one). */
   virtual void activateRow(()) {}
   /*! Gets the number of rows on the control.

@return (int) The number of rows on the control. */
   virtual int getRowCount(()) {}
   /*! Gets the label displayed on the specified row.

@param row Index of the row to get the label of.
@return The label for the row. */
   virtual string getRowLabel(( int row )) {}
   /*! Sets the label on the given row.

@param row Index of the row to set the label on.
@param label Text to set as the label of the row.
 */
   virtual void setRowLabel(( int row, string label )) {}
   /*! Sets the selected row. Only rows that are enabled can be selected.

@param row Index of the row to set as selected. */
   virtual void setSelected(( int row )) {}
   /*! Gets the index of the currently selected row.

@return Index of the selected row. */
   virtual int getSelectedRow(()) {}
   /*!
   Enable debug rendering
   
    */
   bool debugRender;
   /*!
   Script callback when the 'A' button is pressed. 'A' inputs are Keyboard: A, Return, Space; Gamepad: A, Start
   
    */
   string callbackOnA;
   /*!
   Script callback when the 'B' button is pressed. 'B' inputs are Keyboard: B, Esc, Backspace, Delete; Gamepad: B, Back
   
    */
   string callbackOnB;
   /*!
   Script callback when the 'X' button is pressed. 'X' inputs are Keyboard: X; Gamepad: X
   
    */
   string callbackOnX;
   /*!
   Script callback when the 'Y' button is pressed. 'Y' inputs are Keyboard: Y; Gamepad: Y
   
    */
   string callbackOnY;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control for showing pages of options that are gamepad friendly.

Each row in this control allows the selection of one value from a set of options using the keyboard, gamepad or mouse. The row is rendered as 2 columns: the first column contains the row label, the second column contains left and right arrows (for mouse picking) and the currently selected value.

@see GuiGameListOptionsProfile

 */
class  GuiGameListOptionsCtrl : public GuiGameListMenuCtrl {
  public:
   /*! Add a row to the list control.

@param label The text to display on the row as a label.
@param options A tab separated list of options.
@param wrapOptions Specify true to allow options to wrap at each end or false to prevent wrapping.
@param callback Name of a script function to use as a callback when this row is activated.
@param icon [optional] Index of the icon to use as a marker.
@param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
@param enabled [optional] If this row is initially enabled. */
   virtual void addRow(( string label, string options, bool wrapOptions, string callback, int icon=-1, int yPad=0, bool enabled=true )) {}
   /*! Gets the text for the currently selected option of the given row.

@param row Index of the row to get the option from.
@return A string representing the text currently displayed as the selected option on the given row. If there is no such displayed text then the empty string is returned. */
   virtual string getCurrentOption(( int row )) {}
   /*! Set the row's current option to the one specified

@param row Index of the row to set an option on.
@param option The option to be made active.
@return True if the row contained the option and was set, false otherwise. */
   virtual bool selectOption(( int row, string option )) {}
   /*! Sets the list of options on the given row.

@param row Index of the row to set options on.@param optionsList A tab separated list of options for the control. */
   virtual void setOptions(( int row, string optionsList )) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Swatch selector that appears inside the GuiGradientCtrl object. These objects are automatically created by GuiGradientCtrl. 

Currently only appears to be editor specific

@see GuiSwatchButtonCtrl
@see GuiGradientCtrl

@ingroup GuiCore
 */
class  GuiGradientSwatchCtrl : public GuiSwatchButtonCtrl {
  public:
      /*! @brief Called whenever the left mouse button has entered the down state while in this control.

@tsexample
// The left mouse button is down on the control, causing the callback to occur.
GuiGradientSwatchCtrl::onMouseDown(%this)
^{
^^// Code to run when the callback occurs
^}
@endtsexample

@see GuiControl
@see GuiSwatchButtonCtrl

@internal */
      void onMouseDown();

      /*! @brief Called whenever the left mouse button performs a double click while in this control.

@tsexample
// The left mouse button has performed a double click on the control, causing the callback to occur.
GuiGradientSwatchCtrl::onDoubleClick(%this)
^{
^^// Code to run when the callback occurs
^}
@endtsexample

@see GuiControl
@see GuiSwatchButtonCtrl

@internal */
      void onDoubleClick();


   /*! @name Button
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Visual representation of color box used with the GuiColorPickerCtrl

Editor use only.

 */
class  GuiGradientCtrl : public GuiControl {
  public:
   /*! Get color count */
   virtual int getColorCount() {}
   /*! Get color value */
   virtual string getColor() {}

   /*! @name ColorPicker
   @{ */
   /*! */
   /*!
    */
   ColorF baseColor;
   /*!
    */
   ColorF pickColor;
   /*!
    */
   GuiGradientPickMode displayMode;
   /*!
    */
   bool actionOnMove;
   /*!
    */
   bool showReticle;
   /*!
    */
   int swatchFactor;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Container for GuiMaterialPreview

Editor use only.

 */
class  GuiMaterialCtrl : public GuiContainer {
  public:
   /*! Set the material to be displayed in the control. */
   virtual bool setMaterial(( string materialName )) {}

   /*! @name Material
   @{ */
   /*! */
   /*!
   
   
    */
   filename materialName;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that allows to select a value from a drop-down list.

For a nearly identical GUI with additional features, use GuiPopUpMenuCtrlEx.

@tsexample
new GuiPopUpMenuCtrl()
{
^maxPopupHeight = "200";
^sbUsesNAColor = "0";
^reverseTextList = "0";
^bitmapBounds = "16 16";
^maxLength = "1024";
^position = "56 31";
^extent = "64 64";
^minExtent = "8 2";
^profile = "GuiPopUpMenuProfile";
^tooltipProfile = "GuiToolTipProfile";
};
@endtsexample

@note This is definitely going to be deprecated soon.

@see GuiPopUpMenuCtrlEx for more features and better explanations.
@ingroup GuiControls
 */
class  GuiPopUpMenuCtrl : public GuiTextCtrl {
  public:
   virtual void add((string name, int idNum, int scheme=0)) {}
   virtual void addScheme((int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL)) {}
   virtual string getText() {}
   /*! Clear the popup list. */
   virtual void clear() {}
   /*! Sort the list alphabetically. */
   virtual void sort() {}
   /*! Sort the list by ID. */
   virtual void sortID() {}
   virtual void forceOnAction() {}
   virtual void forceClose() {}
   virtual int getSelected() {}
   virtual void setSelected((int id, [scriptCallback=true])) {}
   virtual void setFirstSelected(([scriptCallback=true])) {}
   virtual void setNoneSelected() {}
   virtual string getTextById((int id)) {}
   virtual void changeTextById(( int id, string text )) {}
   /*! This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away.. */
   virtual void setEnumContent((string class, string enum)) {}
   /*! Returns the position of the first entry containing the specified text. */
   virtual int findText((string text)) {}
   /*! Get the size of the menu - the number of entries in it. */
   virtual int size() {}
   virtual void replaceText((bool doReplaceText)) {}
   virtual void clearEntry((S32 entry)) {}
   /*!
    */
   int maxPopupHeight;
   /*!
    */
   bool sbUsesNAColor;
   /*!
    */
   bool reverseTextList;
   /*!
    */
   filename bitmap;
   /*!
    */
   Point2I bitmapBounds;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that allows to select a value from a drop-down list.

This is essentially a GuiPopUpMenuCtrl, but with quite a few more features.

@tsexample
new GuiPopUpMenuCtrlEx()
{
^maxPopupHeight = "200";
^sbUsesNAColor = "0";
^reverseTextList = "0";
^bitmapBounds = "16 16";
^hotTrackCallback = "0";
^extent = "64 64";
^profile = "GuiDefaultProfile";
^tooltipProfile = "GuiToolTipProfile";
};
@endtsexample

@see GuiPopUpMenuCtrl
@ingroup GuiControls
 */
class  GuiPopUpMenuCtrlEx : public GuiTextCtrl {
  public:
   virtual void add((string name, int idNum, int scheme=0)) {}
   /*! @brief Add a category to the list.

Acts as a separator between entries, allowing for sub-lists

@param text Name of the new category

 */
   virtual void addCategory(( string text )) {}
   /*! @brief Create a new scheme and add it to the list of choices for when a new text entry is added.

@param id Numerical id associated with this scheme
@param fontColor The base text font color. Formatted as "Red Green Blue", each a numerical between 0 and 255.
@param fontColorHL Color of text when being highlighted. Formatted as "Red Green Blue", each a numerical between 0 and 255.
@param fontColorSel Color of text when being selected. Formatted as "Red Green Blue", each a numerical between 0 and 255.
 */
   virtual void addScheme(( int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL )) {}
   /*! @brief Set the current text to a specified value.

@param text String containing new text to set

 */
   virtual void setText(( string text )) {}
   /*! @brief Get the.

Detailed description

@param param Description

@tsexample
// Comment
code();
@endtsexample

@return Returns current text in string format */
   virtual string getText(()) {}
   /*! @brief Clear the popup list.

 */
   virtual void clear(()) {}
   /*! @brief Sort the list alphabetically.

 */
   virtual void sort(()) {}
   /*! @brief Sort the list by ID.

 */
   virtual void sortID(()) {}
   /*! @brief Manually for the onAction function, which updates everything in this control.

 */
   virtual void forceOnAction(()) {}
   /*! @brief Manually force this control to collapse and close.

 */
   virtual void forceClose(()) {}
   /*! @brief Get the current selection of the menu.

@return Returns the ID of the currently selected entry */
   virtual int getSelected(()) {}
   /*! @hide */
   virtual void setSelected((int id, [scriptCallback=true])) {}
   /*! @hide */
   virtual void setFirstSelected(([scriptCallback=true])) {}
   /*! @brief Clears selection in the menu.

 */
   virtual void setNoneSelected(( int param )) {}
   /*! @brief Get the text of an entry based on an ID.

@param id The ID assigned to the entry being queried

@return String contained by the specified entry, NULL if empty or bad ID */
   virtual string getTextById(( int id )) {}
   /*! @brief Get color of an entry's box

@param id ID number of entry to query

@return ColorI in the format of "Red Green Blue Alpha", each of with is a value between 0 - 255 */
   virtual string getColorById() {}
   /*! @brief This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away.

@param class Name of the class containing the enum
@param enum Name of the enum value to acces
 */
   virtual void setEnumContent() {}
   /*! Returns the id of the first entry containing the specified text or -1 if not found.@param text String value used for the query

@return Numerical ID of entry containing the text. */
   virtual int findText((string text)) {}
   /*! @brief Get the size of the menu

@return Number of entries in the menu
 */
   virtual int size() {}
   /*! @brief Flag that causes each new text addition to replace the current entry

@param True to turn on replacing, false to disable it */
   virtual void replaceText() {}
   virtual void clearEntry((S32 entry)) {}
   /*!
   Length of menu when it extends
   
    */
   int maxPopupHeight;
   /*!
   Deprecated@internal
   
    */
   bool sbUsesNAColor;
   /*!
   Reverses text list if popup extends up, instead of down
   
    */
   bool reverseTextList;
   /*!
   File name of bitmap to use
   
    */
   filename bitmap;
   /*!
   Boundaries of bitmap displayed
   
    */
   Point2I bitmapBounds;
   /*!
   Whether to provide a 'onHotTrackItem' callback when a list item is hovered over
   
    */
   bool hotTrackCallback;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that displays a value between its minimal and maximal bounds using a slider placed on a vertical or horizontal axis.

A slider displays a value and allows that value to be changed by dragging a thumb control along the axis of the slider.  In this way, the value is changed between its allowed minimum and maximum.

To hook up script code to the value changes of a slider, use the #command and #altCommand properties.  #command is executed once the thumb is released by the user whereas #altCommand is called any time the slider value changes. When changing the slider value from script, however, trigger of #altCommand is suppressed by default.

The orientation of a slider is automatically determined from the ratio of its width to its height.  If a slider is taller than it is wide, it will be rendered with a vertical orientation.  If it is wider than it is tall, it will be rendered with a horizontal orientation.

The rendering of a slider depends on the bitmap in the slider's profile.  This bitmap must be a bitmap array comprised of at least five bitmap rectangles.  The rectangles are used such that:

- Rectangle #1: Left edge of slider
- Rectangle #2: Center piece of slider; this is stretched between the left and right edge
- Rectangle #3: Right edge of slider
- Rectangle #4: Thumb button in normal state
- Rectangle #5: Thumb button in highlighted (mouse-over) state

@tsexample
// Create a sound source and a slider that changes the volume of the source.

%source = sfxPlayOnce( "art/sound/testing", AudioLoop2D );

new GuiSlider()
{
   // Update the sound source volume when the slider is being dragged and released.
   command = %source @ ".setVolume( $ThisControl.value );";

   // Limit the range to 0..1 since that is the allowable range for sound volumes.
   range = "0 1";
};
@endtsexample

@see GuiTextEditSliderCtrl
@see GuiTextEditSliderBitmapCtrl

 */
class  GuiSliderCtrl : public GuiControl {
  public:
      /*! Called when the left mouse button is dragged across the slider. */
      void onMouseDragged();

   /*! Get the current value of the slider based on the position of the thumb.
@return Slider position (from range.x to range.y). */
   virtual float getValue(()) {}
   /*! Set position of the thumb on the slider.
@param pos New slider position (from range.x to range.y)
@param doCallback If true, the altCommand callback will be invoked
 */
   virtual void setValue(( float pos, bool doCallback=false )) {}
   /*! Returns true if the thumb is currently being dragged by the user.  This method is mainly useful for scrubbing type sliders where the slider position is sync'd to a changing value.  When the user is dragging the thumb, however, the sync'ing should pause and not get in the way of the user. */
   virtual bool isThumbBeingDragged(()) {}

   /*! @name Slider
   @{ */
   /*! */
   /*!
   Min and max values corresponding to left and right slider position.
   
    */
   Point2F range;
   /*!
   Spacing between tick marks in pixels. 0=off.
   
    */
   int ticks;
   /*!
   Whether to snap the slider to tick marks.
   
    */
   bool snap;
   /*!
   The value corresponding to the current slider position.
   
    */
   float value;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A single page in a GuiTabBookCtrl.

@tsexample

new GuiTabPageCtrl()
{
   fitBook = "1";
   //Properties not specific to this control have been omitted from this example.
};
@endtsexample

 */
class  GuiTabPageCtrl : public GuiTextCtrl {
  public:
   /*! Select this page in its tab book. */
   virtual void select(()) {}
   /*! Turns on and off notify bitmap display. */
   virtual void setNotify(( bool notifyVal )) {}
   /*!
   Determines whether to resize this page when it is added to the tab book. If true, the page will be resized according to the tab book extents and <i>tabPosition</i> property.
   
    */
   bool fitBook;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI control that displays a list of text. Text items in the list can be individually selected.

@tsexample
      new GuiTextListCtrl(EndGameGuiList)
^^{
^^^columns = "0 256";
^        fitParentWidth = "1";
^^^clipColumnText = "0";
^^    //Properties not specific to this control have been omitted from this example.
^^};
@endtsexample

@see Reference

@ingroup GuiControls
 */
class  GuiTextListCtrl : public GuiArrayCtrl {
  public:
      /*! @brief Called whenever an item in the list is selected.

@param cellid The ID of the cell that was selected
@param text The text in the selected cel

@tsexample
// A cel in the control was selected, causing the callback to occur
GuiTextListCtrl::onSelect(%this,%callid,%text)
^{
^^// Code to run when a cel item is selected
^}
@endtsexample

@see GuiControl

 */
      void onSelect( string cellid, string text );

      /*! @brief Called when the delete key has been pressed.

@param id Id of the selected item in the list
@tsexample
// The delete key was pressed while the GuiTextListCtrl was in focus, causing the callback to occur.
GuiTextListCtrl::onDeleteKey(%this,%id)
^{
^^// Code to run when the delete key is pressed
^}
@endtsexample

@see GuiControl

 */
      void onDeleteKey( string id );

   /*! @brief Get the ID of the currently selected item.

@tsexample
// Acquire the ID of the selected item in the list.
%id = %thisGuiTextListCtrl.getSelectedId();
@endtsexample

@return The id of the selected item in the list.

@see GuiControl */
   virtual int getSelectedId(()) {}
   /*! @brief Finds the specified entry by id, then marks its row as selected.

@param id Entry within the text list to make selected.
@tsexample
// Define the id
%id = "5";

// Inform the GuiTextListCtrl control to set the defined id entry as selected
%thisGuiTextListCtrl.setSelectedById(%id);
@endtsexample

@see GuiControl */
   virtual void setSelectedById(( int id )) {}
   /*! @briefSelects the specified row.

@param rowNum Row number to set selected.
@tsexample
// Define the row number to set selected
%rowNum = "4";

%guiTextListCtrl.setSelectedRow(%rowNum);
@endtsexample

@see GuiControl */
   virtual void setSelectedRow(( int rowNum )) {}
   /*! @brief Returns the selected row index (not the row ID).

@tsexample
// Acquire the selected row index
%rowIndex = %thisGuiTextListCtrl.getSelectedRow();
@endtsexample

@return Index of the selected row

@see GuiControl */
   virtual int getSelectedRow(()) {}
   /*! @brief Set the selection to nothing.

@tsexample
// Deselect anything that is currently selected
%thisGuiTextListCtrl.clearSelection();
@endtsexample

@see GuiControl */
   virtual void clearSelection(()) {}
   /*! @brief Adds a new row at end of the list with the defined id and text.
If index is used, then the new row is inserted at the row location of 'index'.

@param id Id of the new row.
@param text Text to display at the new row.
@param index Index to insert the new row at. If not used, new row will be placed at the end of the list.
@tsexample
// Define the id
%id = "4";

// Define the text to display
%text = "Display Text"

// Define the index (optional)
%index = "2"

// Inform the GuiTextListCtrl control to add the new row with the defined information.
%rowIndex = %thisGuiTextListCtrl.addRow(%id,%text,%index);
@endtsexample

@return Returns the row index of the new row. If 'index' was defined, then this just returns the number of rows in the list.

@see References */
   virtual int addRow(( int id=0, string text="", int index=-1 )) {}
   /*! @brief Sets the text at the defined id.

@param id Id to change.
@param text Text to use at the Id.
@tsexample
// Define the id
%id = "4";

// Define the text
%text = "Text To Display";

// Inform the GuiTextListCtrl control to display the defined text at the defined id
%thisGuiTextListCtrl.setRowById(%id,%text);
@endtsexample

@see GuiControl */
   virtual void setRowById(( int id, string text )) {}
   /*! @brief Performs a standard (alphabetical) sort on the values in the specified column.

@param columnId Column ID to perform the sort on.
@param increasing If false, sort will be performed in reverse.
@tsexample
// Define the columnId
%id = "1";

// Define if we are increasing or not
%increasing = "false";

// Inform the GuiTextListCtrl to perform the sort operation
%thisGuiTextListCtrl.sort(%id,%increasing);
@endtsexample

@see GuiControl */
   virtual void sort(( int columnId, bool increasing=true )) {}
   /*! @brief Perform a numerical sort on the values in the specified column.

Detailed description

@param columnId Column ID to perform the sort on.
@param increasing If false, sort will be performed in reverse.
@tsexample
// Define the columnId
%id = "1";

// Define if we are increasing or not
%increasing = "false";

// Inform the GuiTextListCtrl to perform the sort operation
%thisGuiTextListCtrl.sortNumerical(%id,%increasing);
@endtsexample

@see GuiControl */
   virtual void sortNumerical(( int columnID, bool increasing=true )) {}
   /*! @brief Clear the list.

@tsexample
// Inform the GuiTextListCtrl control to clear its contents
%thisGuiTextListCtrl.clear();
@endtsexample

@see GuiControl */
   virtual void clear(()) {}
   /*! @brief Get the number of rows.

@tsexample
// Get the number of rows in the list
%rowCount = %thisGuiTextListCtrl.rowCount();
@endtsexample

@return Number of rows in the list.

@see GuiControl */
   virtual int rowCount(()) {}
   /*! @brief Get the row ID for an index.

@param index Index to get the RowID at
@tsexample
// Define the index
%index = "3";

// Request the row ID at the defined index
%rowId = %thisGuiTextListCtrl.getRowId(%index);
@endtsexample

@return RowId at the defined index.

@see GuiControl */
   virtual int getRowId(( int index )) {}
   /*! @brief Get the text of a row with the specified id.

@tsexample
// Define the id
%id = "4";

// Inform the GuiTextListCtrl control to return the text at the defined row id
%rowText = %thisGuiTextListCtrl.getRowTextById(%id);
@endtsexample

@return Row text at the requested row id.

@see GuiControl */
   virtual string getRowTextById(( int id )) {}
   /*! @brief Get the row number for a specified id.

@param id Id to get the row number at
@tsexample
// Define the id
%id = "4";

// Request the row number from the GuiTextListCtrl control at the defined id.
%rowNumber = %thisGuiTextListCtrl.getRowNumById(%id);
@endtsexample

@see GuiControl */
   virtual int getRowNumById(( int id )) {}
   /*! @brief Get the text of the row with the specified index.

@param index Row index to acquire the text at.
@tsexample
// Define the row index
%index = "5";

// Request the text from the row at the defined index
%rowText = %thisGuiTextListCtrl.getRowText(%index);
@endtsexample

@return Text at the defined row index.

@see GuiControl */
   virtual string getRowText(( int index )) {}
   /*! @brief Remove row with the specified id.

@param id Id to remove the row entry at
@tsexample
// Define the id
%id = "4";

// Inform the GuiTextListCtrl control to remove the row at the defined id
%thisGuiTextListCtrl.removeRowById(%id);
@endtsexample

@see GuiControl */
   virtual void removeRowById(( int id )) {}
   /*! @brief Remove a row from the table, based on its index.

@param index Row index to remove from the list.
@tsexample
// Define the row index
%index = "4";

// Inform the GuiTextListCtrl control to remove the row at the defined row index
%thisGuiTextListCtrl.removeRow(%index);
@endtsexample

@see GuiControl */
   virtual void removeRow(( int index )) {}
   /*! @brief Scroll so the specified row is visible

@param rowNum Row number to make visible
@tsexample
// Define the row number to make visible
%rowNum = "4";

// Inform the GuiTextListCtrl control to scroll the list so the defined rowNum is visible.
%thisGuiTextListCtrl.scrollVisible(%rowNum);
@endtsexample

@see GuiControl */
   virtual void scrollVisible(( int rowNum )) {}
   /*! @brief Find needle in the list, and return the row number it was found in.

@param needle Text to find in the list.
@tsexample
// Define the text to find in the list
%needle = "Text To Find";

// Request the row number that contains the defined text to find

%rowNumber = %thisGuiTextListCtrl.findTextIndex(%needle);

@endtsexample

@return Row number that the defined text was found in,

@see GuiControl */
   virtual int findTextIndex(( string needle )) {}
   /*! @brief Mark a specified row as active/not.

@param rowNum Row number to change the active state.
@param active Boolean active state to set the row number.
@tsexample
// Define the row number
%rowNum = "4";

// Define the boolean active state
%active = "true";

// Informthe GuiTextListCtrl control to set the defined active state at the defined row number.
%thisGuiTextListCtrl.setRowActive(%rowNum,%active);
@endtsexample

@see GuiControl */
   virtual void setRowActive(( int rowNum, bool active )) {}
   /*! @brief Check if the specified row is currently active or not.

@param rowNum Row number to check the active state.
@tsexample
// Define the row number
%rowNum = "5";

// Request the active state of the defined row number from the GuiTextListCtrl control.
%rowActiveState = %thisGuiTextListCtrl.isRowActive(%rowNum);
@endtsexample

@return Active state of the defined row number.

@see GuiControl */
   virtual bool isRowActive(( int rowNum )) {}
   /*!
   A vector of column offsets.  The number of values determines the number of columns in the table.

   
    */
   intList columns;
   /*!
   If true, the width of this control will match the width of its parent.

   
    */
   bool fitParentWidth;
   /*!
   If true, text exceeding a column's given width will get clipped.

   
    */
   bool clipColumnText;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A canvas on which rendering occurs.

@section GuiCanvas_contents What a GUICanvas Can Contain...

@subsection GuiCanvas_content_contentcontrol Content Control
A content control is the top level GuiControl for a screen. This GuiControl will be the parent control for all other GuiControls on that particular screen.

@subsection GuiCanvas_content_dialogs Dialogs

A dialog is essentially another screen, only it gets overlaid on top of the current content control, and all input goes to the dialog. This is most akin to the "Open File" dialog box found in most operating systems. When you choose to open a file, and the "Open File" dialog pops up, you can no longer send input to the application, and must complete or cancel the open file request. Torque keeps track of layers of dialogs. The dialog with the highest layer is on top and will get all the input, unless the dialog is modeless, which is a profile option.

@see GuiControlProfile

@section GuiCanvas_dirty Dirty Rectangles

The GuiCanvas is based on dirty regions. Every frame the canvas paints only the areas of the canvas that are 'dirty' or need updating. In most cases, this only is the area under the mouse cursor. This is why if you look in guiCanvas.cc the call to glClear is commented out. What you will see is a black screen, except in the dirty regions, where the screen will be painted normally. If you are making an animated GuiControl you need to add your control to the dirty areas of the canvas.

@see GuiControl

@ingroup GuiCore
 */
class  GuiCanvas : public GuiControl {
  public:
   /*! @brief Get the GuiControl which is being used as the content.

@tsexample
Canvas.getContent();
@endtsexample

@return ID of current content control */
   virtual int getContent(()) {}
   /*! @brief Set the content of the canvas to a specified control.

@param ctrl ID or name of GuiControl to set content to

@tsexample
Canvas.setContent(PlayGui);
@endtsexample

 */
   virtual void setContent(( GuiControl ctrl )) {}
   /*! @hide */
   virtual void pushDialog((GuiControl ctrl, int layer=0, bool center=false)) {}
   /*! @hide */
   virtual void popDialog((GuiControl ctrl=NULL)) {}
   /*! @hide */
   virtual void popLayer((int layer)) {}
   /*! @brief Turns on the mouse cursor.

@tsexample
Canvas.cursorOn();
@endtsexample

 */
   virtual void cursorOn(()) {}
   /*! @brief Turns on the mouse off.

@tsexample
Canvas.cursorOff();
@endtsexample

 */
   virtual void cursorOff(()) {}
   /*! @brief Sets the cursor for the canvas.

@param cursor Name of the GuiCursor to use

@tsexample
Canvas.setCursor("DefaultCursor");
@endtsexample

 */
   virtual void setCursor(( GuiCursor cursor )) {}
   /*! @brief This turns on/off front-buffer rendering.

@param enable True if all rendering should be done to the front buffer

@tsexample
Canvas.renderFront(false);
@endtsexample

 */
   virtual void renderFront(( bool enable )) {}
   /*! @brief Enable rendering of the cursor.

@tsexample
Canvas.showCursor();
@endtsexample

 */
   virtual void showCursor(()) {}
   /*! @brief Disable rendering of the cursor.

@tsexample
Canvas.hideCursor();
@endtsexample

 */
   virtual void hideCursor(()) {}
   /*! @brief Determines if mouse cursor is enabled.

@tsexample
// Is cursor on?
if(Canvas.isCursorOn())
^echo("Canvas cursor is on");
@endtsexample

@return Returns true if the cursor is on.

 */
   virtual bool isCursorOn(()) {}
   /*! @brief Determines if mouse cursor is rendering.

@tsexample
// Is cursor rendering?
if(Canvas.isCursorShown())
^echo("Canvas cursor is rendering");
@endtsexample

@return Returns true if the cursor is rendering.

 */
   virtual bool isCursorShown(()) {}
   /*! @brief Force canvas to redraw.
If the elapsed time is greater than the time since the last paint then the repaint will be skipped.
@param elapsedMS The optional elapsed time in milliseconds.

@tsexample
Canvas.repaint();
@endtsexample

 */
   virtual void repaint(( int elapsedMS=0 )) {}
   /*! @brief Reset the update regions for the canvas.

@tsexample
Canvas.reset();
@endtsexample

 */
   virtual void reset(()) {}
   /*! @brief Get the current position of the cursor.

@param param Description

@tsexample
%cursorPos = Canvas.getCursorPos();
@endtsexample

@return Screen coordinates of mouse cursor, in format "X Y" */
   virtual string getCursorPos(()) {}
   /*! @hide */
   virtual void setCursorPos((Point2I pos)) {}
   /*! @brief Gets the gui control under the mouse.

@tsexample
%underMouse = Canvas.getMouseControl();
@endtsexample

@return ID of the gui control, if one was found. NULL otherwise */
   virtual int getMouseControl(()) {}
   /*! @brief Returns the dimensions of the canvas

@tsexample
%extent = Canvas.getExtent();
@endtsexample

@return Width and height of canvas. Formatted as numerical values in a single string "# #" */
   virtual string getExtent(()) {}
   /*! @brief Change the title of the OS window.

@param newTitle String containing the new name

@tsexample
Canvas.setWindowTitle("Documentation Rocks!");
@endtsexample

 */
   virtual void setWindowTitle(( string newTitle )) {}
   /*! @brief Find the first monitor index that matches the given name.

The actual match algorithm depends on the implementation.
@param name The name to search for.

@return The number of monitors attached to the system, including the default monoitor. */
   virtual int findFirstMatchingMonitor(( string name )) {}
   /*! @brief Gets the number of monitors attached to the system.

@return The number of monitors attached to the system, including the default monoitor. */
   virtual int getMonitorCount(()) {}
   /*! @brief Gets the name of the requested monitor.

@param index The monitor index.

@return The name of the requested monitor. */
   virtual string getMonitorName(( int index )) {}
   /*! @brief Gets the region of the requested monitor.

@param index The monitor index.

@return The rectangular region of the requested monitor. */
   virtual string getMonitorRect(( int index )) {}
   /*! @brief Gets the current screen mode as a string.

The return string will contain 5 values (width, height, fullscreen, bitdepth, refreshRate). You will need to parse out each one for individual use.

@tsexample
%screenWidth = getWord(Canvas.getVideoMode(), 0);
%screenHeight = getWord(Canvas.getVideoMode(), 1);
%isFullscreen = getWord(Canvas.getVideoMode(), 2);
%bitdepth = getWord(Canvas.getVideoMode(), 3);
%refreshRate = getWord(Canvas.getVideoMode(), 4);
@endtsexample

@return String formatted with screen width, screen height, screen mode, bit depth, and refresh rate. */
   virtual string getVideoMode(()) {}
   /*! @brief Gets the number of modes available on this device.

@param param Description

@tsexample
%modeCount = Canvas.getModeCount()
@endtsexample

@return The number of video modes supported by the device */
   virtual int getModeCount(()) {}
   /*! @brief Gets information on the specified mode of this device.

@param modeId Index of the mode to get data from.
@return A video mode string given an adapter and mode index.

@see GuiCanvas::getVideoMode() */
   virtual string getMode(( int modeId )) {}
   /*! @brief toggle canvas from fullscreen to windowed mode or back.

@tsexample
// If we are in windowed mode, the following will put is in fullscreen
Canvas.toggleFullscreen();@endtsexample

 */
   virtual void toggleFullscreen(()) {}
   /*! Translate a coordinate from canvas window-space to screen-space.
@param coordinate The coordinate in window-space.
@return The given coordinate translated to screen-space. */
   virtual string clientToScreen(( Point2I coordinate )) {}
   /*! Translate a coordinate from screen-space to canvas window-space.
@param coordinate The coordinate in screen-space.
@return The given coordinate translated to window-space. */
   virtual string screenToClient(( Point2I coordinate )) {}
   /*! Get the current position of the platform window associated with the canvas.
@return The window position of the canvas in screen-space. */
   virtual string getWindowPosition(()) {}
   /*! Set the position of the platform window associated with the canvas.
@param position The new position of the window in screen-space. */
   virtual void setWindowPosition(( Point2I position )) {}
   /*! Is this canvas currently fullscreen? */
   virtual bool isFullscreen(()) {}
   /*! minimize this canvas' window. */
   virtual void minimizeWindow(()) {}
   virtual bool isMinimized(()) {}
   virtual bool isMaximized(()) {}
   /*! maximize this canvas' window. */
   virtual void maximizeWindow(()) {}
   /*! restore this canvas' window. */
   virtual void restoreWindow(()) {}
   /*! Claim OS input focus for this canvas' window. */
   virtual void setFocus(()) {}
   /*! Change the video mode of this canvas. This method has the side effect of setting the $pref::Video::mode to the new values.

\param width The screen width to set.
\param height The screen height to set.
\param fullscreen Specify true to run fullscreen or false to run in a window
\param bitDepth [optional] The desired bit-depth. Defaults to the current setting. This parameter is ignored if you are running in a window.
\param refreshRate [optional] The desired refresh rate. Defaults to the current setting. This parameter is ignored if you are running in a window\param antialiasLevel [optional] The level of anti-aliasing to apply 0 = none */
   virtual void setVideoMode((int width, int height, bool fullscreen, [int bitDepth], [int refreshRate], [int antialiasLevel] )) {}

   /*! @name Mouse Handling
   @{ */
   /*! */
   /*!
   Deal with mouse buttons, even if the cursor is hidden.
   
    */
   bool alwaysHandleMouseButtons;
   /// @}


   /*! @name Canvas Rendering
   @{ */
   /*! */
   /*!
   The number of GFX fences to use.
   
    */
   int numFences;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control which adds several reactions to other GUIs via callbacks.

GuiScriptNotifyCtrl does not exist to render anything. When parented or made a child of other controls, you can toggle flags on or off to make use of its specialized callbacks. Normally these callbacks are used as utility functions by the GUI Editor, or other container classes. However, for very fancy GUI work where controls interact with each other constantly, this is a handy utility to make use of.

 @tsexample
// Common member fields left out for sake of example
new GuiScriptNotifyCtrl()
{
^onChildAdded = "0";
^onChildRemoved = "0";
^onChildResized = "0";
^onParentResized = "0";
};
@endtsexample

@ingroup GuiUtil
 */
class  GuiScriptNotifyCtrl : public GuiControl {
  public:
      /*! Called when this GUI is resized.

@param ID Unique object ID assigned when created (%this in script).
 */
      void onResize( SimObjectId ID );

      /*! Called when a child is added to this GUI.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being added.
 */
      void onChildAdded( SimObjectId ID, SimObjectId childID );

      /*! Called when a child is removed from this GUI.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being removed.
 */
      void onChildRemoved( SimObjectId ID, SimObjectId childID );

      /*! Called when a child is of this GUI is being resized.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being resized.
 */
      void onChildResized( SimObjectId ID, SimObjectId childID );

      /*! Called when this GUI's parent is resized.

@param ID Unique object ID assigned when created (%this in script).
 */
      void onParentResized( SimObjectId ID );

      /*! Called when this GUI loses focus.

@param ID Unique object ID assigned when created (%this in script).
 */
      void onLoseFirstResponder( SimObjectId ID );

      /*! Called when this GUI gains focus.

@param ID Unique object ID assigned when created (%this in script).
 */
      void onGainFirstResponder( SimObjectId ID );


   /*! @name Callbacks
   @{ */
   /*! */
   /*!
   Enables/disables onChildAdded callback
   
    */
   bool onChildAdded;
   /*!
   Enables/disables onChildRemoved callback
   
    */
   bool onChildRemoved;
   /*!
   Enables/disables onChildResized callback
   
    */
   bool onChildResized;
   /*!
   Enables/disables onParentResized callback
   
    */
   bool onParentResized;
   /*!
   Enables/disables onResize callback
   
    */
   bool onResize;
   /*!
   Enables/disables onLoseFirstResponder callback
   
    */
   bool onLoseFirstResponder;
   /*!
   Enables/disables onGainFirstResponder callback
   
    */
   bool onGainFirstResponder;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Remnant from ancient script debugger (TGE days?)

Possibly useful for an editor tooltip.

 */
class  DbgFileView : public GuiArrayCtrl {
  public:
   /*! Set the current highlighted line. */
   virtual void setCurrentLine((int line, bool selected)) {}
   /*! Get the currently executing file and line, if any.

@returns A string containing the file, a tab, and then the line number. Use getField() with this. */
   virtual string getCurrentLine(()) {}
   /*! Open a file for viewing.

@note This loads the file from the local system. */
   virtual bool open((string filename)) {}
   /*! Clear all break points in the current file. */
   virtual void clearBreakPositions(()) {}
   /*! Set a breakpoint at the specified line. */
   virtual void setBreakPosition((int line)) {}
   /*! Set a breakpoint at the specified line. */
   virtual void setBreak((int line)) {}
   /*! Remove a breakpoint from the specified line. */
   virtual void removeBreak((int line)) {}
   /*! Find the specified string in the currently viewed file and scroll it into view. */
   virtual bool findString((string findThis)) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Native side of the GUI editor.

Editor use only.

 */
class  GuiEditCtrl : public GuiControl {
  public:
      /*!  */
      void onHierarchyChanged();

      /*!  */
      void onDelete();

      /*!  */
      void onPreEdit( SimSet selection );

      /*!  */
      void onPostEdit( SimSet selection );

      /*!  */
      void onClearSelected();

      /*!  */
      void onSelect( GuiControl control );

      /*!  */
      void onAddSelected( GuiControl control );

      /*!  */
      void onRemoveSelected( GuiControl control );

      /*!  */
      void onPreSelectionNudged( SimSet selection );

      /*!  */
      void onPostSelectionNudged( SimSet selection );

      /*!  */
      void onSelectionMoved( GuiControl control );

      /*!  */
      void onSelectionCloned( SimSet selection );

      /*!  */
      void onTrashSelection( SimSet selection );

      /*!  */
      void onAddNewCtrl( GuiControl control );

      /*!  */
      void onAddNewCtrlSet( SimSet set );

      /*!  */
      void onSelectionResized( GuiControl control );

      /*!  */
      void onFitIntoParent( bool width, bool height );

      /*!  */
      void onMouseModeChange();

      /*!  */
      void onControlInspectPreApply( GuiControl control );

      /*!  */
      void onControlInspectPostApply( GuiControl control );

   /*! Return the toplevel control edited inside the GUI editor. */
   virtual int getContentControl(()) {}
   /*! Set the toplevel control to edit in the GUI editor. */
   virtual void setContentControl(( GuiControl ctrl )) {}
   virtual void addNewCtrl((GuiControl ctrl)) {}
   /*! selects a control. */
   virtual void addSelection() {}
   /*! deselects a control. */
   virtual void removeSelection() {}
   /*! Clear selected controls list. */
   virtual void clearSelection() {}
   virtual void select((GuiControl ctrl)) {}
   virtual void setCurrentAddSet((GuiControl ctrl)) {}
   /*! Returns the set to which new controls will be added */
   virtual int getCurrentAddSet() {}
   /*! Toggle activation. */
   virtual void toggle() {}
   virtual void justify((int mode)) {}
   virtual void bringToFront() {}
   virtual void pushToBack() {}
   /*! Delete the selected controls. */
   virtual void deleteSelection(()) {}
   /*! Move all controls in the selection by (dx,dy) pixels. */
   virtual void moveSelection((int dx, int dy)) {}
   /*! Save selection to file or clipboard. */
   virtual void saveSelection(( string fileName=null )) {}
   /*! Load selection from file or clipboard. */
   virtual void loadSelection(( string fileName=null )) {}
   virtual void selectAll(()) {}
   /*! Gets the set of GUI controls currently selected in the editor. */
   virtual string getSelection(()) {}
   /*! Return the number of controls currently selected. */
   virtual int getNumSelected(()) {}
   /*! Returns global bounds of current selection as vector 'x y width height'. */
   virtual string getSelectionGlobalBounds(()) {}
   /*! Select parents of currently selected controls. */
   virtual void selectParents(( bool addToSelection=false )) {}
   /*! Select children of currently selected controls. */
   virtual void selectChildren(( bool addToSelection=false )) {}
   /*! Gets the GUI controls(s) that are currently in the trash. */
   virtual string getTrash(()) {}
   /*! GuiEditCtrl.setSnapToGrid(gridsize) */
   virtual void setSnapToGrid() {}
   /*! Read the guides from the given control. */
   virtual void readGuides(( GuiControl ctrl [, int axis ] )) {}
   /*! Write the guides to the given control. */
   virtual void writeGuides(( GuiControl ctrl [, int axis ] )) {}
   /*! Clear all currently set guide lines. */
   virtual void clearGuides(( [ int axis ] )) {}
   /*! Fit selected controls into their parents. */
   virtual void fitIntoParents(( bool width=true, bool height=true )) {}
   /*! Return the current mouse mode. */
   virtual string getMouseMode(()) {}

   /*! @name Snapping
   @{ */
   /*! */
   /*!
   If true, edge and center snapping will work against controls.
   
    */
   bool snapToControls;
   /*!
   If true, edge and center snapping will work against guides.
   
    */
   bool snapToGuides;
   /*!
   If true, edge and center snapping will work against canvas (toplevel control).
   
    */
   bool snapToCanvas;
   /*!
   If true, selection edges will snap into alignment when moved or resized.
   
    */
   bool snapToEdges;
   /*!
   If true, selection centers will snap into alignment when moved or resized.
   
    */
   bool snapToCenters;
   /*!
   Distance in pixels that edge and center snapping will work across.
   
    */
   int snapSensitivity;
   /// @}


   /*! @name Selection
   @{ */
   /*! */
   /*!
   If true, rectangle selection will only select controls fully inside the drag rectangle.
   
    */
   bool fullBoxSelection;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
   If true, lines will be drawn extending along the edges of selected objects.
   
    */
   bool drawBorderLines;
   /*!
   If true, guides will be included in rendering.
   
    */
   bool drawGuides;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that displays a Catmull-Rom spline through a number of control points.

Currently editor use only, no real application without extension.

 */
class  GuiFilterCtrl : public GuiControl {
  public:
   /*! Return a tuple containing all the values in the filter.@internal */
   virtual string getValue() {}
   /*! Reset the filter to use the specified points, spread equidistantly across the domain.@internal */
   virtual void setValue((f1, f2, ...)) {}
   /*! Reset the filtering.@internal */
   virtual void identity() {}
   /*!
   Total number of control points in the spline curve.
   
    */
   int controlPoints;
   /*!
   Vector of control points.
   
    */
   floatList filter;
   /*!
   @internal
   
    */
   bool showIdentity;
   /*!
   @internal
   
    */
   Point2F identity;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that plots one or more curves in a chart.

Up to 6 individual curves can be plotted in the graph.  Each plotted curve can have its own display style including its own charting style (#plotType) and color (#plotColor).

The data points on each curve can be added in one of two ways:

- Manually by calling addDatum().  This causes new data points to be added to the left end of the plotting curve.
- Automatically by letting the graph plot the values of a variable over time.  This is achieved by calling addAutoPlot and specifying the variable and update frequency.

@tsexample
// Create a graph that plots a red polyline graph of the FPS counter in a 1 second (1000 milliseconds) interval.
new GuiGraphCtrl( FPSGraph )
{
   plotType[ 0 ] = "PolyLine";
   plotColor[ 0 ] = "1 0 0";
   plotVariable[ 0 ] = "fps::real";
   plotInterval[ 0 ] = 1000;
};
@endtsexample

@note Each curve has a maximum number of 200 data points it can have at any one time.  Adding more data points to a curve will cause older data points to be removed.

 */
class  GuiGraphCtrl : public GuiControl {
  public:
   /*! Add a data point to the plot's curve.

@param plotId Index of the plotting curve to which to add the data point.  Must be 0<=plotId<6.
@param value Value of the data point to add to the curve.

@note Data values are added to the @b left end of the plotting curve.

@note A maximum number of 200 data points can be added to any single plotting curve at any one time.  If this limit is exceeded, data points on the right end of the curve are culled. */
   virtual void addDatum(( int plotId, float value )) {}
   /*! Get a data point on the given plotting curve.

@param plotId Index of the plotting curve from which to fetch the data point.  Must be 0<=plotId<6.
@param index Index of the data point on the curve.
@return The value of the data point or -1 if @a plotId or @a index are out of range. */
   virtual float getDatum(( int plotId, int index )) {}
   /*! Sets up the given plotting curve to automatically plot the value of the @a variable with a frequency of @a updateFrequency.
@param plotId Index of the plotting curve.  Must be 0<=plotId<6.
@param variable Name of the global variable.
@param updateFrequency Frequency with which to add new data points to the plotting curve (in milliseconds).
@tsexample
// Plot FPS counter at 1 second intervals.
%graph.addAutoPlot( 0, "fps::real", 1000 );
@endtsexample */
   virtual void addAutoPlot(( int plotId, string variable, int updateFrequency )) {}
   /*! Stop automatic variable plotting for the given curve.
@param plotId Index of the plotting curve.  Must be 0<=plotId<6.
 */
   virtual void removeAutoPlot(( int plotId )) {}
   /*! Change the charting type of the given plotting curve.
@param plotId Index of the plotting curve.  Must be 0<=plotId<6.
@param graphType Charting type to use for the curve.
@note Instead of calling this method, you can directly assign to #plotType. */
   virtual void setGraphType(( int plotId, GuiGraphType graphType )) {}
   /*! Set the scale of all specified plots to the maximum scale among them.

@param plotID1 Index of plotting curve.
@param plotID2 Index of plotting curve. */
   virtual void matchScale(( int plotID1, int plotID2, ... )) {}

   /*! @name Graph
   @{ */
   /*! */
   /*!
   Ratio of where to place the center coordinate of the graph on the Y axis. 0.5=middle height of control.

This allows to account for graphs that have only positive or only negative data points, for example.
   
    */
   float centerY;
   /*!
   Color to use for the plotting curves in the graph.
   
    */
   ColorF plotColor;
   /*!
   Charting type of the plotting curves.
   
    */
   GuiGraphType plotType;
   /*!
   Name of the variable to automatically plot on the curves.  If empty, auto-plotting is disabled for the respective curve.
   
    */
   string plotVariable;
   /*!
   Interval between auto-plots of #plotVariable for the respective curve (in milliseconds).
   
    */
   int plotInterval;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI control which displays a list of images.

Used to be a part of an old editor system for previous Torque systems. Doesn't appear to be used anymore, will most likely be deprecated.

@ingroup GuiCore
 */
class  GuiImageList : public SimObject {
  public:
   /*! @brief Get a path to the texture at the specified index.

@param index Index of the image in the list.
@tsexample
// Define the image index/n%index = "5";

// Request the image path location from the control.
%imagePath = %thisGuiImageList.getImage(%index);
@endtsexample

@return File path to the image map for the specified index.

@see SimObject */
   virtual string getImage(( int index )) {}
   /*! @brief Clears the imagelist

@tsexample
// Inform the GuiImageList control to clear itself.
%isFinished = %thisGuiImageList.clear();
@endtsexample

@return Returns true when finished.

@see SimObject */
   virtual bool clear(()) {}
   /*! @brief Gets the number of images in the list.

@tsexample
// Request the number of images from the GuiImageList control.
%imageCount = %thisGuiImageList.count();
@endtsexample

@return Number of images in the control.

@see SimObject */
   virtual int count(()) {}
   /*! @brief Removes an image from the list by index.

@param index Image index to remove.
@tsexample
// Define the image index.
%imageIndex = "4";

// Inform the GuiImageList control to remove the image at the defined index.
%wasSuccessful = %thisGuiImageList.remove(%imageIndex);
@endtsexample

@return True if the operation was successful, false if it was not.

@see SimObject */
   virtual bool remove(( int index )) {}
   /*! @brief Retrieves the imageindex of a specified texture in the list.

@param imagePath Imagemap including filepath of image to search for
@tsexample
// Define the imagemap to search for
%imagePath = "./game/client/data/images/thisImage";

// Request the index entry for the defined imagemap
%imageIndex = %thisGuiImageList.getIndex(%imagePath);
@endtsexample

@return Index of the imagemap matching the defined image path.

@see SimObject */
   virtual int getIndex(( string imagePath )) {}
   /*! @brief Insert an image into imagelist- returns the image index or -1 for failure.

@param imagePath Imagemap, with path, to add to the list.
@tsexample
// Define the imagemap to add to the list
%imagePath = "./game/client/data/images/thisImage";

// Request the GuiImageList control to add the defined image to its list.
%imageIndex = %thisGuiImageList.insert(%imagePath);
@endtsexample

@return The index of the newly inserted imagemap, or -1 if the insertion failed.

@see SimObject */
   virtual int insert(( string imagePath )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that allows to edit the properties of one or more SimObjects.

Editor use only.

 */
class  GuiInspector : public GuiStackControl {
  public:
   /*! Inspect(Object) */
   virtual void inspect() {}
   /*! Add the object to the list of objects being inspected. */
   virtual void addInspect(( id object, (bool autoSync = true) )) {}
   /*! Remove the object from the list of objects being inspected. */
   virtual void removeInspect(( id object )) {}
   /*! Reinspect the currently selected object. */
   virtual void refresh() {}
   /*! getInspectObject( int index=0 ) - Returns currently inspected object */
   virtual string getInspectObject() {}
   /*! Return the number of objects currently being inspected. */
   virtual int getNumInspectObjects(()) {}
   /*! setName(NewObjectName) */
   virtual void setName() {}
   /*! apply() - Force application of inspected object's attributes */
   virtual void apply() {}
   /*! setObjectField( fieldname, data ) - Set a named fields value on the inspected object if it exists. This triggers all the usual callbacks that would occur if the field had been changed through the gui. */
   virtual void setObjectField() {}
   /*! findByObject( SimObject ) - returns the id of an awake inspector that is inspecting the passed object if one exists. */
   virtual int findByObject() {}
   /*! Clears Inspector */
   virtual void clearAll() {}

   /*! @name Inspector
   @{ */
   /*! */
   /*!
    */
   int dividerMargin;
   /*!
   Specify groups that should be shown or not. Specifying 'shown' implicitly does 'not show' all other groups. Example string: +name -otherName
   
    */
   string groupFilters;
   /*!
   If false the custom fields Name, Id, and Source Class will not be shown.
   
    */
   bool showCustomFields;
   /// @}


   /*! @name Stacking
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Inspector field type for TypeBitMask32.

Editor use only.

 */
class  GuiInspectorTypeBitMask32 : public GuiInspectorField {
  public:
   /*! apply(); */
   virtual void applyBit() {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI Control which displays a horizontal bar with individual drop-down menu items. Each menu item may also have submenu items.

@tsexample
new GuiMenuBar(newMenuBar)
{
^Padding = "0";
^//Properties not specific to this control have been omitted from this example.
};

// Add a menu to the menu bar
newMenuBar.addMenu(0,"New Menu");

// Add a menu item to the New Menu
newMenuBar.addMenuItem(0,"New Menu Item",0,"n",-1);

// Add a submenu item to the New Menu Item
newMenuBar.addSubmenuItem(0,1,"New Submenu Item",0,"s",-1);
@endtsexample

@see GuiTickCtrl

@ingroup GuiCore
 */
class  GuiMenuBar : public GuiTickCtrl {
  public:
      /*! @brief Called whenever the mouse enters, or persists is in the menu.

@param isInMenu True if the mouse has entered the menu, otherwise is false.
@note To receive this callback, call setProcessTicks(true) on the menu bar.
@tsexample
// Mouse enters or persists within the menu, causing the callback to occur.
GuiMenuBar::onMouseInMenu(%this,%hasLeftMenu)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl

 */
      void onMouseInMenu( bool isInMenu );

      /*! @brief Called whenever a menu is selected.

@param menuId Index id of the clicked menu
@param menuText Text of the clicked menu

@tsexample
// A menu has been selected, causing the callback to occur.
GuiMenuBar::onMenuSelect(%this,%menuId,%menuText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl

 */
      void onMenuSelect( string menuId, string menuText );

      /*! @brief Called whenever an item in a menu is selected.

@param menuId Index id of the menu which contains the selected menu item
@param menuText Text of the menu which contains the selected menu item

@param menuItemId Index id of the selected menu item
@param menuItemText Text of the selected menu item

@tsexample
// A menu item has been selected, causing the callback to occur.
GuiMenuBar::onMenuItemSelect(%this,%menuId,%menuText,%menuItemId,%menuItemText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl

 */
      void onMenuItemSelect( string menuId, string menuText, string menuItemId, string menuItemText );

      /*! @brief Called whenever a submenu is selected.

@param submenuId Id of the selected submenu
@param submenuText Text of the selected submenu

@tsexample
GuiMenuBar::onSubmenuSelect(%this,%submenuId,%submenuText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl

 */
      void onSubmenuSelect( string submenuId, string submenuText );

   /*! @brief Clears all the menus from the menu bar.

@tsexample
// Inform the GuiMenuBar control to clear all menus from itself.
%thisGuiMenuBar.clearMenus();
@endtsexample

@see GuiTickCtrl */
   virtual void clearMenus(( int param1, int param2 )) {}
   /*! @brief Sets the menu rendering margins: horizontal, vertical, bitmap spacing.

Detailed description

@param horizontalMargin Number of pixels on the left and right side of a menu's text.
@param verticalMargin Number of pixels on the top and bottom of a menu's text.
@param bitmapToTextSpacing Number of pixels between a menu's bitmap and text.
@tsexample
// Define the horizontalMargin
%horizontalMargin = "5";

// Define the verticalMargin
%verticalMargin = "5";

// Define the bitmapToTextSpacing
%bitmapToTextSpacing = "12";

// Inform the GuiMenuBar control to set its margins based on the defined values.
%thisGuiMenuBar.setMenuMargins(%horizontalMargin,%verticalMargin,%bitmapToTextSpacing);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuMargins(( int horizontalMargin, int verticalMargin, int bitmapToTextSpacing )) {}
   /*! @brief Adds a new menu to the menu bar.

@param menuText Text to display for the new menu item.
@param menuId ID for the new menu item.
@tsexample
// Define the menu text
%menuText = "New Menu";

// Define the menu ID.
%menuId = "2";

// Inform the GuiMenuBar control to add the new menu
%thisGuiMenuBar.addMenu(%menuText,%menuId);
@endtsexample

@see GuiTickCtrl */
   virtual void addMenu(( string menuText, int menuId )) {}
   /*! @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.

@param menu Menu name or menu Id to add the new item to.
@param menuItemText Text for the new menu item.
@param menuItemId Id for the new menu item.
@param accelerator Accelerator key for the new menu item.
@param checkGroup Check group to include this menu item in.
@tsexample
// Define the menu we wish to add the item to
%targetMenu = "New Menu";  or  %menu = "4";

// Define the text for the new menu item
%menuItemText = "Menu Item";

// Define the id for the new menu item
%menuItemId = "3";

// Set the accelerator key to toggle this menu item with
%accelerator = "n";

// Define the Check Group that this menu item will be in, if we want it to be in a check group. -1 sets it in no check group.
%checkGroup = "4";

// Inform the GuiMenuBar control to add the new menu item with the defined fields
%thisGuiMenuBar.addMenuItem(%menu,%menuItemText,%menuItemId,%accelerator,%checkGroup);
@endtsexample

@see GuiTickCtrl */
   virtual void addMenuItem(( string targetMenu="", string menuItemText="", int menuItemId=0, string accelerator=NULL, int checkGroup=-1 )) {}
   /*! @brief sets the menu item to enabled or disabled based on the enable parameter.
The specified menu and menu item can either be text or ids.

Detailed description

@param menuTarget Menu to work in
@param menuItemTarget The menu item inside of the menu to enable or disable
@param enabled Boolean enable / disable value.
@tsexample
// Define the menu
%menu = "New Menu";  or  %menu = "4";

// Define the menu item
%menuItem = "New Menu Item";  or %menuItem = "2";

// Define the enabled state
%enabled = "true";

// Inform the GuiMenuBar control to set the enabled state of the requested menu item
%thisGuiMenuBar.setMenuItemEnable(%menu,%menuItme,%enabled);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuItemEnable(( string menuTarget, string menuItemTarget, bool enabled )) {}
   /*! @brief Sets the menu bitmap index for the check mark image.

@param bitmapIndex Bitmap index for the check mark image.
@tsexample
// Define the bitmap index
%bitmapIndex = "2";

// Inform the GuiMenuBar control of the proper bitmap index for the check mark image
%thisGuiMenuBar.setCheckmarkBitmapIndex(%bitmapIndex);
@endtsexample

@see GuiTickCtrl */
   virtual void setCheckmarkBitmapIndex(( int bitmapindex )) {}
   /*! @brief Sets the menu item bitmap to a check mark, which by default is the first element in
the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
Any other menu items in the menu with the same check group become unchecked if they are checked.

@param menuTarget Menu to work in
@param menuItem Menu item to affect
@param checked Whether we are setting it to checked or not
@tsexample
@endtsexample

@return If not void, return value and description

@see References */
   virtual void setMenuItemChecked(( string menuTarget, string menuItemTarget, bool checked )) {}
   /*! @brief Sets the text of the specified menu to the new string.

@param menuTarget Menu to affect
@param newMenuText New menu text
@tsexample
// Define the menu to affect%menu = "New Menu";  or %menu = "3";

// Define the text to change the menu to
%newMenuText = "Still a New Menu";

// Inform the GuiMenuBar control to change the defined menu to the defined text
%thisGuiMenuBar.setMenuText(%menu,%newMenuText);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuText(( string menuTarget, string newMenuText )) {}
   /*! @brief Sets the bitmap index for the menu and toggles rendering only the bitmap.

@param menuTarget Menu to affect
@param bitmapindex Bitmap index to set for the menu
@param bitmaponly If true, only the bitmap will be rendered
@param drawborder If true, a border will be drawn around the menu.
@tsexample
// Define the menuTarget to affect
%menuTarget = "New Menu";  or %menuTarget = "3";

// Set the bitmap index
%bitmapIndex = "5";

// Set if we are only to render the bitmap or not
%bitmaponly = "true";

// Set if we are rendering a border or not
%drawborder = "true";

// Inform the GuiMenuBar of the bitmap and rendering changes
%thisGuiMenuBar.setMenuBitmapIndex(%menuTarget,%bitmapIndex,%bitmapOnly,%drawBorder);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuBitmapIndex(( string menuTarget, int bitmapindex, bool bitmaponly, bool drawborder )) {}
   /*! @brief Sets the whether or not to display the specified menu.

@param menuTarget Menu item to affect
@param visible Whether the menu item will be visible or not
@tsexample
// Define the menu to work with
%menuTarget = "New Menu";  or  %menuTarget = "4";

// Define if the menu should be visible or not
%visible = "true";

// Inform the GuiMenuBar control of the new visibility state for the defined menu
%thisGuiMenuBar.setMenuVisible(%menuTarget,%visible);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuVisible(( string menuTarget, bool visible )) {}
   /*! @brief Sets the text of the specified menu item to the new string.

@param menuTarget Menu to affect
@param menuItem Menu item in the menu to change the text at
@param newMenuItemText New menu text
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "4";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "2";

// Define the new text for the menu item
%newMenuItemText = "Very New Menu Item";

// Inform the GuiMenuBar control to change the defined menu item with the new text
%thisGuiMenuBar.setMenuItemText(%menuTarget,%menuItem,%newMenuItemText);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuItemText(( string menuTarget, string menuItemTarget, string newMenuItemText )) {}
   /*! @brief Brief Description.

Detailed description

@param menuTarget Menu to affect the menu item in
@param menuItem Menu item to affect
@param isVisible Visible state to set the menu item to.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "2";

// Define the visibility state
%isVisible = "true";

// Inform the GuiMenuBarControl of the visibility state of the defined menu item
%thisGuiMenuBar.setMenuItemVisible(%menuTarget,%menuItem,%isVisible);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuItemVisible(( string menuTarget, string menuItemTarget, bool isVisible )) {}
   /*! @brief Sets the specified menu item bitmap index in the bitmap array.  Setting the item's index to -1 will remove any bitmap.

@param menuTarget Menu to affect the menuItem in
@param menuItem Menu item to affect
@param bitmapIndex Bitmap index to set the menu item to
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem"
%menuItem = "New Menu Item";  or %menuItem = "2";

// Define the bitmapIndex
%bitmapIndex = "6";

// Inform the GuiMenuBar control to set the menu item to the defined bitmap
%thisGuiMenuBar.setMenuItemBitmap(%menuTarget,%menuItem,%bitmapIndex);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuItemBitmap(( string menuTarget, string menuItemTarget, int bitmapIndex )) {}
   /*! @brief Removes the specified menu item from the menu.

@param menuTarget Menu to affect the menu item in
@param menuItem Menu item to affect
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Request the GuiMenuBar control to remove the define menu item
%thisGuiMenuBar.removeMenuItem(%menuTarget,%menuItem);

@endtsexample

@see GuiTickCtrl */
   virtual void removeMenuItem(( string menuTarget, string menuItemTarget )) {}
   /*! @brief Removes all the menu items from the specified menu.

@param menuTarget Menu to remove all items from
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Inform the GuiMenuBar control to clear all menu items from the defined menu
%thisGuiMenuBar.clearMenuItems(%menuTarget);
@endtsexample

@see GuiTickCtrl */
   virtual void clearMenuItems(( string menuTarget )) {}
   /*! @brief Removes the specified menu from the menu bar.

@param menuTarget Menu to remove from the menu bar
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Inform the GuiMenuBar to remove the defined menu from the menu bar
%thisGuiMenuBar.removeMenu(%menuTarget);
@endtsexample

@see GuiTickCtrl */
   virtual void removeMenu(( string menuTarget )) {}
   /*! @brief Sets the given menu item to be a submenu.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param isSubmenu Whether or not the menuItem will become a subMenu or not
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define whether or not the Menu Item is a sub menu or not
%isSubmenu = "true";

// Inform the GuiMenuBar control to set the defined menu item to be a submenu or not.
%thisGuiMenuBar.setMenuItemSubmenuState(%menuTarget,%menuItem,%isSubmenu);
@endtsexample

@see GuiTickCtrl */
   virtual void setMenuItemSubmenuState(( string menuTarget, string menuItem, bool isSubmenu )) {}
   /*! @brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param submenuItemText Text to show for the new submenu
@param submenuItemId Id for the new submenu
@param accelerator Accelerator key for the new submenu
@param checkGroup Which check group the new submenu should be in, or -1 for none.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define the text for the new submenu
%submenuItemText = "New Submenu Item";

// Define the id for the new submenu
%submenuItemId = "4";

// Define the accelerator key for the new submenu
%accelerator = "n";

// Define the checkgroup for the new submenu
%checkgroup = "7";

// Request the GuiMenuBar control to add the new submenu with the defined information
%thisGuiMenuBar.addSubmenuItem(%menuTarget,%menuItem,%submenuItemText,%submenuItemId,%accelerator,%checkgroup);
@endtsexample

@see GuiTickCtrl
 */
   virtual void addSubmenuItem(( string menuTarget, string menuItem, string submenuItemText, int submenuItemId, string accelerator, int checkGroup )) {}
   /*! @brief Removes all the menu items from the specified submenu.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Inform the GuiMenuBar to remove all submenu items from the defined menu item
%thisGuiMenuBar.clearSubmenuItems(%menuTarget,%menuItem);

@endtsexample

@see GuiControl */
   virtual void clearSubmenuItems(( string menuTarget, string menuItem )) {}
   /*! @brief Sets the menu item bitmap to a check mark, which by default is the first element in the
bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
Any other menu items in the menu with the same check group become unchecked if they are checked.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param submenuItemText Text to show for submenu
@param checked Whether or not this submenu item will be checked.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define the text for the new submenu
%submenuItemText = "Submenu Item";

// Define if this submenu item should be checked or not
%checked = "true";

// Inform the GuiMenuBar control to set the checked state of the defined submenu item
%thisGuiMenuBar.setSubmenuItemChecked(%menuTarget,%menuItem,%submenuItemText,%checked);
@endtsexample

@return If not void, return value and description

@see References */
   virtual void setSubmenuItemChecked(( string menuTarget, string menuItemTarget, string submenuItemText, bool checked )) {}
   /*!
   Extra padding to add to the bounds of the control.

   
    */
   int padding;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Legacy remnant from old Torque particle editor

Editor use only.

 */
class  GuiParticleGraphCtrl : public GuiControl {
  public:
   /*! Set the selected point on the graph.
@return No return value */
   virtual void setSelectedPoint((int point)) {}
   /*! Set the selected plot (a.k.a. graph).@return No return value */
   virtual void setSelectedPlot((int plotID)) {}
   /*! Clear the graph of the given plot.@return No return value */
   virtual void clearGraph((int plotID)) {}
   /*! Clear all of the graphs.@return No return value */
   virtual void clearAllGraphs(()) {}
   /*! Add a data point to the given plot.@return */
   virtual string addPlotPoint((int plotID, float x, float y, bool setAdded = true;)) {}
   /*! Insert a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value. */
   virtual void insertPlotPoint((int plotID, int i, float x, float y)) {}
   /*! Change a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value. */
   virtual string changePlotPoint((int plotID, int i, float x, float y)) {}
   /*! Gets the selected Plot (a.k.a. graph).
@return The plot's ID. */
   virtual string getSelectedPlot(()) {}
   /*! Gets the selected Point on the Plot (a.k.a. graph).@return The last selected point ID */
   virtual string getSelectedPoint(()) {}
   /*! @return Returns true or false whether or not the point in the plot passed is an existing point. */
   virtual string isExistingPoint((int plotID, int samples)) {}
   /*! Get a data point from the plot specified, samples from the start of the graph.@return The data point ID */
   virtual string getPlotPoint((int plotID, int samples)) {}
   /*! Gets the index of the point passed on the plotID passed (graph ID).
@param plotID The plot you wish to check.
@param x,y The coordinates of the point to get.
@return Returns the index of the point.
 */
   virtual string getPlotIndex((int plotID, float x, float y)) {}
   /*! Get the color of the graph passed.@return Returns the color of the graph as a string of RGB values formatted as "R G B" */
   virtual string getGraphColor((int plotID)) {}
   /*! Get the minimum values of the graph ranges.
@return Returns the minimum of the range formatted as "x-min y-min" */
   virtual string getGraphMin((int plotID)) {}
   /*! Get the maximum values of the graph ranges.
@return Returns the maximum of the range formatted as "x-max y-max" */
   virtual string getGraphMax((int plotID)) {}
   /*! Get the name of the graph passed.
@return Returns the name of the plot */
   virtual string getGraphName((int plotID)) {}
   /*! Set the min values of the graph of plotID.
@param plotID The plot to modify
@param minX,minY The minimum bound of the value range.
@return No return value. */
   virtual void setGraphMin((int plotID, float minX, float minY)) {}
   /*! Set the min X value of the graph of plotID.
@param plotID The plot to modify.
@param minX The minimum x value.
@return No return Value. */
   virtual void setGraphMinX((int plotID, float minX)) {}
   /*! Set the min Y value of the graph of plotID.@param plotID The plot to modify.
@param minY The minimum y value.
@return No return Value. */
   virtual void setGraphMinY((int plotID, float minY)) {}
   /*! Set the max values of the graph of plotID.@param plotID The plot to modify
@param maxX,maxY The maximum bound of the value range.
@return No return value. */
   virtual void setGraphMax((int plotID, float maxX, float maxY)) {}
   /*! Set the max X value of the graph of plotID.@param plotID The plot to modify.
@param maxX The maximum x value.
@return No return Value. */
   virtual void setGraphMaxX((int plotID, float maxX)) {}
   /*! Set the max Y value of the graph of plotID.@param plotID The plot to modify.
@param maxY The maximum y value.
@return No return Value. */
   virtual void setGraphMaxY((int plotID, float maxY)) {}
   /*! Set whether the graph number passed is hidden or not.@return No return value. */
   virtual void setGraphHidden((int plotID, bool isHidden)) {}
   /*! Set whether the max will automatically be set when adding points (ie if you add a value over the current max, the max is increased to that value).
@return No return value. */
   virtual void setAutoGraphMax((bool autoMax)) {}
   /*! Set whether or not a point should be deleted when you drag another one over it.@return No return value. */
   virtual void setAutoRemove((bool autoRemove)) {}
   /*! Set whether or not a position should be rendered on every point or just the last selected.@return No return value. */
   virtual void setRenderAll((bool renderAll)) {}
   /*! Set whether the x position of the selected graph point should be clamped@return No return value. */
   virtual void setPointXMovementClamped((bool clamped)) {}
   /*! Set whether or not to render the graph tooltip.@return No return value. */
   virtual void setRenderGraphTooltip((bool renderGraphTooltip)) {}
   /*! Set the name of the given plot.
@param plotID The plot to modify.
@param graphName The name to set on the plot.
@return No return value. */
   virtual void setGraphName((int plotID, string graphName)) {}
   /*! This will reset the currently selected point to nothing.@return No return value. */
   virtual void resetSelectedPoint(()) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This control provides the 3D view for the Shape Editor tool, and is not intended for general purpose use.
@ingroup GuiControls
 */
class  GuiShapeEdPreview : public EditTSCtrl {
  public:
      /*! Called when the position of the active thread has changed, such as during playback. */
      void onThreadPosChanged( float pos, bool inTransition );

   /*! Set the camera orbit position

@param pos Position in the form "x y z"
 */
   virtual void setOrbitPos(( Point3F pos )) {}
   /*! Sets the model to be displayed in this control

@param shapeName Name of the model to display.
@return True if the model was loaded successfully, false otherwise.
 */
   virtual bool setModel(( string shapePath )) {}
   /*! Adjust the camera position and zoom to fit the shape within the view.

 */
   virtual void fitToShape(()) {}
   /*! Refresh the shape (used when the shape meshes or nodes have been added or removed)

 */
   virtual void refreshShape(()) {}
   /*! Refresh the shape node transforms (used when a node transform has been modified externally)

 */
   virtual void updateNodeTransforms(()) {}
   /*! Compute the bounding box of the shape using the current detail and node transforms

@return the bounding box "min.x min.y min.z max.x max.y max.z" */
   virtual string computeShapeBounds(()) {}
   /*! Return whether the named object is currently hidden

 */
   virtual bool getMeshHidden(( string name )) {}
   /*! Show or hide the named object in the shape

 */
   virtual void setMeshHidden(( string name, bool hidden )) {}
   /*! Show or hide all objects in the shape

 */
   virtual void setAllMeshesHidden(( bool hidden )) {}
   /*! Export the current shape and all mounted objects to COLLADA (.dae).
Note that animation is not exported, and all geometry is combined into a single mesh.

@param path Destination filename
 */
   virtual void exportToCollada(( string path )) {}
   /*! Add a new thread (initially without any sequence set)

 */
   virtual void addThread(()) {}
   /*! Removes the specifed thread

@param slot index of the thread to remove
 */
   virtual void removeThread(( int slot )) {}
   /*! Get the number of threads

@return the number of threads
 */
   virtual int getThreadCount(()) {}
   /*! Set the time scale of all threads

@param scale new time scale value
 */
   virtual void setTimeScale(( float scale )) {}
   /*! Sets the sequence to play for the active thread.

@param name name of the sequence to play
@param duration transition duration (0 for no transition)
@param pos position in the new sequence to transition to
@param play if true, the new sequence will play during the transition
 */
   virtual void setThreadSequence(( string name, float duration=0, float pos=0, bool play=false )) {}
   /*! Get the name of the sequence assigned to the active thread */
   virtual string getThreadSequence(()) {}
   /*! Refreshes thread sequences (in case of removed/renamed sequences */
   virtual void refreshThreadSequences(()) {}
   /*! Mount a shape onto the main shape at the specified node

@param shapePath path to the shape to mount
@param nodeName name of the node on the main shape to mount to
@param type type of mounting to use (Object, Image or Wheel)
@param slot mount slot
 */
   virtual bool mountShape(( string shapePath, string nodeName, string type, int slot )) {}
   /*! Set the node a shape is mounted to.

@param slot mounted shape slot
@param nodename name of the node to mount to
 */
   virtual void setMountNode(( int slot, string nodeName )) {}
   /*! Get the name of the sequence playing on this mounted shape
@param slot mounted shape slot
@return name of the sequence (if any)
 */
   virtual string getMountThreadSequence(( int slot )) {}
   /*! Set the sequence to play for the shape mounted in the specified slot
@param slot mounted shape slot
@param name name of the sequence to play
 */
   virtual void setMountThreadSequence(( int slot, string name )) {}
   /*! Get the playback position of the sequence playing on this mounted shape
@param slot mounted shape slot
@return playback position of the sequence (0-1)
 */
   virtual float getMountThreadPos(( int slot )) {}
   /*! Set the sequence position of the shape mounted in the specified slot
@param slot mounted shape slot
@param pos sequence position (0-1)
 */
   virtual void setMountThreadPos(( int slot, float pos )) {}
   /*! Get the playback direction of the sequence playing on this mounted shape
@param slot mounted shape slot
@return direction of the sequence (-1=reverse, 0=paused, 1=forward)
 */
   virtual float getMountThreadDir(( int slot )) {}
   /*! Set the playback direction of the shape mounted in the specified slot
@param slot mounted shape slot
@param dir playback direction (-1=backwards, 0=paused, 1=forwards)
 */
   virtual void setMountThreadDir(( int slot, float dir )) {}
   /*! Unmount the shape in the specified slot
@param slot mounted shape slot
 */
   virtual void unmountShape(( int slot )) {}
   /*! Unmount all shapes
 */
   virtual void unmountAll(()) {}

   /*! @name Rendering
   @{ */
   /*! */
   /*!
   If true, dragging the gizmo will rotate the sun direction
   
    */
   bool editSun;
   /*!
   Index of the selected node, or -1 if none
   
    */
   int selectedNode;
   /*!
   Index of the selected object, or -1 if none
   
    */
   int selectedObject;
   /*!
   Index of the selected object detail mesh, or 0 if none
   
    */
   int selectedObjDetail;
   /*!
   Grid dimensions (number of rows and columns) in the form "rows cols"
   
    */
   Point2I gridDimension;
   /*!
   Flag indicating whether to draw the grid
   
    */
   bool renderGrid;
   /*!
   Flag indicating whether to render the shape nodes
   
    */
   bool renderNodes;
   /*!
   Flag indicating whether to render the shape in 'ghost' mode (transparent)
   
    */
   bool renderGhost;
   /*!
   Flag indicating whether to render the shape bounding box
   
    */
   bool renderBounds;
   /*!
   Flag indicating whether to render the selected object's bounding box
   
    */
   bool renderObjBox;
   /*!
   Flag indicating whether to render the shape's collision geometry
   
    */
   bool renderColMeshes;
   /*!
   Flag indicating whether to render mounted objects
   
    */
   bool renderMounts;
   /// @}


   /*! @name Sun
   @{ */
   /*! */
   /*!
   Ambient color for the sun
   
    */
   ColorI sunDiffuse;
   /*!
   Diffuse color for the sun
   
    */
   ColorI sunAmbient;
   /*!
   X-axis rotation angle for the sun
   
    */
   float sunAngleX;
   /*!
   Z-axis rotation angle for the sun
   
    */
   float sunAngleZ;
   /// @}


   /*! @name Animation
   @{ */
   /*! */
   /*!
   Index of the active thread, or -1 if none
   
    */
   int activeThread;
   /*!
   Current position of the active thread (0-1)
   
    */
   float threadPos;
   /*!
   Playback direction of the active thread
   
    */
   int threadDirection;
   /*!
   'PingPong' mode of the active thread
   
    */
   bool threadPingPong;
   /// @}


   /*! @name Detail Stats
   @{ */
   /*! */
   /*!
   If false, the current detail is selected based on camera distance
   
    */
   bool fixedDetail;
   /*!
   The current distance from the camera to the model
   
    */
   float orbitDist;
   /*!
   The current detail level
   
    */
   int currentDL;
   /*!
   The size of the current detail
   
    */
   int detailSize;
   /*!
   Number of polygons in the current detail
   
    */
   int detailPolys;
   /*!
   The current pixel size of the model
   
    */
   float pixelSize;
   /*!
   The number of materials in the current detail level
   
    */
   int numMaterials;
   /*!
   The number of draw calls in the current detail level
   
    */
   int numDrawCalls;
   /*!
   The number of bones in the current detail level (skins only)
   
    */
   int numBones;
   /*!
   The number of vertex weights in the current detail level (skins only)
   
    */
   int numWeights;
   /*!
   The number of collision meshes in the shape
   
    */
   int colMeshes;
   /*!
   The total number of collision polygons (all meshes) in the shape
   
    */
   int colPolys;
   /// @}


   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Custom field type for dynamic variable modification on SimObjects.

Editor use only.

 */
class  GuiInspectorDynamicField : public GuiInspectorField {
  public:
   /*! field.renameField(newDynamicFieldName); */
   virtual void renameField() {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Used to inspect an object's FieldDictionary (dynamic fields) instead of regular persistent fields.

Editor use only.

 */
class  GuiInspectorDynamicGroup : public GuiInspectorGroup {
  public:
   /*! Refreshes the dynamic fields in the inspector. */
   virtual bool inspectGroup() {}
   /*! obj.addDynamicField(); */
   virtual void addDynamicField() {}
   virtual void removeDynamicField() {}

   /*! @name Rollout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI dedicated to variable viewing/manipulation

Mostly used in console system, internal use only.

 */
class  GuiVariableInspector : public GuiInspector {
  public:
   /*! loadVars( searchString ) */
   virtual void loadVars() {}

   /*! @name Inspector
   @{ */
   /*! */
   /// @}


   /*! @name Stacking
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief This is a control that will render a specified bitmap or a bitmap specified in a referenced variable.

This control allows you to either set a bitmap with the "bitmap" field or with the setBitmap method.  You can also choose to reference a variable in the "variable" field such as "$image" and then set "useVariable" to true.  This will cause it to synchronize the variable with the bitmap displayed (if the variable holds a valid image).  You can then change the variable and effectively changed the displayed image.

@tsexample
$image = "anotherbackground.png";
new GuiChunkedBitmapCtrl(ChunkedBitmap)
{
   bitmap = "background.png";
   variable = "$image";
   useVariable = false;
}

// This will result in the control rendering "background.png"
// If we now set the useVariable to true it will now render "anotherbackground.png"
ChunkedBitmap.useVariable = true;
@endtsexample

@see GuiControl::variable

@ingroup GuiImages
 */
class  GuiChunkedBitmapCtrl : public GuiControl {
  public:
   /*! @brief Set the image rendered in this control.

@param filename The image name you want to set
@tsexample
ChunkedBitmap.setBitmap("images/background.png");@endtsexample

 */
   virtual void setBitmap(( string filename )) {}

   /*! @name GuiChunkedBitmapCtrl
   @{ */
   /*! */
   /*!
   This is the bitmap to render to the control.
   
    */
   filename bitmap;
   /*!
   This decides whether to use the "bitmap" file or a bitmap stored in "variable"
   
    */
   bool useVariable;
   /*!
   This is no longer in use
   
    */
   bool tile;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A GUI control which renders a black square over a bitmap image. The black square will fade out, then fade back in after a determined time.
This control is especially useful for transitions and splash screens.

@tsexample
new GuiFadeinBitmapCtrl()
^{
^^fadeinTime = "1000";
^^waitTime = "2000";
^^fadeoutTime = "1000";
^^done = "1";
^^// Additional GUI properties that are not specific to GuiFadeinBitmapCtrl have been omitted from this example.
^};
@endtsexample

@see GuiBitmapCtrl

@ingroup GuiCore
 */
class  GuiFadeinBitmapCtrl : public GuiBitmapCtrl {
  public:
      /*! @brief Informs the script level that this object received a Click event from the cursor or keyboard.

@tsexample
GuiFadeInBitmapCtrl::click(%this)
^{
^^// Code to run when click occurs
^}
@endtsexample

@see GuiCore

 */
      void click();

      /*! @brief Informs the script level that this object has completed is fade cycle.

@tsexample
GuiFadeInBitmapCtrl::onDone(%this)
^{
^^// Code to run when the fade cycle completes
^}
@endtsexample

@see GuiCore

 */
      void onDone();


   /*! @name Fading
   @{ */
   /*! */
   /*!
   Color to fade in from and fade out to.
   
    */
   ColorF fadeColor;
   /*!
   Milliseconds for the bitmap to fade in.
   
    */
   int fadeInTime;
   /*!
   Milliseconds to wait after fading in before fading out the bitmap.
   
    */
   int waitTime;
   /*!
   Milliseconds for the bitmap to fade out.
   
    */
   int fadeOutTime;
   /*!
   Easing curve for fade-in.
   
    */
   EaseF fadeInEase;
   /*!
   Easing curve for fade-out.
   
    */
   EaseF fadeOutEase;
   /*!
   Whether the fade cycle has finished running.
   
    */
   bool done;
   /// @}


   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief GUI that will fade the current view in and out.

Main difference between this and FadeinBitmap is this appears to fade based on the source texture.

This is going to be deprecated, and any useful code ported to FadeinBitmap

 */
class  GuiIdleCamFadeBitmapCtrl : public GuiBitmapCtrl {
  public:
   /*! @internal */
   virtual void fadeIn(()) {}
   /*! @internal */
   virtual void fadeOut(()) {}
   /*!
    */
   int fadeInTime;
   /*!
    */
   int fadeOutTime;
   /*!
    */
   bool done;

   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A chat HUD control that displays messages from a MessageVector.

This renders messages from a MessageVector; the important thing here is that the MessageVector holds all the messages we care about, while we can destroy and create these GUI controls as needed.

@tsexample
// Declare ChatHud, which is what will display the actual chat from a MessageVector
new GuiMessageVectorCtrl(ChatHud) {
   profile = "ChatHudMessageProfile";
   horizSizing = "width";
   vertSizing = "height";
   position = "1 1";
   extent = "252 16";
   minExtent = "8 8";
   visible = "1";
   helpTag = "0";
   lineSpacing = "0";
   lineContinuedIndex = "10";
   matchColor = "0 0 255 255";
   maxColorIndex = "5";
};

// All messages are stored in this HudMessageVector, the actual
// MainChatHud only displays the contents of this vector.
new MessageVector(HudMessageVector);

// Attach the MessageVector to the chat control
chatHud.attach(HudMessageVector);
@endtsexample

@see MessageVector for more details on how this is used
@ingroup GuiUtil
 */
class  GuiMessageVectorCtrl : public GuiControl {
  public:
   /*! @brief Push a line onto the back of the list.

@param item The GUI element being pushed into the control

@tsexample
// All messages are stored in this HudMessageVector, the actual
// MainChatHud only displays the contents of this vector.
new MessageVector(HudMessageVector);

// Attach the MessageVector to the chat control
chatHud.attach(HudMessageVector);
@endtsexample

@return Value */
   virtual bool attach(( MessageVector item )) {}
   /*! @brief Stop listing messages from the MessageVector previously attached to, if any.

Detailed description

@param param Description

@tsexample
// Deatch the MessageVector from HudMessageVector
// HudMessageVector will no longer render the text
chatHud.detach();
@endtsexample

 */
   virtual void detach(()) {}
   /*!
    */
   int lineSpacing;
   /*!
    */
   int lineContinuedIndex;
   /*!
    */
   string allowedMatches;
   /*!
    */
   ColorI matchColor;
   /*!
    */
   int maxColorIndex;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A horizontal progress bar rendered from a repeating image.

This class is used give progress feedback to the user.  Unlike GuiProgressCtrl which simply renders a filled rectangle, GuiProgressBitmapCtrl renders the bar using a bitmap.

This bitmap can either be simple, plain image which is then stretched into the current extents of the bar as it fills up or it can be a bitmap array with three entries.  In the case of a bitmap array, the first entry in the array is used to render the left cap of the bar and the third entry in the array is used to render the right cap of the bar.  The second entry is streched in-between the two caps.

@tsexample
// This example shows one way to break down a long-running computation into phases
// and incrementally update a progress bar between the phases.

new GuiProgressBitmapCtrl( Progress )
{
   bitmap = "core/art/gui/images/loading";
   extent = "300 50";
   position = "100 100";
};

// Put the control on the canvas.
%wrapper = new GuiControl();
%wrapper.addObject( Progress );
Canvas.pushDialog( %wrapper );

// Start the computation.
schedule( 1, 0, "phase1" );

function phase1()
{
   Progress.setValue( 0 );

   // Perform some computation.
   //...

   // Update progress.
   Progress.setValue( 0.25 );

   // Schedule next phase.  Don't call directly so engine gets a change to run refresh.
   schedule( 1, 0, "phase2" );
}

function phase2()
{
   // Perform some computation.
   //...

   // Update progress.
   Progress.setValue( 0.7 );

   // Schedule next phase.  Don't call directly so engine gets a change to run refresh.
   schedule( 1, 0, "phase3" );
}

function phase3()
{
   // Perform some computation.
   //...

   // Update progress.
   Progress.setValue( 0.9 );

   // Schedule next phase.  Don't call directly so engine gets a change to run refresh.
   schedule( 1, 0, "phase4" );
}

function phase4()
{
   // Perform some computation.
   //...

   // Final update of progress.
   Progress.setValue( 1.0 );
}
@endtsexample

@see GuiProgressCtrl

 */
class  GuiProgressBitmapCtrl : public GuiTextCtrl {
  public:
   /*! Set the bitmap to use for rendering the progress bar.

@param filename ~Path to the bitmap file.

@note Directly assign to #bitmap rather than using this method.

@see GuiProgressBitmapCtrl::setBitmap */
   virtual void setBitmap(( string filename )) {}
   /*!
   ~Path to the bitmap file to use for rendering the progress bar.

If the profile assigned to the control already has a bitmap assigned, this property need not be set in which case the bitmap from the profile is used.
   
    */
   filename bitmap;

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Used to overlaps a 'hot region' where you want to catch inputs with and have specific events occur based on individual callbacks.

Mouse event callbacks supported by this control are: onMouseUp, onMouseDown, onMouseMove, onMouseDragged, onMouseEnter, onMouseLeave,
onRightMouseDown, onRightMouseUp and onRightMouseDragged.

@tsexample
new GuiMouseEventCtrl()
{
^lockMouse = "0";
^//Properties not specific to this control have been omitted from this example.
};
@endtsexample

@see GuiControl

@ingroup GuiCore
 */
class  GuiMouseEventCtrl : public GuiControl {
  public:
      /*! @brief Callback that occurs whenever the mouse is pressed down while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was pressed down in this control, causing the callback
GuiMouseEventCtrl::onMouseDown(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseDown( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse is released while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was released in this control, causing the callback
GuiMouseEventCtrl::onMouseUp(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseUp( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse is moved (without dragging) while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was moved in this control, causing the callback
GuiMouseEventCtrl::onMouseMove(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseMove( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse is dragged while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was dragged in this control, causing the callback
GuiMouseEventCtrl::onMouseDragged(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseDragged( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse enters this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse entered this control, causing the callback
GuiMouseEventCtrl::onMouseEnter(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseEnter( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse leaves this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse left this control, causing the callback
GuiMouseEventCtrl::onMouseLeave(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onMouseLeave( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the right mouse button is pressed while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was pressed in this control, causing the callback
GuiMouseEventCtrl::onRightMouseDown(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onRightMouseDown( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the right mouse button is released while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was released in this control, causing the callback
GuiMouseEventCtrl::onRightMouseUp(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onRightMouseUp( U8 modifier, Point2I mousePoint, U8 mouseClickCount );

      /*! @brief Callback that occurs whenever the mouse is dragged in this control while the right mouse button is pressed.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was dragged in this control, causing the callback
GuiMouseEventCtrl::onRightMouseDragged(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl

 */
      void onRightMouseDragged( U8 modifier, Point2I mousePoint, U8 mouseClickCount );


   /*! @name Input
   @{ */
   /*! */
   /*!
   Whether the control should lock the mouse between up and down button events.
   
    */
   bool lockMouse;
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A control that locks the mouse and reports all keyboard input events to script.

This is useful for implementing custom keyboard handling code, and most commonly used in Torque for a menu that allows a user to remap their in-game controls

 @tsexample
new GuiInputCtrl(OptRemapInputCtrl)
{
^lockMouse = "0";
^position = "0 0";
^extent = "64 64";
^minExtent = "8 8";
^horizSizing = "center";
^vertSizing = "bottom";
^profile = "GuiInputCtrlProfile";
^visible = "1";
^active = "1";
^tooltipProfile = "GuiToolTipProfile";
^hovertime = "1000";
^isContainer = "0";
^canSave = "1";
^canSaveDynamicFields = "0";
};
@endtsexample

@see GuiMouseEventCtrl
@ingroup GuiUtil
 */
class  GuiInputCtrl : public GuiMouseEventCtrl {
  public:
      /*! @brief Callback that occurs when an input is triggered on this control

@param device The device type triggering the input, such as keyboard, mouse, etc
@param action The actual event occuring, such as a key or button
@param state True if the action is being pressed, false if it is being release

 */
      void onInputEvent( string device, string action, bool state );


   /*! @name Input
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Store a list of chat messages.

This is responsible for managing messages which appear in the chat HUD, not the actual control rendered to the screen

@tsexample
// Declare ChatHud, which is what will display the actual chat from a MessageVector
new GuiMessageVectorCtrl(ChatHud) {
   profile = "ChatHudMessageProfile";
   horizSizing = "width";
   vertSizing = "height";
   position = "1 1";
   extent = "252 16";
   minExtent = "8 8";
   visible = "1";
   helpTag = "0";
   lineSpacing = "0";
   lineContinuedIndex = "10";
   matchColor = "0 0 255 255";
   maxColorIndex = "5";
};

// All messages are stored in this HudMessageVector, the actual
// MainChatHud only displays the contents of this vector.
new MessageVector(HudMessageVector);

// Attach the MessageVector to the chat control
chatHud.attach(HudMessageVector);
@endtsexample

@see GuiMessageVectorCtrl for more details on how this is used.@ingroup GuiUtil
 */
class  MessageVector : public SimObject {
  public:
   /*! Clear all messages in the vector

@tsexample
HudMessageVector.clear();
@endtsexample

 */
   virtual void clear(()) {}
   /*! Push a line onto the back of the list.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.pushBackLine("Hello World", 0);
@endtsexample

 */
   virtual void pushBackLine(( string msg, int tag )) {}
   /*! Pop a line from the back of the list; destroys the line.

@tsexample
HudMessageVector.popBackLine();
@endtsexample

@return False if there are no lines to pop (underflow), true otherwise */
   virtual bool popBackLine(()) {}
   /*! Push a line onto the front of the vector.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.pushFrontLine("Hello World", 0);
@endtsexample

 */
   virtual void pushFrontLine(( string msg, int tag )) {}
   /*! Pop a line from the front of the vector, destroying the line.

@tsexample
HudMessageVector.popFrontLine();
@endtsexample

@return False if there are no lines to pop (underflow), true otherwise */
   virtual bool popFrontLine(()) {}
   /*! Push a line onto the back of the list.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.insertLine(1, "Hello World", 0);
@endtsexample

@return False if insertPos is greater than the number of lines in the current vector */
   virtual bool insertLine(( int insertPos, string msg, int tag )) {}
   /*! Delete the line at the specified position.

@param deletePos Position in the vector containing the line to be deleted
@tsexample
// Delete the first line (index 0) in the vector...
HudMessageVector.deleteLine(0);
@endtsexample

@return False if deletePos is greater than the number of lines in the current vector */
   virtual bool deleteLine(( int deletePos )) {}
   /*! Dump the message vector to a file, optionally prefixing a header.@hide */
   virtual void dump((string filename, string header=NULL)) {}
   /*! Get the number of lines in the vector.

@tsexample
// Find out how many lines have been stored in HudMessageVector
%chatLines = HudMessageVector.getNumLines();
echo(%chatLines);
@endtsexample

 */
   virtual int getNumLines(()) {}
   /*! Scan through the lines in the vector, returning the first line that has a matching tag.

@param tag Numerical value assigned to a message when it was added or inserted
@tsexample
// Locate text in the vector tagged with the value "1", then print it
%taggedText = HudMessageVector.getLineTextByTag(1);
echo(%taggedText);
@endtsexample

@return Text from a line with matching tag, other wise "" */
   virtual string getLineTextByTag(( int tag )) {}
   /*! Scan through the vector, returning the line number of the first line that matches the specified tag; else returns -1 if no match was found.

@param tag Numerical value assigned to a message when it was added or inserted
@tsexample
// Locate a line of text tagged with the value "1", then delete it.
%taggedLine = HudMessageVector.getLineIndexByTag(1);
HudMessageVector.deleteLine(%taggedLine);
@endtsexample

@return Line with matching tag, other wise -1 */
   virtual int getLineIndexByTag(( int tag )) {}
   /*! Get the text at a specified line.

@param pos Position in vector to grab text from
@tsexample
// Print a line of text at position 1.
%text = HudMessageVector.getLineText(1);
echo(%text);
@endtsexample

@return Text at specified line, if the position is greater than the number of lines return "" */
   virtual string getLineText(( int pos )) {}
   /*! Get the tag of a specified line.

@param pos Position in vector to grab tag from
@tsexample
// Remove all lines that do not have a tag value of 1.
while( HudMessageVector.getNumLines())
{
   %tag = HudMessageVector.getLineTag(1);
   if(%tag != 1)
      %tag.delete();
   HudMessageVector.popFrontLine();
}
@endtsexample

@return Tag value of a given line, if the position is greater than the number of lines return 0 */
   virtual int getLineTag(( int pos )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Creator tree from old editor.  Not used in current editor.

 */
class  CreatorTree : public GuiArrayCtrl {
  public:
   virtual int addGroup((string group, string name, string value)) {}
   virtual int addItem((Node group, string name, string value)) {}
   virtual bool fileNameMatch((string world, string type, string filename)) {}
   /*! Return a handle to the currently selected item. */
   virtual int getSelected() {}
   virtual bool isGroup((Group g)) {}
   virtual string getName((Node item)) {}
   virtual string getValue((Node n)) {}
   /*! Clear the tree. */
   virtual void clear() {}
   virtual int getParent((Node n)) {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief For Editor use only, deprecated

 */
class  EditManager : public GuiControl {
  public:
   virtual void setBookmark((int slot)) {}
   virtual void gotoBookmark((int slot)) {}
   /*! Perform the onEditorEnabled callback on all SimObjects and set gEditingMission true */
   virtual void editorEnabled() {}
   /*! Perform the onEditorDisabled callback on all SimObjects and set gEditingMission false */
   virtual void editorDisabled() {}
   /*! Return the value of gEditingMission. */
   virtual bool isEditorEnabled() {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  EditorIconRegistry {
  public:
   /*! @internal */
   virtual void add(( String className, String imageFile [, bool overwrite = true] )) {}
   /*! @internal */
   virtual void loadFromPath(( String imagePath [, bool overwrite = true] )) {}
   /*! @internal */
   virtual void clear() {}
   /*! Returns the file path to the icon file if found.@internal */
   virtual string findIconByClassName(( String className )) {}
   /*! Returns the file path to the icon file if found.@internal */
   virtual string findIconBySimObject(( SimObject )) {}
};

/*!
@brief The base class for the sketch tool

Editor use only.

 */
class  GuiConvexEditorCtrl : public EditTSCtrl {
  public:
   virtual void hollowSelection() {}
   virtual void recenterSelection() {}
   virtual int hasSelection() {}
   virtual void handleDelete() {}
   virtual void handleDeselect() {}
   virtual void dropSelectionAtScreenCenter() {}
   virtual void selectConvex(( ConvexShape )) {}
   virtual void splitSelectedFace() {}
   /*!
    */
   bool isDirty;
   /*!
    */
   string materialName;

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The base class for the Decal Editor tool

Editor use only.

 */
class  GuiDecalEditorCtrl : public EditTSCtrl {
  public:
   /*! deleteSelectedDecal() */
   virtual void deleteSelectedDecal() {}
   /*! deleteSelectedDecalDatablock( String datablock ) */
   virtual void deleteDecalDatablock() {}
   /*! setMode( String mode )() */
   virtual void setMode() {}
   /*! getMode() */
   virtual string getMode() {}
   /*! getDecalCount() */
   virtual int getDecalCount() {}
   /*! getDecalTransform() */
   virtual string getDecalTransform() {}
   /*! getDecalLookupName( S32 )() */
   virtual string getDecalLookupName() {}
   /*! selectDecal( S32 )() */
   virtual void selectDecal() {}
   /*! editDecalDetails( S32 )() */
   virtual void editDecalDetails() {}
   virtual int getSelectionCount() {}
   virtual void retargetDecalDatablock() {}
   /*!
    */
   DecalData currentDecalData;

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Visual representation of Mission Area Editor.

 */
class  GuiMissionAreaCtrl : public GuiBitmapCtrl {
  public:
   /*! @brief Set the MissionArea to edit.

 */
   virtual void setMissionArea(( MissionArea area )) {}
   /*! @brief Update the terrain bitmap.

 */
   virtual void updateTerrain(()) {}
   /*!
    */
   bool squareBitmap;
   /*!
   Bitmap file for the mission area handles.

   
    */
   filename handleBitmap;
   /*!
    */
   ColorI missionBoundsColor;
   /*!
    */
   ColorI cameraColor;

   /*! @name Bitmap
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Specialized GUI used for editing the MissionArea in a level

Editor use only.

 */
class  GuiMissionAreaEditorCtrl : public EditTSCtrl {
  public:
   virtual void setSelectedMissionArea() {}
   virtual string getSelectedMissionArea() {}

   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Very old GUI used for terrain preview

Deprecated

 */
class  GuiTerrPreviewCtrl : public GuiControl {
  public:
   /*! Reset the view of the terrain. */
   virtual void reset() {}
   /*! Add the origin to the root and reset the origin. */
   virtual void setRoot() {}
   /*! Return a Point2F representing the position of the root. */
   virtual string getRoot() {}
   /*! Set the origin of the view. */
   virtual void setOrigin((float x, float y)) {}
   /*! Return a Point2F containing the position of the origin. */
   virtual string getOrigin() {}
   /*! Returns a 4-tuple containing: root_x root_y origin_x origin_y */
   virtual string getValue() {}
   /*! Accepts a 4-tuple in the same form as getValue returns.

@see GuiTerrPreviewCtrl::getValue() */
   virtual void setValue() {}

   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Terrain action used for leveling varying terrain heights smoothly.

Editor use only.

 */
class  TerrainSmoothAction : public UndoAction {
  public:
   virtual void smooth(( TerrainBlock obj, F32 factor, U32 steps )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The base Terrain Editor tool

Editor use only.

 */
class  TerrainEditor : public EditTSCtrl {
  public:
   virtual void attachTerrain((TerrainBlock terrain)) {}
   virtual int getTerrainBlockCount(()) {}
   virtual int getTerrainBlock((S32 index)) {}
   /*! gets the list of current terrain materials for all terrain blocks. */
   virtual string getTerrainBlocksMaterialList(()) {}
   /*! One of box, ellipse, selection. */
   virtual void setBrushType((string type)) {}
   virtual string getBrushType(()) {}
   virtual void setBrushSize((int w [, int h])) {}
   virtual string getBrushSize(()) {}
   virtual void setBrushPressure((float pressure)) {}
   virtual float getBrushPressure(()) {}
   virtual void setBrushSoftness((float softness)) {}
   virtual float getBrushSoftness(()) {}
   /*! Returns a Point2I. */
   virtual string getBrushPos() {}
   virtual void setBrushPos((int x, int y)) {}
   virtual void setAction((string action_name)) {}
   virtual string getActionName((int num)) {}
   virtual int getNumActions() {}
   virtual string getCurrentAction() {}
   virtual void resetSelWeights((bool clear)) {}
   virtual void clearSelection() {}
   virtual void processAction((string action=NULL)) {}
   virtual int getActiveTerrain() {}
   virtual int getNumTextures() {}
   virtual void markEmptySquares() {}
   virtual void mirrorTerrain() {}
   /*! sets the terraformer current heightmap to draw as an overlay over the current terrain. */
   virtual void setTerraformOverlay((bool overlayEnable)) {}
   /*! Changes the material name at the index. */
   virtual bool updateMaterial(( int index, string matName )) {}
   /*! Adds a new material. */
   virtual int addMaterial(( string matName )) {}
   /*! Remove the material at the given index. */
   virtual void removeMaterial(( int index )) {}
   /*! Returns the current material count. */
   virtual int getMaterialCount() {}
   /*! gets the list of current terrain materials. */
   virtual string getMaterials(()) {}
   /*! Returns the name of the material at the given index. */
   virtual string getMaterialName(( int index )) {}
   /*! Returns the index of the material with the given name or -1. */
   virtual int getMaterialIndex(( string name )) {}
   /*! Reorder material at the given index to the new position, changing the order in which it is rendered / blended. */
   virtual void reorderMaterial(( int index, int order )) {}
   /*! Gets the terrain block that is located under the given world point.
@param x/y/z The world coordinates (floating point values) you wish to query at. These can be formatted as either a string ("x y z") or separately as (x, y, z)
@return Returns the ID of the requested terrain block (0 if not found).

 */
   virtual int getTerrainUnderWorldPoint((x/y/z)) {}
   virtual float getSlopeLimitMinAngle() {}
   virtual float setSlopeLimitMinAngle() {}
   virtual float getSlopeLimitMaxAngle() {}
   virtual float setSlopeLimitMaxAngle() {}
   virtual void autoMaterialLayer((float minHeight, float maxHeight, float minSlope, float maxSlope)) {}

   /*! @name Misc
   @{ */
   /*! */
   /*!
    */
   bool isDirty;
   /*!
    */
   bool isMissionDirty;
   /*!
    */
   bool renderBorder;
   /*!
    */
   float borderHeight;
   /*!
    */
   ColorI borderFillColor;
   /*!
    */
   ColorI borderFrameColor;
   /*!
    */
   bool borderLineMode;
   /*!
    */
   bool selectionHidden;
   /*!
    */
   bool renderVertexSelection;
   /*!
    */
   bool renderSolidBrush;
   /*!
    */
   bool processUsesBrush;
   /*!
    */
   Point2I maxBrushSize;
   /*!
    */
   float adjustHeightVal;
   /*!
    */
   float setHeightVal;
   /*!
    */
   float scaleVal;
   /*!
    */
   float smoothFactor;
   /*!
    */
   float noiseFactor;
   /*!
    */
   int materialGroup;
   /*!
    */
   float softSelectRadius;
   /*!
    */
   string softSelectFilter;
   /*!
    */
   string softSelectDefaultFilter;
   /*!
    */
   float adjustHeightMouseScale;
   /*!
    */
   int paintIndex;
   /// @}


   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Material Editor create undo instance

Not intended for game development, for editors or internal use only.

 */
class  MECreateUndoAction : public UndoAction {
  public:
   virtual void addObject(( SimObject obj )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Material Editor delete undo instance

Not intended for game development, for editors or internal use only.

 */
class  MEDeleteUndoAction : public UndoAction {
  public:
   virtual void deleteObject(( SimObject obj )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief The main World Editor tool class

Editor use only.

 */
class  WorldEditor : public EditTSCtrl {
  public:
   virtual void ignoreObjClass((string class_name, ...)) {}
   virtual void clearIgnoreList() {}
   virtual void clearSelection() {}
   /*! Return the currently active WorldEditorSelection object. */
   virtual int getActiveSelection(()) {}
   /*! Set the currently active WorldEditorSelection object. */
   virtual void setActiveSelection(( id set )) {}
   virtual void selectObject((SimObject obj)) {}
   virtual void unselectObject((SimObject obj)) {}
   virtual void invalidateSelectionCentroid() {}
   /*! Return the number of objects currently selected in the editor. */
   virtual int getSelectionSize(()) {}
   virtual int getSelectedObject((int index)) {}
   virtual float getSelectionRadius() {}
   virtual string getSelectionCentroid() {}
   virtual string getSelectionExtent() {}
   virtual void dropSelection(( bool skipUndo = false )) {}
   virtual void cutSelection() {}
   virtual void copySelection() {}
   virtual void pasteSelection() {}
   virtual bool canPasteSelection() {}
   virtual void hideObject((Object obj, bool hide)) {}
   virtual void hideSelection((bool hide)) {}
   virtual void lockSelection((bool lock)) {}
   /*! Align all selected objects against the given bounds axis. */
   virtual void alignByBounds((int boundsAxis)) {}
   /*! Align all selected objects along the given axis. */
   virtual void alignByAxis((int axis)) {}
   virtual void resetSelectedRotation() {}
   virtual void resetSelectedScale() {}
   virtual void redirectConsole(( int objID )) {}
   virtual void addUndoState() {}
   /*! getSoftSnap()
Is soft snapping always on? */
   virtual bool getSoftSnap() {}
   /*! setSoftSnap(bool)
Allow soft snapping all of the time. */
   virtual void setSoftSnap() {}
   /*! getSoftSnapSize()
Get the absolute size to trigger a soft snap. */
   virtual float getSoftSnapSize() {}
   /*! setSoftSnapSize(F32)
Set the absolute size to trigger a soft snap. */
   virtual void setSoftSnapSize() {}
   /*! Get the soft snap alignment. */
   virtual string getSoftSnapAlignment(()) {}
   /*! Set the soft snap alignment. */
   virtual void setSoftSnapAlignment(( WorldEditor::AlignmentType type )) {}
   /*! softSnapSizeByBounds(bool)
Use selection bounds size as soft snap bounds. */
   virtual void softSnapSizeByBounds() {}
   /*! getSoftSnapBackfaceTolerance()
The fraction of the soft snap radius that backfaces may be included. */
   virtual float getSoftSnapBackfaceTolerance() {}
   /*! setSoftSnapBackfaceTolerance(F32 with range of 0..1)
The fraction of the soft snap radius that backfaces may be included. */
   virtual void setSoftSnapBackfaceTolerance() {}
   /*! softSnapRender(bool)
Render the soft snapping bounds. */
   virtual void softSnapRender() {}
   /*! softSnapRenderTriangle(bool)
Render the soft snapped triangle. */
   virtual void softSnapRenderTriangle() {}
   /*! softSnapDebugRender(bool)
Toggle soft snapping debug rendering. */
   virtual void softSnapDebugRender() {}
   /*! Get the terrain snap alignment.  */
   virtual string getTerrainSnapAlignment(()) {}
   /*! Set the terrain snap alignment. */
   virtual void setTerrainSnapAlignment(( WorldEditor::AlignmentType alignment )) {}
   /*! transformSelection(...)
Transform selection by given parameters. */
   virtual void transformSelection() {}
   /*! Export the combined geometry of all selected objects to the specified path in collada format. */
   virtual void colladaExportSelection(( String path )) {}
   /*! Save selected objects to a .prefab file and replace them in the level with a Prefab object. */
   virtual void makeSelectionPrefab(( string filename )) {}
   /*! Replace selected Prefab objects with a SimGroup containing all children objects defined in the .prefab. */
   virtual void explodeSelectedPrefab(()) {}
   virtual void mountRelative(( Object A, Object B )) {}
   /*! Grab the geometry from @a geometryProvider, create a @a className object, and assign it the extracted geometry. */
   virtual string createPolyhedralObject(( string className, SceneObject geometryProvider )) {}
   /*! Create a ConvexShape from the given polyhedral object. */
   virtual string createConvexShapeFrom(( SceneObject polyObject )) {}
   virtual void clearAllSelections() {}
   virtual string getMode() {}
   /*! Get the number of static fields on the object.
@return The number of static fields defined on the object. */
   virtual void setMode(( String mode )) {}

   /*! @name Grid
   @{ */
   /*! */
   /*!
   If true, transform operations will snap to the grid.
   
    */
   bool gridSnap;
   /// @}


   /*! @name Dropping
   @{ */
   /*! */
   /*!
    */
   bool dropAtBounds;
   /*!
    */
   float dropBelowCameraOffset;
   /*!
    */
   float dropAtScreenCenterScalar;
   /*!
    */
   float dropAtScreenCenterMax;
   /*!
    */
   WorldEditorDropType dropType;
   /// @}


   /*! @name Colors
   @{ */
   /*! */
   /*!
    */
   ColorI popupBackgroundColor;
   /*!
    */
   ColorI popupTextColor;
   /*!
    */
   ColorI objectTextColor;
   /*!
    */
   ColorI selectionBoxColor;
   /*!
    */
   ColorI objSelectColor;
   /*!
    */
   ColorI objMouseOverSelectColor;
   /*!
    */
   ColorI objMouseOverColor;
   /*!
    */
   ColorI dragRectColor;
   /*!
    */
   ColorI faceSelectColor;
   /// @}


   /*! @name Selections
   @{ */
   /*! */
   /*!
    */
   bool boundingBoxCollision;
   /*!
    */
   bool objectMeshCollision;
   /*!
    */
   bool selectionLocked;
   /*!
   
   
    */
   bool objectsUseBoxCenter;
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /*!
    */
   string objTextFormat;
   /*!
    */
   bool renderPopupBackground;
   /*!
    */
   bool showMousePopupInfo;
   /*!
    */
   bool renderObjText;
   /*!
    */
   bool renderObjHandle;
   /*!
    */
   bool renderSelectionBox;
   /*!
    */
   filename selectHandle;
   /*!
    */
   filename defaultHandle;
   /*!
    */
   filename lockedHandle;
   /// @}


   /*! @name Rendering: Icons
   @{ */
   /*! */
   /*!
   Whether object icons should fade out with distance to camera pos.
   
    */
   bool fadeIcons;
   /*!
   Distance from camera pos at which to start fading out icons.
   
    */
   float fadeIconsDist;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
    */
   bool isDirty;
   /*!
    */
   bool stickToGround;
   /*!
    */
   bool toggleIgnoreList;
   /// @}


   /*! @name Grid
   @{ */
   /*! */
   /// @}


   /*! @name Mission Area
   @{ */
   /*! */
   /// @}


   /*! @name BorderMovement
   @{ */
   /*! */
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /// @}


   /*! @name Camera
   @{ */
   /*! */
   /// @}


   /*! @name Rendering
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Layout
   @{ */
   /*! */
   /// @}


   /*! @name Control
   @{ */
   /*! */
   /// @}


   /*! @name ToolTip
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Localization
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Specialized simset that stores the objects selected by the World Editor

Editor use only.

 */
class  WorldEditorSelection : public SimPersistSet {
  public:
   /*! True if an object with global bounds is contained in the selection. */
   virtual bool containsGlobalBounds(()) {}
   /*! Return the median of all object positions in the selection. */
   virtual string getCentroid(()) {}
   /*! Return the center of the bounding box around the selection. */
   virtual string getBoxCentroid(()) {}
   /*! Move all objects in the selection by the given delta. */
   virtual void offset(( vector delta, float gridSnap=0 )) {}
   /*! Add all objects in the given set to this selection. */
   virtual void union(( SimSet set )) {}
   /*! Remove all objects in the given set from this selection. */
   virtual void subtract(( SimSet )) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Provides the code necessary to handle the low level management of the string tables for localization

One LangTable is created for each mod, as well as one for the C++ code. LangTable is responsible for obtaining the correct strings from each and relaying it to the appropriate controls.

@see Localization for a full description

@ingroup Localization
 */
class  LangTable : public SimObject {
  public:
   /*! @brief Adds a language to the table

@param filename Name and path to the language file
@param languageName Optional name to assign to the new language entry

@return True If file was successfully found and language created
 */
   virtual int addLanguage((string filename, [string languageName])) {}
   /*! @brief Grabs a string from the specified table

If an invalid is passed, the function will attempt to to grab from the default table

@param filename Name of the language table to access

@return Text from the specified language table, "" if ID was invalid and default table is not set */
   virtual string getString((string filename)) {}
   /*! @brief Sets the default language table

@param language ID of the table
 */
   virtual void setDefaultLanguage((int language)) {}
   /*! @brief Sets the current language table for grabbing text

@param language ID of the table
 */
   virtual void setCurrentLanguage((int language)) {}
   /*! @brief Get the ID of the current language table

@return Numerical ID of the current language table */
   virtual int getCurrentLanguage(()) {}
   /*! @brief Return the readable name of the language table

@param language Numerical ID of the language table to access

@return String containing the name of the table, NULL if ID was invalid or name was never specified */
   virtual string getLangName((int language)) {}
   /*! @brief Used to find out how many languages are in the table

@return Size of the vector containing the languages, numerical */
   virtual int getNumLang(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Special type of data block that stores information about a handwritten shader.

To use hand written shaders, a ShaderData datablock must be used. This datablock refers only to the vertex and pixel shader filenames and a hardware target level. Shaders are API specific, so DirectX and OpenGL shaders must be explicitly identified.

 @tsexample
// Used for the procedural clould system
singleton ShaderData( CloudLayerShader )
{
^DXVertexShaderFile   = "shaders/common/cloudLayerV.hlsl";
^DXPixelShaderFile    = "shaders/common/cloudLayerP.hlsl";
^OGLVertexShaderFile = "shaders/common/gl/cloudLayerV.glsl";
^OGLPixelShaderFile = "shaders/common/gl/cloudLayerP.glsl";
^pixVersion = 2.0;
};
@endtsexample

@ingroup Shaders
 */
class  ShaderData : public SimObject {
  public:
   /*! @brief Rebuilds all the vertex and pixel shader instances created from this ShaderData.

@tsexample
// Rebuild the shader instances from ShaderData CloudLayerShader
CloudLayerShader.reload();
@endtsexample

 */
   virtual void reload(()) {}
   /*!
   @brief %Path to the DirectX vertex shader file to use for this ShaderData.

It must contain only one program and no pixel shader, just the vertex shader.It can be either an HLSL or assembly level shader. HLSL's must have a filename extension of .hlsl, otherwise its assumed to be an assembly file.
   
    */
   filename DXVertexShaderFile;
   /*!
   @brief %Path to the DirectX pixel shader file to use for this ShaderData.

It must contain only one program and no vertex shader, just the pixel shader. It can be either an HLSL or assembly level shader. HLSL's must have a filename extension of .hlsl, otherwise its assumed to be an assembly file.
   
    */
   filename DXPixelShaderFile;
   /*!
   @brief %Path to an OpenGL vertex shader file to use for this ShaderData.

It must contain only one program and no pixel shader, just the vertex shader.
   
    */
   filename OGLVertexShaderFile;
   /*!
   @brief %Path to an OpenGL pixel shader file to use for this ShaderData.

It must contain only one program and no vertex shader, just the pixel shader.
   
    */
   filename OGLPixelShaderFile;
   /*!
   @brief If true, the maximum pixel shader version offered by the graphics card will be used.

Otherwise, the script-defined pixel shader version will be used.


   
    */
   bool useDevicePixVersion;
   /*!
   @brief Indicates target level the shader should be compiled.

Valid numbers at the time of this writing are 1.1, 1.4, 2.0, and 3.0. The shader will not run properly if the hardware does not support the level of shader compiled.
   
    */
   float pixVersion;
   /*!
   @brief String of case-sensitive defines passed to the shader compiler.

The string should be delimited by a semicolon, tab, or newline character.@tsexample
singleton ShaderData( FlashShader )
{
DXVertexShaderFile ^= "shaders/common/postFx/flashV.hlsl";
DXPixelShaderFile ^= "shaders/common/postFx/flashP.hlsl";

 //Define setting the color of WHITE_COLOR.
defines = "WHITE_COLOR=float4(1.0,1.0,1.0,0.0)";

pixVersion = 2.0
}
@endtsexample


   
    */
   string defines;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A ResponseCurve<F32> wrapped as a SimObject.

Currently no applied use, not network ready, not intended for game development, for editors or internal use only.

 */
class  SimResponseCurve : public SimObject {
  public:
   /*! addPoint( F32 value, F32 time ) */
   virtual void addPoint() {}
   /*! getValue( F32 time ) */
   virtual float getValue() {}
   /*! clear() */
   virtual void clear() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Used for rendering platform menu bars

Internal use only

 */
class  MenuBar : public SimSet {
  public:
   virtual void attachToCanvas((GuiCanvas, pos)) {}
   virtual void removeFromCanvas(()) {}
   /*! insert object at position */
   virtual void insert((object, pos)) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief PopupMenu represents a system menu.

You can add menu items to the menu, but there is no torque object associated with these menu items, they exist only in a  platform specific manner.

@note Internal use only

 */
class  PopupMenu : public SimObject {
  public:
   virtual int insertItem((pos[, title][, accelerator])) {}
   virtual void removeItem((pos)) {}
   virtual int insertSubMenu((pos, title, subMenu)) {}
   virtual bool setItem((pos, title[, accelerator])) {}
   virtual void enableItem((pos, enabled)) {}
   virtual void checkItem((pos, checked)) {}
   virtual void checkRadioItem((firstPos, lastPos, checkPos)) {}
   virtual bool isItemChecked((pos)) {}
   virtual int getItemCount(()) {}
   virtual void attachToMenuBar((GuiCanvas, pos, title)) {}
   virtual void removeFromMenuBar(()) {}
   virtual void showPopup((Canvas,[x, y])) {}
   /*!
   true if this is a pop-up/context menu. defaults to false.
   
    */
   bool isPopup;
   /*!
   the title of this menu when attached to a menu bar
   
    */
   caseString barTitle;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

class  PfxVis {
  public:
   /*! @hide */
   virtual void clear(()) {}
   /*! @hide */
   virtual void open(( PostEffect, [bool clear = false] )) {}
   /*! @hide */
   virtual void hide(()) {}
   /*! @hide */
   virtual void show(()) {}
   /*! @hide */
   virtual void onWindowClosed(( GuiWindowCtrl )) {}
};

/*!
@brief A grouping of render bin managers which forms a render pass.

The render pass is used to order a set of RenderBinManager objects which are used when rendering a scene.  This class does little work itself other than managing its list of render bins.

In 'core/scripts/client/renderManager.cs' you will find the DiffuseRenderPassManager which is used by the C++ engine to render the scene.

@see RenderBinManager
@ingroup RenderBin
 */
class  RenderPassManager : public SimObject {
  public:
   /*! Returns the total number of bin managers. */
   virtual int getManagerCount(()) {}
   /*! Returns the render bin manager at the index or null if the index is out of range. */
   virtual string getManager(( int index )) {}
   /*! Add as a render bin manager to the pass. */
   virtual void addManager(( RenderBinManager  renderBin )) {}
   /*! Removes a render bin manager. */
   virtual void removeManager(( RenderBinManager  renderBin )) {}
};

/*!
@brief A spline along which various objects can move along. The spline object acts like a container for Marker objects, which make
up the joints, or knots, along the path. Paths can be assigned a speed, can be looping or non-looping. Each of a path's markers can be
one of three primary movement types: "normal", "Position Only", or "Kink". 
@tsexample
new path()
^{
     isLooping = "1";

     new Marker()
^^{
^^^seqNum = "0";
^^^type = "Normal";
^^^msToNext = "1000";
^^^smoothingType = "Spline";
^^^position = "-0.054708 -35.0612 234.802";
^^^rotation = "1 0 0 0";
      };

^};
@endtsexample
@see Marker
@see NetConnection::transmitPaths()
@see NetConnection::clearPaths()
@see Path
@ingroup enviroMisc
 */
class  Path : public SimGroup {
  public:
   /*! @brief Returns the PathID (not the object ID) of this path.

@return PathID (not the object ID) of this path.
@tsexample
// Acquire the PathID of this path object.
%pathID = %thisPath.getPathId();

@endtsexample

 */
   virtual int getPathId(()) {}
   /*!
   If this is true, the loop is closed, otherwise it is open.

   
    */
   bool isLooping;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Playback controller for a sound source.

All sound playback is driven by SFXSources.  Each such source represents an independent playback controller that directly or indirectly affects sound output.

While this class itself is instantiable, such an instance will not by itself emit any sound.  This is the responsibility of its subclasses.  Note, however, that none of these subclasses must be instantiated directly but must instead be instantiated indirectly through the SFX interface.

@section SFXSource_playonce Play-Once Sources

Often, a sound source need only exist for the duration of the sound it is playing.  In this case so-called "play-once" sources simplify the bookkeeping involved by leaving the deletion of sources that have expired their playtime to the sound system.

Play-once sources can be created in either of two ways:
- sfxPlayOnce(): Directly create a play-once source from a SFXTrack or file.
- sfxDeleteWhenStopped(): Retroactively turn any source into a play-once source that will automatically be deleted when moving into stopped state.

@see sfxPlayOnce
@see sfxDeleteWhenStopped

@section SFXSource_hierarchies Source Hierarchies

Source are arranged into playback hierarchies where a parent source will scale some of the properties of its children and also hand on any play(), pause(), and stop() commands to them.  This allows to easily group sounds into logical units that can then be operated on as a whole.

An example of this is the segregation of sounds according to their use in the game.  Volume levels of background music, in-game sound effects, and character voices will usually be controlled independently and putting their sounds into different hierarchies allows to achieve that easily.

The source properties that are scaled by parent values are:
- volume,
- pitch, and
- priority

This means that if a parent has a volume of 0.5, the child will play at half the effective volume it would otherwise have.

Additionally, parents affect the playback state of their children:

- A parent that is in stopped state will force all its direct and indirect children into stopped state.
- A parent that is in paused state will force all its direct and indirect children that are playing into paused state.  However, children that are in stopped state will not be affected.
- A parent that is in playing state will not affect the playback state of its children.

Each source maintains a state that is wants to be in which may differ from the state that is enforced on it by its parent.  If a parent changes its states in a way that allows a child to move into its desired state, the child will do so.

For logically grouping sources, instantiate the SFXSource class directly and make other sources children to it.  A source thus instantiated will not effect any real sound output on its own but will influence the sound output of its direct and indirect children.

@note Be aware that the property values used to scale child property values are the @b effective values.  For example, the value used to scale the volume of a child is the @b effective volume of the parent, i.e. the volume after fades, distance attenuation, etc. has been applied.

@see SFXDescription::sourceGroup
@section SFXSource_volume Volume Attenuation

During its lifetime, the volume of a source will be continually updated.  This update process always progresses in a fixed set of steps to compute the final effective volume of the source based on the base volume level that was either assigned from the SFXDescription associated with the source (SFXDescription::volume) or manually set by the user.  The process of finding a source's final effective volume is called "volume attenuation".  The steps involved in attenuating a source's volume are (in order):
<dl>
<dt>Fading</dt>
<dd>If the source currently has a fade-effect applied, the volume is interpolated along the currently active fade curve.</dd>
<dt>Modulation</dt>
<dd>If the source is part of a hierarchy, it's volume is scaled according to the effective volume of its parent.</dd>
<dt>Distance Attenuation</dt>
<dd>If the source is a 3D sound source, then the volume is interpolated according to the distance model in effect and current listener position and orientation (see @ref SFX_3d).</dd>
</dl>

@see SFXDescription::volume
@see SFXDescription::is3d
@section SFXSource_fades Volume Fades

To ease-in and ease-out playback of a sound, fade effects may be applied to sources.  A fade will either go from zero volume to full effective volume (fade-in) or from full effective volume to zero volume (fade-out).

Fading is coupled to the play(), pause(), and stop() methods as well as to loop iterations when SFXDescription::fadeLoops is true for the source.  play() and the start of a loop iteration will trigger a fade-in whereas pause(), stop() and the end of loop iterations will trigger fade-outs.

For looping sources, if SFXDescription::fadeLoops is false, only the initial play() will trigger a fade-in and no further fading will be applied to loop iterations.

By default, the fade durations will be governed by the SFXDescription::fadeInTime and SFXDescription::fadeOutTime properties of the SFXDescription attached to the source.  However, these may be overridden on a per-source basis by setting fade times explicitly with setFadeTimes().  Additionally, the set values may be overridden for individual play(), pause(), and stop() calls by supplying appropriate fadeInTime/fadeOutTime parameters.

By default, volume will interpolate linearly during fades.  However, custom interpolation curves can be assigned through the SFXDescription::fadeInEase and SFXDescription::fadeOutTime properties.

@see SFXDescription::fadeInTime
@see SFXDescription::fadeOutTime
@see SFXDescription::fadeInEase
@see SFXDescription::fadeOutEase
@see SFXDescription::fadeLoops
@section SFXSource_cones Sound Cones

@see SFXDescription::coneInsideAngle
@see SFXDescription::coneOutsideAngle
@see SFXDescription::coneOutsideVolume
@section SFXSource_doppler Doppler Effect

@see sfxGetDopplerFactor
@see sfxSetDopplerFactor
@see SFXAmbience::dopplerFactor
@section SFXSource_markers Playback Markers

Playback markers allow to attach notification triggers to specific playback positions.  Once the play cursor crosses a position for which a marker is defined, the #onMarkerPassed callback will be triggered on the SFXSource thus allowing to couple script logic to .

Be aware that the precision with which marker callbacks are triggered are bound by global source update frequency.  Thus there may be a delay between the play cursor actually passing a marker position and the callback being triggered.

@ingroup SFX
 */
class  SFXSource : public SimGroup {
  public:
      /*! Called when the playback status of the source changes.
@param newStatus The new playback status. */
      void onStatusChange( SFXStatus newStatus );

      /*! Called when a parameter attached to the source changes value.
This callback will be triggered before the value change has actually been applied to the source.
@param parameter The parameter that has changed value.
@note This is also triggered when the parameter is first attached to the source. */
      void onParameterValueChange( SFXParameter parameter );

   /*! Start playback of the source.
If the sound data for the source has not yet been fully loaded, there will be a delay after calling play and playback will start after the data has become available.

@param fadeInTime Seconds for the sound to reach full volume.  If -1, the SFXDescription::fadeInTime set in the source's associated description is used.  Pass 0 to disable a fade-in effect that may be configured on the description. */
   virtual void play(( float fadeInTime=-1.f )) {}
   /*! Stop playback of the source.
@param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be configured on the description.
Be aware that if a fade-out effect is used, the source will not immediately transtion to stopped state but will rather remain in playing state until the fade-out time has expired. */
   virtual void stop(( float fadeOutTime=-1.f )) {}
   /*! Pause playback of the source.
@param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be configured on the description.
Be aware that if a fade-out effect is used, the source will not immediately to paused state but will rather remain in playing state until the fade-out time has expired.. */
   virtual void pause(( float fadeOutTime=-1.f )) {}
   /*! Test whether the source is currently playing.
@return True if the source is in playing state, false otherwise.

@see play
@see getStatus
@see SFXStatus */
   virtual bool isPlaying(()) {}
   /*! Test whether the source is currently paused.
@return True if the source is in paused state, false otherwise.

@see pause
@see getStatus
@see SFXStatus */
   virtual bool isPaused(()) {}
   /*! Test whether the source is currently stopped.
@return True if the source is in stopped state, false otherwise.

@see stop
@see getStatus
@see SFXStatus */
   virtual bool isStopped(()) {}
   /*! Get the current playback status.
@return Te current playback status
 */
   virtual string getStatus(()) {}
   /*! Get the current base volume level of the source.
This is not the final effective volume that the source is playing at but rather the starting volume level before source group modulation, fades, or distance-based volume attenuation are applied.

@return The current base volume level.

@see setVolume
@see SFXDescription::volume

@ref SFXSource_volume */
   virtual float getVolume(()) {}
   /*! Set the base volume level for the source.
This volume will be the starting point for source group volume modulation, fades, and distance-based volume attenuation.

@param volume The new base volume level for the source.  Must be 0>=volume<=1.

@see getVolume

@ref SFXSource_volume */
   virtual void setVolume(( float volume )) {}
   /*! Get the final effective volume level of the source.

This method returns the volume level as it is after source group volume modulation, fades, and distance-based volume attenuation have been applied to the base volume level.

@return The effective volume of the source.

@ref SFXSource_volume */
   virtual float getAttenuatedVolume(()) {}
   /*! Get the fade-in time set on the source.
This will initially be SFXDescription::fadeInTime.

@return The fade-in time set on the source in seconds.

@see SFXDescription::fadeInTime

@ref SFXSource_fades */
   virtual float getFadeInTime(()) {}
   /*! Get the fade-out time set on the source.
This will initially be SFXDescription::fadeOutTime.

@return The fade-out time set on the source in seconds.

@see SFXDescription::fadeOutTime

@ref SFXSource_fades */
   virtual float getFadeOutTime(()) {}
   /*! Set the fade time parameters of the source.
@param fadeInTime The new fade-in time in seconds.
@param fadeOutTime The new fade-out time in seconds.

@see SFXDescription::fadeInTime
@see SFXDescription::fadeOutTime

@ref SFXSource_fades */
   virtual void setFadeTimes(( float fadeInTime, float fadeOutTime )) {}
   /*! Get the pitch scale of the source.
Pitch determines the playback speed of the source (default: 1).

@return The current pitch scale factor of the source.

@see setPitch
@see SFXDescription::pitch */
   virtual float getPitch(()) {}
   /*! Set the pitch scale of the source.
Pitch determines the playback speed of the source (default: 1).

@param pitch The new pitch scale factor.

@see getPitch
@see SFXDescription::pitch */
   virtual void setPitch(( float pitch )) {}
   /*! Set the position and orientation of a 3D sound source.
@hide */
   virtual void setTransform(( vector position [, vector direction ] )) {}
   /*! Set up the 3D volume cone for the source.

@param innerAngle Angle of the inner sound cone in degrees (@ref SFXDescription::coneInsideAngle).  Must be 0<=innerAngle<=360.
@param outerAngle Angle of the outer sound cone in degrees (@ref SFXDescription::coneOutsideAngle).  Must be 0<=outerAngle<=360.
@param outsideVolume Volume scale factor outside of outer cone (@ref SFXDescription::coneOutsideVolume).  Must be 0<=outsideVolume<=1.
@note This method has no effect on the source if the source is not 3D.

 */
   virtual void setCone(( float innerAngle, float outerAngle, float outsideVolume )) {}
   /*! Get the number of SFXParameters that are attached to the source.
@return The number of parameters attached to the source.

@tsexample
// Print the name ofo each parameter attached to %source.
%numParams = %source.getParameterCount();
for( %i = 0; %i < %numParams; %i ++ )
   echo( %source.getParameter( %i ).getParameterName() );
@endtsexample

@see getParameter
@see addParameter
 */
   virtual int getParameterCount(()) {}
   /*! Attach @a parameter to the source,

Once attached, the source will react to value changes of the given @a parameter.  Attaching a parameter will also trigger an initial read-out of the parameter's current value.

@param parameter The parameter to attach to the source. */
   virtual void addParameter(( SFXParameter parameter )) {}
   /*! Detach @a parameter from the source.

Once detached, the source will no longer react to value changes of the given @a parameter.

If the parameter is not attached to the source, the method will do nothing.

@param parameter The parameter to detach from the source.
 */
   virtual void removeParameter(( SFXParameter parameter )) {}
   /*! Get the parameter at the given index.
@param index Index of the parameter to fetch.  Must be 0<=index<=getParameterCount().
@return The parameter at the given @a index or null if @a index is out of range.

@tsexample
// Print the name ofo each parameter attached to %source.
%numParams = %source.getParameterCount();
for( %i = 0; %i < %numParams; %i ++ )
   echo( %source.getParameter( %i ).getParameterName() );
@endtsexample

@see getParameterCount */
   virtual string getParameter(( int index )) {}
   /*! Add a notification marker called @a name at @a pos seconds of playback.

@param name Symbolic name for the marker that will be passed to the onMarkerPassed() callback.
@param pos Playback position in seconds when the notification should trigger.  Note that this is a soft limit and there may be a delay between the play cursor actually passing the position and the callback being triggered.

@note For looped sounds, the marker will trigger on each iteration.

@tsexample
// Create a new source.
$source = sfxCreateSource( AudioMusicLoop2D, "art/sound/backgroundMusic" );

// Assign a class to the source.
$source.class = "BackgroundMusic";

// Add a playback marker at one minute into playback.
$source.addMarker( "first", 60 );

// Define the callback function.  This function will be called when the playback position passes the one minute mark.
function BackgroundMusic::onMarkerPassed( %this, %markerName )
{
   if( %markerName $= "first" )
      echo( "Playback has passed the 60 seconds mark." );
}

// Play the sound.
$source.play();
@endtsexample */
   virtual void addMarker(( String name, float pos )) {}

   /*! @name Sound
   @{ */
   /*! */
   /*!
   The playback configuration that determines the initial sound properties and setup.
Any SFXSource must have an associated SFXDescription.
   
    */
   SFXDescription description;
   /*!
   Name of function to call when the status of the source changes.

The source that had its status changed is passed as the first argument to the function and the new status of the source is passed as the second argument.
   
    */
   string statusCallback;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A sound source that drives multi-source playback.

This class acts as an interpreter for SFXPlayLists.  It goes through the slots of the playlist it is attached to and performs the actions described by each of the slots in turn.
As SFXControllers are created implicitly by the SFX system when instantiating a source for a play list it is in most cases not necessary to directly deal with the class.
The following example demonstrates how a controller would commonly be created.
@tsexample
// Create a play list from two SFXProfiles.
%playList = new SFXPlayList()
{
   // Use a looped description so the list playback will loop.
   description = AudioMusicLoop2D;

   track[ 0 ] = Profile1;
   track[ 1 ] = Profile2;
};

// Play the list.  This will implicitly create a controller.
sfxPlayOnce( %playList );
@endtsexample

@note Play lists are updated at regular intervals by the sound system.  This processing determines the granularity at which playlist action timing takes place.
@note This class cannot be instantiated directly.  Use sfxPlayOnce() or sfxCreateSource() with the playlist you want to play to create an instance of this class.
@see SFXPlayList
@ingroup SFX
 */
class  SFXController : public SFXSource {
  public:
   /*! Get the index of the playlist slot currently processed by the controller.
@return The slot index currently being played.
@see SFXPlayList */
   virtual int getCurrentSlot(()) {}
   /*! Set the index of the playlist slot to play by the controller.  This can be used to seek in the playlist.
@param index Index of the playlist slot. */
   virtual void setCurrentSlot(( int index )) {}

   /*! @name Debug
   @{ */
   /*! */
   /*!
   If true, the controller logs its operation to the console.
This is a non-networked field that will work locally only.
   
    */
   bool trace;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A sound channel value that can be bound to multiple sound sources.

Parameters are special objects that isolate a specific property that sound sources can have and allows to bind this isolated instance to multiple sound sources such that when the value of the parameter changes, all sources bound to the parameter will have their respective property changed.

Parameters are identified and referenced by their #internalName.  This means that the SFXDescription::parameters and SFXTrack::parameters fields should contain the #internalNames of the SFXParameter objects which should be attached to the SFXSources when they are created.  No two SFXParameters should have the same #internalName.

All SFXParameter instances are automatically made children of the SFXParameterGroup.

@note To simply control the volume and/or pitch levels of a group of sounds, it is easier and more efficient to use a sound source group rather than SFXParameters (see @ref SFXSource_hierarchies).  Simply create a SFXSource object representing the group, assign SFXDescription::sourceGroup of the sounds appropriately, and then set the volume and/or pitch level of the group to modulate the respective properties of all children.

@section SFXParameter_updates Parameter Updates
Parameters are periodically allowed to update their own values.  This makes it possible to attach custom logic to a parameter and have individual parameters synchronize their values autonomously.  Use the onUpdate() callback to attach script code to a parameter update.

@tsexample
new SFXParameter( EngineRPMLevel )
{
   // Set the name by which this parameter is identified.
   internalName = "EngineRPMLevel";

   // Let this parameter control the pitch of attached sources to simulate engine RPM ramping up and down.
   channel = "Pitch";

   // Start out with unmodified pitch.
   defaultValue = 1;

   // Add a texture description of what this parameter does.
   description = "Engine RPM Level";
};

// Create a description that automatically attaches the engine RPM parameter.
singleton SFXDescription( EngineRPMSound : AudioLoop2D )
{
   parameters[ 0 ] = "EngineRPMLevel";
};

// Create sound sources for the engine.
sfxCreateSource( EngineRPMSound, "art/sound/engine/enginePrimary" );
sfxCreateSource( EngineRPMSound, "art/sound/engine/engineSecondary" );

// Setting the parameter value will now affect the pitch level of both sound sources.
EngineRPMLevel.value = 0.5;
EngineRPMLevel.value = 1.5;
@endtsexample

@ref SFX_interactive

 */
class  SFXParameter : public SimObject {
  public:
      /*! Called when the sound system triggers an update on the parameter.
This occurs periodically during system operation. */
      void onUpdate();

   /*! Get the name of the parameter.
@return The paramete name. */
   virtual string getParameterName(()) {}
   /*! Reset the parameter's value to its default.
@see SFXParameter::defaultValue
 */
   virtual void reset(()) {}

   /*! @name Sound
   @{ */
   /*! */
   /*!
   Current value of the audio parameter.
All attached sources are notified when this value changes.
   
    */
   float value;
   /*!
   Permitted range for #value.
Minimum and maximum allowed value for the parameter.  Both inclusive.

For all but the User0-3 channels, this property is automatically set up by SFXParameter.
   
    */
   Point2F range;
   /*!
   Channel that the parameter controls.
This controls which property of the sources it is attached to the parameter controls.
   
    */
   SFXChannel channel;
   /*!
   Value to which the parameter is initially set.
When the parameter is first added to the system, #value will be set to #defaultValue.
   
    */
   float defaultValue;
   /*!
   Textual description of the parameter.
Primarily for use in the Audio Parameters dialog of the editor to allow for easier identification of parameters.
   
    */
   string description;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Encapsulates a single sound file for playback by the sound system.

SFXProfile combines a sound description (SFXDescription) with a sound file such that it can be played by the sound system.  To be able to play a sound file, the sound system will always require a profile for it to be created.  However, several of the SFX functions (sfxPlayOnce(), sfxCreateSource()) perform this creation internally for convenience using temporary profile objects.

Sound files can be in either OGG or WAV format.  However, extended format support is available when using FMOD. See @ref SFX_formats.

@section SFXProfile_loading Profile Loading

By default, the sound data referenced by a profile will be loaded when the profile is first played and the data then kept until either the profile is deleted or until the sound device on which the sound data is held is deleted.

This initial loading my incur a small delay when the sound is first played.  To avoid this, a profile may be expicitly set to load its sound data immediately when the profile is added to the system.  This is done by setting the #preload property to true.

@note Sounds using streamed playback (SFXDescription::isStreaming) cannot be preloaded and will thus ignore the #preload flag.

@tsexample
datablock SFXProfile( Shore01Snd )
{
   fileName     = "art/sound/Lakeshore_mono_01";
   description  = Shore01Looping3d;
   preload      = true;
};
@endtsexample

@ingroup SFX
@ingroup Datablocks
 */
class  SFXProfile : public SFXTrack {
  public:
   /*! Return the length of the sound data in seconds.

@return The length of the sound data in seconds or 0 if the sound referenced by the profile could not be found. */
   virtual float getSoundDuration(()) {}

   /*! @name Sound
   @{ */
   /*! */
   /*!
   %Path to the sound file.
If the extension is left out, it will be inferred by the sound system.  This allows to easily switch the sound format without having to go through the profiles and change the filenames there, too.

   
    */
   filename fileName;
   /*!
   Whether to preload sound data when the profile is added to system.
@note This flag is ignored by streamed sounds.

@ref SFXProfile_loading
   
    */
   bool preload;
   /// @}


   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A sound controller that directly plays a single sound file.

When playing individual audio files, SFXSounds are implicitly created by the sound system.

Each sound source has an associated play cursor that can be queried and explicitly positioned by the user.  The cursor is a floating-point value measured in seconds.

For streamed sources, playback may not be continuous in case the streaming queue is interrupted.

@note This class cannot be instantiated directly by the user but rather is implicitly created by the sound system when sfxCreateSource() or sfxPlayOnce() is called on a SFXProfile instance.

@section SFXSound_virtualization Sounds and Voices

To actually emit an audible signal, a sound must allocate a resource on the sound device through which the sound data is being played back.  This resource is called 'voice'.

As with other types of resources, the availability of these resources may be restricted, i.e. a given sound device will usually only support a fixed number of voices that are playing at the same time.  Since, however, there may be arbitrary many SFXSounds instantiated and playing at the same time, this needs to be solved.  

@see SFXDescription::priority
 */
class  SFXSound : public SFXSource {
  public:
   /*! Test whether the sound data associated with the sound has been fully loaded and is ready for playback.
For streamed sounds, this will be false during playback when the stream queue for the sound is starved and waiting for data.  For buffered sounds, only an initial loading phase will potentially cause isReady to return false.

@return True if the sound is ready for playback. */
   virtual bool isReady(()) {}
   /*! Get the current playback position in seconds.
@return The current play cursor offset. */
   virtual float getPosition(()) {}
   /*! Set the current playback position in seconds.
If the source is currently playing, playback will jump to the new position.  If playback is stopped or paused, playback will resume at the given position when play() is called.

@param position The new position of the play cursor (in seconds).
 */
   virtual void setPosition(( float position )) {}
   /*! Get the total play time (in seconds) of the sound data attached to the sound.
@return 

@note Be aware that for looped sounds, this will not return the total playback time of the sound.
 */
   virtual float getDuration(()) {}

   /*! @name Sound
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief A boolean switch used to modify playlist behavior.

Sound system states are used to allow playlist controllers to make decisions based on global state.  This is useful, for example, to couple audio playback to gameplay state.  Certain states may, for example, represent different locations that the listener can be in, like underwater, in open space, or indoors.  Other states could represent moods of the current gameplay situation, like, for example, an aggressive mood during combat.

By activating and deactivating sound states according to gameplay state, a set of concurrently running playlists may react and adapt to changes in the game.

@section SFXState_activation Activation and Deactivation
At any time, a given state can be either active or inactive.  Calling activate() on a state increases an internal counter and calling deactivate() decreases the counter.  Only when the count reaches zero will the state be deactivated.

In addition to the activation count, states also maintain a disabling count.  Calling disable() increases this count and calling enable() decreases it.  As long as this count is greater than zero, a given state will not be activated even if its activation count is non-zero.  Calling disable() on an active state will not only increase the disabling count but also deactivate the state.  Calling enable() on a state with a positive activation count will re-activate the state when the disabling count reaches zero.

@section SFXState_dependencies State Dependencies
By listing other states in in its #includedStates and #excludedStates fields, a state may automatically trigger the activation or disabling of other states in the sytem when it is activated.  This allows to form dependency chains between individual states.

@tsexample
// State indicating that the listener is submerged.
singleton SFXState( AudioLocationUnderwater )
{
   parentGroup = AudioLocation;
   // AudioStateExclusive is a class defined in the core scripts that will automatically
   // ensure for a state to deactivate all the sibling SFXStates in its parentGroup when it
   // is activated.
   className = "AudioStateExclusive";
};

// State suitable e.g. for combat.
singleton SFXState( AudioMoodAggressive )
{
   parentGroup = AudioMood;
   className = "AudioStateExclusive";
};
@endtsexample

@see SFXPlayList
@see SFXController
@see SFXPlayList::state
@see SFXPlayList::stateMode

@ref SFX_interactive

@ingroup SFX
 */
class  SFXState : public SimDataBlock {
  public:
      /*! Called when the state goes from inactive to active. */
      void onActivate();

      /*! called when the state goes from active to deactive. */
      void onDeactivate();

   /*! Test whether the state is currently active.
This is true when the activation count is >0 and the disabling count is =0.
@return True if the state is currently active.
@see activate */
   virtual bool isActive(()) {}
   /*! Increase the activation count on the state.
If the state isn't already active and it is not disabled, the state will be activated.
@see isActive
@see deactivate
 */
   virtual void activate(()) {}
   /*! Decrease the activation count on the state.
If the count reaches zero and the state was not disabled, the state will be deactivated.
@see isActive
@see activate
 */
   virtual void deactivate(()) {}
   /*! Test whether the state is currently disabled.
This is true when the disabling count of the state is non-zero.
@return True if the state is disabled.

@see disable
 */
   virtual bool isDisabled(()) {}
   /*! Increase the disabling count of the state.
If the state is currently active, it will be deactivated.
@see isDisabled
 */
   virtual void disable(()) {}
   /*! Decrease the disabling count of the state.
If the disabling count reaches zero while the activation count is still non-zero, the state will be reactivated again.
@see isDisabled
 */
   virtual void enable(()) {}

   /*! @name State
   @{ */
   /*! */
   /*!
   States that will automatically be activated when this state is activated.

@ref SFXState_activation
   
    */
   SFXState includedStates;
   /*!
   States that will automatically be disabled when this state is activated.

@ref SFXState_activation
   
    */
   SFXState excludedStates;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Represent a terrain object in a Torque 3D level

@tsexample
new TerrainBlock(theTerrain)
{
   terrainFile = "art/terrains/Deathball Desert_0.ter";
   squareSize = "2";
   tile = "0";
   baseTexSize = "1024";
   screenError = "16";
   position = "-1024 -1024 179.978";
   rotation = "1 0 0 0";
   scale = "1 1 1";
   isRenderEnabled = "true";
   canSaveDynamicFields = "1";
};
@endtsexample

@see TerrainMaterial

@ingroup Terrain
 */
class  TerrainBlock : public SceneObject {
  public:
   /*! @brief Saves the terrain block's terrain file to the specified file name.

@param fileName Name and path of file to save terrain data to.

@return True if file save was successful, false otherwise */
   virtual bool save(( string fileName )) {}
   /*! export the terrain block's heightmap to a bitmap file (default: png) */
   virtual bool exportHeightMap((string filename, [string format])) {}
   /*! export the terrain block's layer maps to bitmap files (default: png) */
   virtual bool exportLayerMaps((string filePrefix, [string format])) {}
   /*! TerrainBlock.create( String terrainName, U32 resolution, String materialName, bool genNoise )
 */
   virtual int createNew() {}
   virtual int import(( String terrainName, String heightMap, F32 metersPerPixel, F32 heightScale, String materials, String opacityLayers[, bool flipYAxis=true] )) {}

   /*! @name Media
   @{ */
   /*! */
   /*!
   The source terrain data file.
   
    */
   filename terrainFile;
   /// @}


   /*! @name Misc
   @{ */
   /*! */
   /*!
   Allows the terrain to cast shadows onto itself and other objects.
   
    */
   bool castShadows;
   /*!
   Indicates the spacing between points on the XY plane on the terrain.
   
    */
   float squareSize;
   /*!
   Size of base texture size per meter.
   
    */
   int baseTexSize;
   /*!
   Light map dimensions in pixels.
   
    */
   int lightMapSize;
   /*!
   Not yet implemented.
   
    */
   int screenError;
   /// @}


   /*! @name Transform
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Mounting
   @{ */
   /*! */
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An object used to modify a DTS or COLLADA shape model after it has been loaded by Torque

@ingroup gameObjects
 */
class  TSShapeConstructor : public SimObject {
  public:
   /*! Add a new mesh primitive to the shape.
@param meshName full name (object name + detail size) of the new mesh. If no detail size is present at the end of the name, a value of 2 is used.<br>An underscore before the number at the end of the name will be interpreted as a negative sign. eg. "MyMesh_4" will be interpreted as "MyMesh-4".
@param type one of: "box", "sphere", "capsule"
@param params mesh primitive parameters:
<ul><li>for box: "size_x size_y size_z"</li><li>for sphere: "radius"</li><li>for capsule: "height radius"</li></ul></ul>
@param txfm local transform offset from the node for this mesh
@param nodeName name of the node to attach the new mesh to (will change the object's node if adding a new mesh to an existing object)
@return true if successful, false otherwise

@tsexample
%this.addMesh( "Box4", "box", "2 4 2", "0 2 0 0 0 1 0", "eye" );
%this.addMesh( "Sphere256", "sphere", "2", "0 0 0 0 0 1 0", "root" );
%this.addMesh( "MyCapsule-1", "capsule", "2 5", "0 0 2 0 0 1 0", "base01" );
@endtsexample
 */
   virtual bool addPrimitive(( string meshName, string type, string params, TransformF txfm, string nodeName )) {}
   /*! Autofit a mesh primitive or set of convex hulls to the shape geometry. Hulls may optionally be converted to boxes, spheres and/or capsules based on their volume.
@param size size for this detail level
@param type one of: box, sphere, capsule, 10-dop x, 10-dop y, 10-dop z, 18-dop, 26-dop, convex hulls. See the Shape Editor documentation for more details about these types.
@param target geometry to fit collision mesh(es) to; either "bounds" (for the whole shape), or the name of an object in the shape
@param depth maximum split recursion depth (hulls only)
@param merge volume % threshold used to merge hulls together (hulls only)
@param concavity volume % threshold used to detect concavity (hulls only)
@param maxVerts maximum number of vertices per hull (hulls only)
@param boxMaxError max % volume difference for a hull to be converted to a box (hulls only)
@param sphereMaxError max % volume difference for a hull to be converted to a sphere (hulls only)
@param capsuleMaxError max % volume difference for a hull to be converted to a capsule (hulls only)
@return true if successful, false otherwise

@tsexample
%this.addCollisionDetail( -1, "box", "bounds" );
%this.addCollisionDetail( -1, "convex hulls", "bounds", 4, 30, 30, 32, 0, 0, 0 );
%this.addCollisionDetail( -1, "convex hulls", "bounds", 4, 30, 30, 32, 50, 50, 50 );
@endtsexample
 */
   virtual bool addCollisionDetail(( int size, string type, string target, int depth=4, float merge=30, float concavity=30, int maxVerts=32, float boxMaxError=0, float sphereMaxError=0, float capsuleMaxError=0 )) {}
      /*! Called immediately after the DTS or DAE file has been loaded; before the shape data is available to any other object (StaticShape, Player etc). This is where you should put any post-load commands to modify the shape in-memory such as addNode, renameSequence etc. */
      void onLoad();

      /*! Called when the DTS or DAE resource is flushed from memory. Not normally required, but may be useful to perform cleanup. */
      void onUnload();

   /*! Dump the shape hierarchy to the console or to a file. Useful for reviewing the result of a series of construction commands.
@param filename Destination filename. If not specified, dump to console.

@tsexample
%this.dumpShape();               // dump to console
%this.dumpShape( "./dump.txt" ); // dump to file
@endtsexample
 */
   virtual void dumpShape(( string filename="" )) {}
   /*! Save the shape (with all current changes) to a new DTS file.
@param filename Destination filename.

@tsexample
%this.saveShape( "./myShape.dts" );
@endtsexample
 */
   virtual void saveShape(( string filename )) {}
   /*! Write the current change set to a TSShapeConstructor script file. The name of the script file is the same as the model, but with .cs extension. eg. myShape.cs for myShape.dts or myShape.dae.
 */
   virtual void writeChangeSet(()) {}
   /*! Notify game objects that this shape file has changed, allowing them to update internal data if needed. */
   virtual void notifyShapeChanged(()) {}
   /*! Get the total number of nodes in the shape.
@return the number of nodes in the shape.

@tsexample
%count = %this.getNodeCount();
@endtsexample
 */
   virtual int getNodeCount(()) {}
   /*! Get the index of the node.
@param name name of the node to lookup.
@return the index of the named node, or -1 if no such node exists.

@tsexample
// get the index of Bip01 Pelvis node in the shape
%index = %this.getNodeIndex( "Bip01 Pelvis" );
@endtsexample
 */
   virtual int getNodeIndex(( string name )) {}
   /*! Get the name of the indexed node.
@param index index of the node to lookup (valid range is 0 - getNodeCount()-1).
@return the name of the indexed node, or "" if no such node exists.

@tsexample
// print the names of all the nodes in the shape
%count = %this.getNodeCount();
for (%i = 0; %i < %count; %i++)
   echo(%i SPC %this.getNodeName(%i));
@endtsexample
 */
   virtual string getNodeName(( int index )) {}
   /*! Get the name of the node's parent. If the node has no parent (ie. it is at the root level), return an empty string.
@param name name of the node to query.
@return the name of the node's parent, or "" if the node is at the root level

@tsexample
echo( "Bip01 Pelvis parent = " @ %this.getNodeParentName( "Bip01 Pelvis ") );
@endtsexample
 */
   virtual string getNodeParentName(( string name )) {}
   /*! Set the parent of a node.
@param name name of the node to modify
@param parentName name of the parent node to set (use "" to move the node to the root level)
@return true if successful, false if failed

@tsexample
%this.setNodeParent( "Bip01 Pelvis", "start01" );
@endtsexample
 */
   virtual bool setNodeParent(( string name, string parentName )) {}
   /*! Get the number of children of this node.
@param name name of the node to query.
@return the number of child nodes.

@tsexample
%count = %this.getNodeChildCount( "Bip01 Pelvis" );
@endtsexample
 */
   virtual int getNodeChildCount(( string name )) {}
   /*! Get the name of the indexed child node.
@param name name of the parent node to query.
@param index index of the child node (valid range is 0 - getNodeChildName()-1).
@return the name of the indexed child node.

@tsexample
function dumpNode( %shape, %name, %indent )
{
   echo( %indent @ %name );
   %count = %shape.getNodeChildCount( %name );
   for ( %i = 0; %i < %count; %i++ )
      dumpNode( %shape, %shape.getNodeChildName( %name, %i ), %indent @ "   " );
}

function dumpShape( %shape )
{
   // recursively dump node hierarchy
   %count = %shape.getNodeCount();
   for ( %i = 0; %i < %count; %i++ )
   {
      // dump top level nodes
      %name = %shape.getNodeName( %i );
      if ( %shape.getNodeParentName( %name ) $=  )
         dumpNode( %shape, %name, "" );
   }
}
@endtsexample
 */
   virtual string getNodeChildName(( string name, int index )) {}
   /*! Get the number of geometry objects attached to this node.
@param name name of the node to query.
@return the number of attached objects.

@tsexample
%count = %this.getNodeObjectCount( "Bip01 Head" );
@endtsexample
 */
   virtual int getNodeObjectCount(( string name )) {}
   /*! Get the name of the indexed object.
@param name name of the node to query.
@param index index of the object (valid range is 0 - getNodeObjectCount()-1).
@return the name of the indexed object.

@tsexample
// print the names of all objects attached to the node
%count = %this.getNodeObjectCount( "Bip01 Head" );
for ( %i = 0; %i < %count; %i++ )
   echo( %this.getNodeObjectName( "Bip01 Head", %i ) );
@endtsexample
 */
   virtual string getNodeObjectName(( string name, int index )) {}
   /*! Get the base (ie. not animated) transform of a node.
@param name name of the node to query.
@param isWorld true to get the global transform, false (or omitted) to get the local-to-parent transform.
@return the node transform in the form "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle".

@tsexample
%ret = %this.getNodeTransform( "mount0" );
%this.setNodeTransform( "mount4", %ret );
@endtsexample
 */
   virtual string getNodeTransform(( string name, bool isWorld=false )) {}
   /*! Set the base transform of a node. That is, the transform of the node when in the root (not-animated) pose.
@param name name of the node to modify
@param txfm transform string of the form: "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle"
@param isworld (optional) flag to set the local-to-parent or the global transform. If false, or not specified, the position and orientation are treated as relative to the node's parent.
@return true if successful, false otherwise

@tsexample
%this.setNodeTransform( "mount0", "0 0 1 0 0 1 0" );
%this.setNodeTransform( "mount0", "0 0 0 0 0 1 1.57" );
%this.setNodeTransform( "mount0", "1 0 0 0 0 1 0", true );
@endtsexample
 */
   virtual bool setNodeTransform(( string name, TransformF txfm, bool isWorld=false )) {}
   /*! Rename a node.
@note Note that node names must be unique, so this command will fail if there is already a node with the desired name
@param oldName current name of the node
@param newName new name of the node
@return true if successful, false otherwise

@tsexample
%this.renameNode( "Bip01 L Hand", "mount5" );
@endtsexample
 */
   virtual bool renameNode(( string oldName, string newName )) {}
   /*! Add a new node.
@param name name for the new node (must not already exist)
@param parentName name of an existing node to be the parent of the new node. If empty (""), the new node will be at the root level of the node hierarchy.
@param txfm (optional) transform string of the form: "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle"
@param isworld (optional) flag to set the local-to-parent or the global transform. If false, or not specified, the position and orientation are treated as relative to the node's parent.
@return true if successful, false otherwise

@tsexample
%this.addNode( "Nose", "Bip01 Head", "0 2 2 0 0 1 0" );
%this.addNode( "myRoot", "", "0 0 4 0 0 1 1.57" );
%this.addNode( "Nodes", "Bip01 Head", "0 2 0 0 0 1 0", true );
@endtsexample
 */
   virtual bool addNode(( string name, string parentName, TransformF txfm=TransformF::Identity, bool isWorld=false )) {}
   /*! Remove a node from the shape.
The named node is removed from the shape, including from any sequences that use the node. Child nodes and objects attached to the node are re-assigned to the node's parent.
@param name name of the node to remove.
@return true if successful, false otherwise.

@tsexample
%this.removeNode( "Nose" );
@endtsexample
 */
   virtual bool removeNode(( string name )) {}
   /*! Get the number of materials in the shape.
@return the number of materials in the shape.

@tsexample
%count = %this.getTargetCount();
@endtsexample
 */
   virtual int getTargetCount(()) {}
   /*! Get the name of the indexed shape material.
@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.

@tsexample
%count = %this.getTargetCount();
for ( %i = 0; %i < %count; %i++ )
   echo( "Target " @ %i @ ": " @ %this.getTargetName( %i ) );
@endtsexample
 */
   virtual string getTargetName(( int index )) {}
   /*! Get the total number of objects in the shape.
@return the number of objects in the shape.

@tsexample
%count = %this.getObjectCount();
@endtsexample
 */
   virtual int getObjectCount(()) {}
   /*! Get the name of the indexed object.
@param index index of the object to get (valid range is 0 - getObjectCount()-1).
@return the name of the indexed object.

@tsexample
// print the names of all objects in the shape
%count = %this.getObjectCount();
for ( %i = 0; %i < %count; %i++ )
   echo( %i SPC %this.getObjectName( %i ) );
@endtsexample
 */
   virtual string getObjectName(( int index )) {}
   /*! Get the index of the first object with the given name.
@param name name of the object to get.
@return the index of the named object.

@tsexample
%index = %this.getObjectIndex( "Head" );
@endtsexample
 */
   virtual int getObjectIndex(( string name )) {}
   /*! Get the name of the node this object is attached to.
@param name name of the object to get.
@return the name of the attached node, or an empty string if this object is not attached to a node (usually the case for skinned meshes).

@tsexample
echo( "Hand is attached to " @ %this.getObjectNode( "Hand" ) );
@endtsexample
 */
   virtual string getObjectNode(( string name )) {}
   /*! Set the node an object is attached to.
When the shape is rendered, the object geometry is rendered at the node's current transform.
@param objName name of the object to modify
@param nodeName name of the node to attach the object to
@return true if successful, false otherwise

@tsexample
%this.setObjectNode( "Hand", "Bip01 LeftHand" );
@endtsexample
 */
   virtual bool setObjectNode(( string objName, string nodeName )) {}
   /*! Rename an object.
@note Note that object names must be unique, so this command will fail if there is already an object with the desired name
@param oldName current name of the object
@param newName new name of the object
@return true if successful, false otherwise

@tsexample
%this.renameObject( "MyBox", "Box" );
@endtsexample
 */
   virtual bool renameObject(( string oldName, string newName )) {}
   /*! Remove an object (including all meshes for that object) from the shape.
@param name name of the object to remove.
@return true if successful, false otherwise.

@tsexample
// clear all objects in the shape
%count = %this.getObjectCount();
for ( %i = %count-1; %i >= 0; %i-- )
   %this.removeObject( %this.getObjectName(%i) );
@endtsexample
 */
   virtual bool removeObject(( string name )) {}
   /*! Get the number of meshes (detail levels) for the specified object.
@param name name of the object to query
@return the number of meshes for this object.

@tsexample
%count = %this.getMeshCount( "SimpleShape" );
@endtsexample
 */
   virtual int getMeshCount(( string name )) {}
   /*! Get the name of the indexed mesh (detail level) for the specified object.
@param name name of the object to query
@param index index of the mesh (valid range is 0 - getMeshCount()-1)
@return the mesh name.

@tsexample
// print the names of all meshes in the shape
%objCount = %this.getObjectCount();
for ( %i = 0; %i < %objCount; %i++ )
{
   %objName = %this.getObjectName( %i );
   %meshCount = %this.getMeshCount( %objName );
   for ( %j = 0; %j < %meshCount; %j++ )
      echo( %this.getMeshName( %objName, %j ) );
}
@endtsexample
 */
   virtual string getMeshName(( string name, int index )) {}
   /*! Get the detail level size of the indexed mesh for the specified object.
@param name name of the object to query
@param index index of the mesh (valid range is 0 - getMeshCount()-1)
@return the mesh detail level size.

@tsexample
// print sizes for all detail levels of this object
%objName = "trunk";
%count = %this.getMeshCount( %objName );
for ( %i = 0; %i < %count; %i++ )
   echo( %this.getMeshSize( %objName, %i ) );
@endtsexample
 */
   virtual int getMeshSize(( string name, int index )) {}
   /*! Change the detail level size of the named mesh.
@param name full name (object name + current size ) of the mesh to modify
@param size new detail level size
@return true if successful, false otherwise.

@tsexample
%this.setMeshSize( "SimpleShape128", 64 );
@endtsexample
 */
   virtual bool setMeshSize(( string name, int size )) {}
   /*! Get the display type of the mesh.
@param name name of the mesh to query
@return the string returned is one of:<dl><dt>normal</dt><dd>a normal 3D mesh</dd><dt>billboard</dt><dd>a mesh that always faces the camera</dd><dt>billboardzaxis</dt><dd>a mesh that always faces the camera in the Z-axis</dd></dl>

@tsexample
echo( "Mesh type is " @ %this.getMeshType( "SimpleShape128" ) );
@endtsexample
 */
   virtual string getMeshType(( string name )) {}
   /*! Set the display type for the mesh.
@param name full name (object name + detail size) of the mesh to modify
@param type the new type for the mesh: "normal", "billboard" or "billboardzaxis"
@return true if successful, false otherwise

@tsexample
// set the mesh to be a billboard
%this.setMeshType( "SimpleShape64", "billboard" );
@endtsexample
 */
   virtual bool setMeshType(( string name, string type )) {}
   /*! Get the name of the material attached to a mesh. Note that only the first material used by the mesh is returned.
@param name full name (object name + detail size) of the mesh to query
@return name of the material attached to the mesh (suitable for use with the Material mapTo field)

@tsexample
echo( "Mesh material is " @ %this.sgetMeshMaterial( "SimpleShape128" ) );
@endtsexample
 */
   virtual string getMeshMaterial(( string name )) {}
   /*! Set the name of the material attached to the mesh.
@param meshName full name (object name + detail size) of the mesh to modify
@param matName name of the material to attach. This could be the base name of the diffuse texture (eg. "test_mat" for "test_mat.jpg"), or the name of a Material object already defined in script.
@return true if successful, false otherwise

@tsexample
// set the mesh material
%this.setMeshMaterial( "SimpleShape128", "test_mat" );
@endtsexample
 */
   virtual bool setMeshMaterial(( string meshName, string matName )) {}
   /*! Add geometry from another DTS or DAE shape file into this shape.
Any materials required by the source mesh are also copied into this shape.<br>
@param meshName full name (object name + detail size) of the new mesh. If no detail size is present at the end of the name, a value of 2 is used.<br>An underscore before the number at the end of the name will be interpreted as a negative sign. eg. "MyMesh_4" will be interpreted as "MyMesh-4".
@param srcShape name of a shape file (DTS or DAE) that contains the mesh
@param srcMesh the full name (object name + detail size) of the mesh to copy from the DTS/DAE file into this shape</li>@return true if successful, false otherwise

@tsexample
%this.addMesh( "ColMesh-1", "./collision.dts", "ColMesh", "Col-1" );
%this.addMesh( "SimpleShape10", "./testShape.dae", "MyMesh2",  );
@endtsexample
 */
   virtual bool addMesh(( string meshName, string srcShape, string srcMesh )) {}
   /*! Remove a mesh from the shape.
If all geometry is removed from an object, the object is also removed.
@param name full name (object name + detail size) of the mesh to remove
@return true if successful, false otherwise

@tsexample
%this.removeMesh( "SimpleShape128" );
@endtsexample
 */
   virtual bool removeMesh(( string name )) {}
   /*! Get the bounding box for the shape.
@return Bounding box "minX minY minZ maxX maxY maxZ" */
   virtual string getBounds(()) {}
   /*! Set the shape bounds to the given bounding box.
@param Bounding box "minX minY minZ maxX maxY maxZ"
@return true if successful, false otherwise
 */
   virtual bool setBounds(( Box3F bbox )) {}
   /*! Get the total number of detail levels in the shape.
@return the number of detail levels in the shape
 */
   virtual int getDetailLevelCount(()) {}
   /*! Get the name of the indexed detail level.
@param index detail level index (valid range is 0 - getDetailLevelCount()-1)
@return the detail level name

@tsexample
// print the names of all detail levels in the shape
%count = %this.getDetailLevelCount();
for ( %i = 0; %i < %count; %i++ )
   echo( %i SPC %this.getDetailLevelName( %i ) );
@endtsexample
 */
   virtual string getDetailLevelName(( int index )) {}
   /*! Get the size of the indexed detail level.
@param index detail level index (valid range is 0 - getDetailLevelCount()-1)
@return the detail level size

@tsexample
// print the sizes of all detail levels in the shape
%count = %this.getDetailLevelCount();
for ( %i = 0; %i < %count; %i++ )
   echo( "Detail" @ %i @ " has size " @ %this.getDetailLevelSize( %i ) );
@endtsexample
 */
   virtual int getDetailLevelSize(( int index )) {}
   /*! Get the index of the detail level with a given size.
@param size size of the detail level to lookup
@return index of the detail level with the desired size, or -1 if no such detail exists

@tsexample
if ( %this.getDetailLevelSize( 32 ) == -1 )
   echo( "Error: This shape does not have a detail level at size 32" );
@endtsexample
 */
   virtual int getDetailLevelIndex(( int size )) {}
   /*! Rename a detail level.
@note Note that detail level names must be unique, so this command will fail if there is already a detail level with the desired name
@param oldName current name of the detail level
@param newName new name of the detail level
@return true if successful, false otherwise

@tsexample
%this.renameDetailLevel( "detail-1", "collision-1" );
@endtsexample
 */
   virtual bool renameDetailLevel(( string oldName, string newName )) {}
   /*! Remove the detail level (including all meshes in the detail level)
@param size size of the detail level to remove
@return true if successful, false otherwise
@tsexample
%this.removeDetailLevel( 2 );
@endtsexample
 */
   virtual bool removeDetailLevel(( int index )) {}
   /*! Change the size of a detail level.@note Note that detail levels are always sorted in decreasing size order, so this command may cause detail level indices to change.
@param index index of the detail level to modify
@param newSize new size for the detail level
@return new index for this detail level

@tsexample
%this.setDetailLevelSize( 2, 256 );
@endtsexample
 */
   virtual int setDetailLevelSize(( int index, int newSize )) {}
   /*! Get the index of the imposter (auto-billboard) detail level (if any).
@return imposter detail level index, or -1 if the shape does not use imposters.

 */
   virtual int getImposterDetailLevel(()) {}
   /*! Get the settings used to generate imposters for the indexed detail level.
@param index index of the detail level to query (does not need to be an imposter detail level
@return string of the form: "valid eqSteps pSteps dl dim poles angle", where:<dl><dt>valid</dt><dd>1 if this detail level generates imposters, 0 otherwise</dd><dt>eqSteps</dt><dd>number of steps around the equator</dd><dt>pSteps</dt><dd>number of steps between the poles</dd><dt>dl</dt><dd>index of the detail level used to generate imposters</dd><dt>dim</dt><dd>size (in pixels) of each imposter image</dd><dt>poles</dt><dd>1 to include pole images, 0 otherwise</dd><dt>angle</dt><dd>angle at which to display pole images</dd></dl>

@tsexample
// print the imposter detail level settings
%index = %this.getImposterDetailLevel();
if ( %index != -1 )
   echo( "Imposter settings: " @ %this.getImposterSettings( %index ) );
@endtsexample
 */
   virtual string getImposterSettings(( int index )) {}
   /*! Add (or edit) an imposter detail level to the shape.
If the shape already contains an imposter detail level, this command will simply change the imposter settings
@param size size of the imposter detail level
@param equatorSteps defines the number of snapshots to take around the equator. Imagine the object being rotated around the vertical axis, then a snapshot taken at regularly spaced intervals.
@param polarSteps defines the number of snapshots taken between the poles (top and bottom), at each equator step. eg. At each equator snapshot, snapshots are taken at regular intervals between the poles.
@param dl the detail level to use when generating the snapshots. Note that this is an array index rather than a detail size. So if an object has detail sizes of: 200, 150, and 40, then setting @a dl to 1 will generate the snapshots using detail size 150.
@param dim defines the size of the imposter images in pixels. The larger the number, the more detailed the billboard will be.
@param includePoles flag indicating whether to include the "pole" snapshots. ie. the views from the top and bottom of the object.
@param polar_angle if pole snapshots are active (@a includePoles is true), this parameter defines the camera angle (in degrees) within which to render the pole snapshot. eg. if polar_angle is set to 25 degrees, then the snapshot taken at the pole (looking directly down or up at the object) will be rendered when the camera is within 25 degrees of the pole.
@return true if successful, false otherwise

@tsexample
%this.addImposter( 2, 4, 0, 0, 64, false, 0 );
%this.addImposter( 2, 4, 2, 0, 64, true, 10 );   // this command would edit the existing imposter detail level
@endtsexample
 */
   virtual int addImposter(( int size, int equatorSteps, int polarSteps, int dl, int dim, bool includePoles, float polarAngle )) {}
   /*! Remove the imposter detail level (if any) from the shape.
@return true if successful, false otherwise

 */
   virtual bool removeImposter(()) {}
   /*! Get the total number of sequences in the shape.
@return the number of sequences in the shape

 */
   virtual int getSequenceCount(()) {}
   /*! Find the index of the sequence with the given name.
@param name name of the sequence to lookup
@return index of the sequence with matching name, or -1 if not found

@tsexample
// Check if a given sequence exists in the shape
if ( %this.getSequenceIndex( "walk" ) == -1 )
   echo( "Could not find 'walk' sequence" );
@endtsexample
 */
   virtual int getSequenceIndex(( string name )) {}
   /*! Get the name of the indexed sequence.
@param index index of the sequence to query (valid range is 0 - getSequenceCount()-1)
@return the name of the sequence

@tsexample
// print the name of all sequences in the shape
%count = %this.getSequenceCount();
for ( %i = 0; %i < %count; %i++ )
   echo( %i SPC %this.getSequenceName( %i ) );
@endtsexample
 */
   virtual string getSequenceName(( int index )) {}
   /*! Get information about where the sequence data came from.
For example, whether it was loaded from an external DSQ file.
@param name name of the sequence to query
@return TAB delimited string of the form: "from reserved start end total", where:<dl><dt>from</dt><dd>the source of the animation data, such as the path to a DSQ file, or the name of an existing sequence in the shape. This field will be empty for sequences already embedded in the DTS or DAE file.</dd><dt>reserved</dt><dd>reserved value</dd><dt>start</dt><dd>the first frame in the source sequence used to create this sequence</dd><dt>end</dt><dd>the last frame in the source sequence used to create this sequence</dd><dt>total</dt><dd>the total number of frames in the source sequence</dd></dl>

@tsexample
// print the source for the walk animation
echo( "walk source:" SPC getField( %this.getSequenceSource( "walk" ), 0 ) );
@endtsexample
 */
   virtual string getSequenceSource(( string name )) {}
   /*! Get the number of keyframes in the sequence.
@param name name of the sequence to query
@return number of keyframes in the sequence

@tsexample
echo( "Run has " @ %this.getSequenceFrameCount( "run" ) @ " keyframes" );
@endtsexample
 */
   virtual int getSequenceFrameCount(( string name )) {}
   /*! Get the priority setting of the sequence.
@param name name of the sequence to query
@return priority value of the sequence

 */
   virtual float getSequencePriority(( string name )) {}
   /*! Set the sequence priority.
@param name name of the sequence to modify
@param priority new priority value
@return true if successful, false otherwise

 */
   virtual bool setSequencePriority(( string name, float priority )) {}
   /*! Get the ground speed of the sequence.
@note Note that only the first 2 ground frames of the sequence are examined; the speed is assumed to be constant throughout the sequence.
@param name name of the sequence to query
@return string of the form: "trans.x trans.y trans.z rot.x rot.y rot.z"

@tsexample
%speed = VectorLen( getWords( %this.getSequenceGroundSpeed( "run" ), 0, 2 ) );
   echo( "Run moves at " @ %speed @ " units per frame" );
@endtsexample
 */
   virtual string getSequenceGroundSpeed(( string name )) {}
   /*! Set the translation and rotation ground speed of the sequence.
The ground speed of the sequence is set by generating ground transform keyframes. The ground translational and rotational speed is assumed to be constant for the duration of the sequence. Existing ground frames for the sequence (if any) will be replaced.
@param name name of the sequence to modify
@param transSpeed translational speed (trans.x trans.y trans.z) in Torque units per frame
@param rotSpeed (optional) rotational speed (rot.x rot.y rot.z) in radians per frame. Default is "0 0 0"
@return true if successful, false otherwise

@tsexample
%this.setSequenceGroundSpeed( "run", "5 0 0" );
%this.setSequenceGroundSpeed( "spin", "0 0 0", "4 0 0" );
@endtsexample
 */
   virtual bool setSequenceGroundSpeed(( string name, Point3F transSpeed, Point3F rotSpeed=Point3F::Zero )) {}
   /*! Check if this sequence is cyclic (looping).
@param name name of the sequence to query
@return true if this sequence is cyclic, false if not

@tsexample
if ( !%this.getSequenceCyclic( "ambient" ) )
   error( "ambient sequence is not cyclic!" );
@endtsexample
 */
   virtual bool getSequenceCyclic(( string name )) {}
   /*! Mark a sequence as cyclic or non-cyclic.
@param name name of the sequence to modify
@param cyclic true to make the sequence cyclic, false for non-cyclic
@return true if successful, false otherwise

@tsexample
%this.setSequenceCyclic( "ambient", true );
%this.setSequenceCyclic( "shoot", false );
@endtsexample
 */
   virtual bool setSequenceCyclic(( string name, bool cyclic )) {}
   /*! Get information about blended sequences.
@param name name of the sequence to query
@return TAB delimited string of the form: "isBlend blendSeq blendFrame", where:<dl><dt>blend_flag</dt><dd>a boolean flag indicating whether this sequence is a blend</dd><dt>blend_seq_name</dt><dd>the name of the sequence that contains the reference frame (empty for blend sequences embedded in DTS files)</dd><dt>blend_seq_frame</dt><dd>the blend reference frame (empty for blend sequences embedded in DTS files)</dd></dl>
@note Note that only sequences set to be blends using the setSequenceBlend command will contain the blendSeq and blendFrame information.

@tsexample
%blendData = %this.getSequenceBlend( "look" );
if ( getField( %blendData, 0 ) )
   echo( "look is a blend, reference: " @ getField( %blendData, 1 ) );
@endtsexample
 */
   virtual string getSequenceBlend(( string name )) {}
   /*! Mark a sequence as a blend or non-blend.
A blend sequence is one that will be added on top of any other playing sequences. This is done by storing the animated node transforms relative to a reference frame, rather than as absolute transforms.
@param name name of the sequence to modify
@param blend true to make the sequence a blend, false for a non-blend
@param blendSeq the name of the sequence that contains the blend reference frame
@param blendFrame the reference frame in the blendSeq sequence
@return true if successful, false otherwise

@tsexample
%this.setSequenceBlend( "look", true, "root", 0 );
@endtsexample
 */
   virtual bool setSequenceBlend(( string name, bool blend, string blendSeq, int blendFrame )) {}
   /*! Rename a sequence.
@note Note that sequence names must be unique, so this command will fail if there is already a sequence with the desired name
@param oldName current name of the sequence
@param newName new name of the sequence
@return true if successful, false otherwise

@tsexample
%this.renameSequence( "walking", "walk" );
@endtsexample
 */
   virtual bool renameSequence(( string oldName, string newName )) {}
   /*! Add a new sequence to the shape.
@param source the name of an existing sequence, or the name of a DTS or DAE shape or DSQ sequence file. When the shape file contains more than one sequence, the desired sequence can be specified by appending the name to the end of the shape file. eg. "myShape.dts run" would select the "run" sequence from the "myShape.dts" file.

@param name name of the new sequence
@param start (optional) first frame to copy. Defaults to 0, the first frame in the sequence.
@param end (optional) last frame to copy. Defaults to -1, the last frame in the sequence.
@param padRot (optional) copy root-pose rotation keys for non-animated nodes. This is useful if the source sequence data has a different root-pose to the target shape, such as if one character was in the T pose, and the other had arms at the side. Normally only nodes that are actually rotated by the source sequence have keyframes added, but setting this flag will also add keyframes for nodes that are not animated, but have a different root-pose rotation to the target shape root pose.
@param padTrans (optional) copy root-pose translation keys for non-animated nodes.  This is useful if the source sequence data has a different root-pose to the target shape, such as if one character was in the T pose, and the other had arms at the side. Normally only nodes that are actually moved by the source sequence have keyframes added, but setting this flag will also add keyframes for nodes that are not animated, but have a different root-pose position to the target shape root pose.
@return true if successful, false otherwise

@tsexample
%this.addSequence( "./testShape.dts ambient", "ambient" );
%this.addSequence( "./myPlayer.dae run", "run" );
%this.addSequence( "./player_look.dsq", "look", 0, -1 );     // start to end
%this.addSequence( "walk", "walk_shortA", 0, 4 );            // start to frame 4
%this.addSequence( "walk", "walk_shortB", 4, -1 );           // frame 4 to end
@endtsexample
 */
   virtual bool addSequence(( string source, string name, int start=0, int end=-1, bool padRot=true, bool padTrans=false )) {}
   /*! Remove the sequence from the shape.
@param name name of the sequence to remove
@return true if successful, false otherwise

 */
   virtual bool removeSequence(( string name )) {}
   /*! Get the number of triggers in the specified sequence.
@param name name of the sequence to query
@return number of triggers in the sequence

 */
   virtual int getTriggerCount(( string name )) {}
   /*! Get information about the indexed trigger
@param name name of the sequence to query
@param index index of the trigger (valid range is 0 - getTriggerCount()-1)
@return string of the form "frame state"

@tsexample
// print all triggers in the sequence
%count = %this.getTriggerCount( "back" );
for ( %i = 0; %i < %count; %i++ )
   echo( %i SPC %this.getTrigger( "back", %i ) );
@endtsexample
 */
   virtual string getTrigger(( string name, int index )) {}
   /*! Add a new trigger to the sequence.
@param name name of the sequence to modify
@param keyframe keyframe of the new trigger
@param state of the new trigger
@return true if successful, false otherwise

@tsexample
%this.addTrigger( "walk", 3, 1 );
%this.addTrigger( "walk", 5, -1 );
@endtsexample
 */
   virtual bool addTrigger(( string name, int keyframe, int state )) {}
   /*! Remove a trigger from the sequence.
@param name name of the sequence to modify
@param keyframe keyframe of the trigger to remove
@param state of the trigger to remove
@return true if successful, false otherwise

@tsexample
%this.removeTrigger( "walk", 3, 1 );
@endtsexample
 */
   virtual bool removeTrigger(( string name, int keyframe, int state )) {}

   /*! @name Media
   @{ */
   /*! */
   /*!
   Specifies the path to the DTS or DAE file to be operated on by this object.
Since the TSShapeConstructor script must be in the same folder as the DTS or DAE file, it is recommended to use a relative path so that the shape and script files can be copied to another location without having to modify the path.
   
    */
   filename baseShape;
   /// @}


   /*! @name Collada
   @{ */
   /*! */
   /*!
   Override the <up_axis> element in the COLLADA (.dae) file. No effect for DTS files.
Set to one of the following values:
<dl><dt>X_AXIS</dt><dd>Positive X points up. Model will be rotated into Torque's coordinate system (Z up).</dd><dt>Y_AXIS</dt><dd>Positive Y points up. Model will be rotated into Torque's coordinate system (Z up).</dd><dt>Z_AXIS</dt><dd>Positive Z points up. No rotation will be applied to the model.</dd><dt>DEFAULT</dt><dd>The default value. Use the value in the .dae file (defaults to Z_AXIS if the <up_axis> element is not present).</dd></dl>
   
    */
   TSShapeConstructorUpAxis upAxis;
   /*!
   Override the <unit> element in the COLLADA (.dae) file. No effect for DTS files.
COLLADA (.dae) files usually contain a <unit> element that indicates the 'real world' units that the model is described in. It means you can work in sensible and meaningful units in your modeling app.<br>
For example, if you were modeling a small object like a cup, it might make sense to work in inches (1 MAX unit = 1 inch), but if you were modeling a building, it might make more sense to work in feet (1 MAX unit = 1 foot). If you export both models to COLLADA, T3D will automatically scale them appropriately. 1 T3D unit = 1 meter, so the cup would be scaled down by 0.0254, and the building scaled down by 0.3048, given them both the correct scale relative to each other.<br>
Omit the field or set to -1 to use the value in the .dae file (1.0 if the <unit> element is not present)
   
    */
   float unit;
   /*!
   Control how the COLLADA (.dae) importer interprets LOD in the model. No effect for DTS files.
Set to one of the following values:
<dl><dt>DetectDTS</dt><dd>The default value. Instructs the importer to search for a 'baseXXX->startXXX' node hierarchy at the root level. If found, the importer acts as if ''TrailingNumber'' was set. Otherwise, all geometry is imported at a single detail size.</dd><dt>SingleSize</dt><dd>All geometry is imported at a fixed detail size. Numbers at the end of geometry node's are ignored.</dd><dt>TrailingNumber</dt><dd>Numbers at the end of geometry node's name are interpreted as the detail size (similar to DTS exporting). Geometry instances with the same base name but different trailing number are grouped into the same object.</dd><dt>DEFAULT</dt><dd>The default value. Use the value in the .dae file (defaults to Z_AXIS if the <up_axis> element is not present).</dd></dl>
   
    */
   TSShapeConstructorLodType lodType;
   /*!
   Sets the detail size when lodType is set to SingleSize. No effect otherwise, and no effect for DTS files.
@see lodType
   
    */
   int singleDetailSize;
   /*!
   Prefix to apply to all material map names in the COLLADA (.dae) file. No effect for DTS files.
This field is useful to avoid material name clashes for exporters that generate generic material names like "texture0" or "material1".
   
    */
   string matNamePrefix;
   /*!
   TAB separated patterns of nodes to import even if in neverImport list. No effect for DTS files.
Torque allows unwanted nodes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match node names. Any node that matches one of the patterns in the list will <b>always</b> be imported, even if it also matches the neverImport list
@see neverImport

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
   baseShape = "./myShape.dae";
   alwaysImport = "mount*" TAB "eye";
   neverImport = "*-PIVOT";
}
@endtsexample
   
    */
   string alwaysImport;
   /*!
   TAB separated patterns of nodes to ignore on loading. No effect for DTS files.
Torque allows unwanted nodes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match node names. Any node that matches one of the patterns in the list will not be imported (unless it matches the alwaysImport list.
@see alwaysImport
   
    */
   string neverImport;
   /*!
   TAB separated patterns of meshes to import even if in neverImportMesh list. No effect for DTS files.
Torque allows unwanted meshes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match mesh names. Any mesh that matches one of the patterns in the list will <b>always</b> be imported, even if it also matches the neverImportMesh list
@see neverImportMesh

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
   baseShape = "./myShape.dae";
   alwaysImportMesh = "body*" TAB "armor" TAB "bounds";
   neverImportMesh = "*-dummy";
}
@endtsexample
   
    */
   string alwaysImportMesh;
   /*!
   TAB separated patterns of meshes to ignore on loading. No effect for DTS files.
Torque allows unwanted meshes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match mesh names. Any mesh that matches one of the patterns in the list will not be imported (unless it matches the alwaysImportMesh list.
@see alwaysImportMesh
   
    */
   string neverImportMesh;
   /*!
   Ignore <scale> elements inside COLLADA <node>s. No effect for DTS files.
This field is a workaround for certain exporters that generate bad node scaling, and is not usually required.
   
    */
   bool ignoreNodeScale;
   /*!
   Translate COLLADA model on import so the origin is at the center. No effect for DTS files.
   
    */
   bool adjustCenter;
   /*!
   Translate COLLADA model on import so origin is at the (Z axis) bottom of the model. No effect for DTS files.
This can be used along with adjustCenter to have the origin at the center of the bottom of the model.
@see adjustCenter
   
    */
   bool adjustFloor;
   /*!
   Forces update of the materials.cs file in the same folder as the COLLADA (.dae) file, even if Materials already exist. No effect for DTS files.
Normally only Materials that are not already defined are written to materials.cs.
   
    */
   bool forceUpdateMaterials;
   /// @}


   /*! @name Sequences
   @{ */
   /*! */
   /*!
   Legacy method of adding sequences to a DTS or DAE shape after loading.

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
   baseShape = "./myShape.dae";
   sequence = "../anims/root.dae root";
   sequence = "../anims/walk.dae walk";
   sequence = "../anims/jump.dsq jump";
}
@endtsexample
   
    */
   filename sequence;
   /// @}


   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief Class used for writing out preferences and settings for editors

Not intended for game development, for editors or internal use only.

 */
class  Settings : public SimObject {
  public:
   /*! settingObj.findFirstValue(); */
   virtual string findFirstValue() {}
   /*! settingObj.findNextValue(); */
   virtual string findNextValue() {}
   /*! settingObj.setValue(settingName, value); */
   virtual void setValue() {}
   /*! settingObj.setDefaultValue(settingName, value); */
   virtual void setDefaultValue() {}
   /*! settingObj.value(settingName, defaultValue); */
   virtual string value() {}
   /*! settingObj.remove(settingName, includeDefaults = false); */
   virtual void remove() {}
   /*! %success = settingObj.write(); */
   virtual bool write() {}
   /*! %success = settingObj.read(); */
   virtual bool read() {}
   /*! settingObj.beginGroup(groupName, fromStart = false); */
   virtual void beginGroup() {}
   /*! settingObj.endGroup(); */
   virtual void endGroup() {}
   /*! settingObj.clearGroups(); */
   virtual void clearGroups() {}
   /*! settingObj.getCurrentGroups(); */
   virtual string getCurrentGroups() {}
   /*!
   The file path and name to be saved to and loaded from.
   
    */
   filename file;

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief An undo action that is comprised of other undo actions.

Not intended for game development, for editors or internal use only.

 */
class  CompoundUndoAction : public UndoAction {
  public:
   /*! addAction( UndoAction ) */
   virtual void addAction() {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

/*!
@brief SimObject which adds, tracks, and deletes UndoAction objects.

Not intended for game development, for editors or internal use only.

 */
class  UndoManager : public SimObject {
  public:
   /*! Clears the undo manager. */
   virtual void clearAll() {}
   virtual int getUndoCount() {}
   virtual string getUndoName((index)) {}
   virtual int getUndoAction((index)) {}
   virtual int getRedoCount() {}
   virtual string getRedoName((index)) {}
   virtual int getRedoAction((index)) {}
   /*! UndoManager.undo(); */
   virtual void undo() {}
   /*! UndoManager.redo(); */
   virtual void redo() {}
   /*! UndoManager.getNextUndoName(); */
   virtual string getNextUndoName() {}
   /*! UndoManager.getNextRedoName(); */
   virtual string getNextRedoName() {}
   /*! Push a CompoundUndoAction onto the compound stack for assembly. */
   virtual string pushCompound(( string name="" )) {}
   /*! Pop the current CompoundUndoAction off the stack. */
   virtual void popCompound(( bool discard=false )) {}
   /*!
   Number of undo & redo levels.
   
    */
   int numLevels;
};

/*!
@brief The EventManager class is a wrapper for the standard messaging system.

It provides functionality for management of event queues, events, and subscriptions. Creating an EventManager is as simple as calling new EventManager and specifying a queue name.

@tsexample
// Create the EventManager.
$MyEventManager = new EventManager() { queue = "MyEventManager"; };

// Create an event.
$MyEventManager.registerEvent( "SomeCoolEvent" );

// Create a listener and subscribe.
$MyListener = new ScriptMsgListener() { class = MyListener; };
$MyEventManager.subscribe( $MyListener, "SomeCoolEvent" );

function MyListener::onSomeCoolEvent( %this, %data )
{
^  echo( "onSomeCoolEvent Triggered" );
}

// Trigger the event.
$MyEventManager.postEvent( "SomeCoolEvent", "Data" );
@endtsexample

@see ScriptMsgListener

@ingroup Messaging
 */
class  EventManager : public SimObject {
  public:
   /*! Register an event with the event manager.
@param event The event to register.
@return Whether or not the event was registered successfully. */
   virtual bool registerEvent(( String event )) {}
   /*! Remove an event from the EventManager.
@param event The event to remove.
 */
   virtual void unregisterEvent(( String event )) {}
   /*! Check if an event is registered or not.
@param event The event to check.
@return Whether or not the event exists. */
   virtual bool isRegisteredEvent(( String event )) {}
   /*! ~Trigger an event.
@param event The event to trigger.
@param data The data associated with the event.
@return Whether or not the event was dispatched successfully. */
   virtual bool postEvent(( String event, String data )) {}
   /*! Subscribe a listener to an event.
@param listener The listener to subscribe.
@param event The event to subscribe to.
@param callback Optional method name to receive the event notification. If this is not specified, "on[event]" will be used.
@return Whether or not the subscription was successful. */
   virtual bool subscribe(( SimObject listener, String event, String callback )) {}
   /*! Remove a listener from an event.
@param listener The listener to remove.
@param event The event to be removed from.
 */
   virtual void remove(( SimObject listener, String event )) {}
   /*! Remove a listener from all events.
@param listener The listener to remove.
 */
   virtual void removeAll(( SimObject listener )) {}
   /*! Print all registered events to the console. */
   virtual void dumpEvents(()) {}
   /*! Print all subscribers to an event to the console.
@param event The event whose subscribers are to be printed. If this parameter isn't specified, all events will be dumped. */
   virtual void dumpSubscribers(( String event )) {}
   /*!
   List of events currently waiting
   
    */
   string queue;
};

/*!
@brief Base class for messages

Message is the base class for C++ defined messages, and may also be used in script for script defined messages if no C++ subclass is appropriate.

Messages are reference counted and will be automatically deleted when their reference count reaches zero. When you dispatch a message, a reference will be added before the dispatch and freed after the dispatch. This allows for temporary messages with no additional code. If you want to keep the message around, for example to dispatch it to multiple queues, call addReference() before dispatching it and freeReference() when you are done with it. Never delete a Message object directly unless addReference() has not been called or the message has not been dispatched.

Message IDs are pooled similarly to datablocks, with the exception that IDs are reused. If you keep a message for longer than a single dispatch, then you should ensure that you clear any script variables that refer to it after the last freeReference(). If you don't, then it is probable that the object ID will become valid again in the future and could cause hard to track down bugs.

Messages have a unique type to simplify message handling code. For object messages, the type is defined as either the script defined class name or the C++ class name if no script class was defined. The message type may be obtained through the getType() method.

By convention, any data for the message is held in script accessible fields. Messages that need to be handled in C++ as well as script provide the relevant data through persistent fields in a subclass of Message to provide best performance on the C++ side. Script defined messages usually their through dynamic fields, and may be accessed in C++ using the SimObject::getDataField() method.

@ingroup Messaging
 */
class  Message : public SimObject {
  public:
      /*! Script callback when a message is first created and registered.

@tsexample
function Message::onAdd(%this)
{
^// Perform on add code here
}
@endtsexample

 */
      void onAdd();

      /*! Script callback when a message is deleted.

@tsexample
function Message::onRemove(%this)
{
^// Perform on remove code here
}
@endtsexample

 */
      void onRemove();

   /*! Get message type (script class name or C++ class name if no script defined class) */
   virtual string getType(()) {}
   /*! Increment the reference count for this message */
   virtual void addReference(()) {}
   /*! Decrement the reference count for this message */
   virtual void freeReference(()) {}

   /*! @name Ungrouped
   @{ */
   /*! */
   /// @}


   /*! @name Object
   @{ */
   /*! */
   /// @}


   /*! @name Editing
   @{ */
   /*! */
   /// @}


   /*! @name Persistence
   @{ */
   /*! */
   /// @}

};

